diff --git a/NEWS b/NEWS
index b3c117a7..0fbf8098 100644
--- a/NEWS
+++ b/NEWS
@@ -210,5 +210,9 @@ Features/Changes on 1.9.1
 - Improvements on the Quic protocol, retrieve hostname and user agent used.
 - Retrieve the SSL session id from TLS connections
 
+Features/Changes on 1.9.2
+- Shows anomalies by using and extra parameter on the binary.
+- Expose the TCP flags on the python Flows
+
 Features/Changes on master
 - Compile in Windows?
diff --git a/configure.ac b/configure.ac
index e2e44b53..1d6e3bd3 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,4 +1,4 @@
-AC_INIT([aiengine],[1.9.1],[luis.camp0.2009@gmail.com],[],[https://bitbucket.org/camp0/aiengine])
+AC_INIT([aiengine],[1.9.2],[luis.camp0.2009@gmail.com],[],[https://bitbucket.org/camp0/aiengine])
 
 AM_INIT_AUTOMAKE([subdir-objects])
 AM_PROG_LIBTOOL
diff --git a/docs/aiengine.rst b/docs/aiengine.rst
index 0be20e07..9689cbda 100644
--- a/docs/aiengine.rst
+++ b/docs/aiengine.rst
@@ -252,8 +252,8 @@ Most of the engines allows to add sets of IP address in order to monitor or trac
     except urllib2.URLError as e:
         print("Error:", e)
 
-    """ Sets the IPSetManager on the stack for TCP traffic """
-    st.tcp_ip_set_manager = ipset_mng
+    # Sets the IPSetManager on the stack for TCP traffic
+    stack.tcp_ip_set_manager = ipset_mng
 
 
 The comparison about the performance betwwen the IPSet and a IPRadixTree is the following
@@ -334,20 +334,20 @@ Nowadays attacks get complex and complex and with Regex Graphs the user is able
 
 .. code:: python
 
-    """ Create a basic regex for match generic SSL traffic """
+    # Create a basic regex for match generic SSL traffic
     ssl_sig = Regex("SSL Basic regex", b"^\x16\x03")
 
-    """ Create another regex for match the heartbeat packets of SSL """
+    # Create another regex for match the heartbeat packets of SSL
     sig = Regex("SSL Heartbeat", b"^.*\x18\x03(\x01|\x02|\x03).*$")
 
-    """ Link both regex expressions """
+    # Link both regex expressions
     ssl_sig.next_regex = sig
 
-    """ Add the main regex to the variable sm of type RegexManager """
+    # Add the main regex to the variable sm of type RegexManager
     sm.add_regex(ssl_sig)
 
-    """ Link the sm to the current network stack """
-    st.tcp_regex_manager = sm
+    # Link the sm to the current network stack
+    stack.tcp_regex_manager = sm
 
 .. raw:: pdf
 
@@ -420,11 +420,11 @@ Nowadays the quantity of traffic on the networks is massive, according to bla bl
 
 .. code:: python
 
-  d = DomainManager
+  dman = DomainManager()
   for dom in list_banned_domains:
-      d.add_domain_name(DomainName("Banned domain", dom))
+      dman.add_domain_name(DomainName("Banned domain", dom))
   
-  st.set_domain_name_manager(d, "http")
+  stack.set_domain_name_manager(dman, "http")
   
 .. raw:: pdf
 
@@ -447,17 +447,17 @@ The system provides functionality to increase or decrease specific items of a gi
 
 .. code:: python
 
-   st = StackLan()
+   stack = StackLan()
 
-   st.tcp_flows = 0
-   st.udp_flows = 1000000
+   stack.tcp_flows = 0
+   stack.udp_flows = 1000000
 
-   """ Decrease the memory of the rest of UDP protocols """
-   st.decrease_allocated_memory(500000, "sip")
-   st.decrease_allocated_memory(500000, "ssdp")
+   # Decrease the memory of the rest of UDP protocols
+   stack.decrease_allocated_memory(500000, "sip")
+   stack.decrease_allocated_memory(500000, "ssdp")
 
-   """ Increase the DNSInfos of the DNS protocol """
-   st.increase_allocated_memory(1000000, "DNSProtocol")
+   # Increase the DNSInfos of the DNS protocol
+   stack.increase_allocated_memory(1000000, "DNSProtocol")
 
 .. raw:: pdf
 
@@ -493,10 +493,9 @@ Another example for detect attacks over NTP on python
 
       total_ips = dict()
       print("NTP DDoS Checker")
-      c = st.get_counters("NTPProtocol")
 
       # Count the number different ips of the NTP flows
-      for flow in st.udp_flow_manager:
+      for flow in stack.udp_flow_manager:
           if (flow.l7_protocol_name == "NTPProtocol"):
               total_ips[flow.src_ip] = 1
 
@@ -504,8 +503,20 @@ Another example for detect attacks over NTP on python
           print("System under a NTP DDoS attack")
 
 
-  """ On the PacketDispatcher set a timer every 10 seconds """
-  pd.add_timer(scheduler_handler_ntp, 10)
+   def scheduler_handler_tcp_syn():
+
+       print("Checking TCP connections")
+       total_with_no_ack = 0
+
+       for flow in stack.tcp_flow_manager:
+           if (flow.tcp_info.syns > 0 and flow.tcp_info.acks == 0):
+               total_with_no_acks = total_with_no_acks + 1
+
+       if (totak_with_no_ack > limit):
+           print("System under TCP syn attack")
+
+  # On the PacketDispatcher set a timer every 10 seconds
+  pdis.add_timer(scheduler_handler_ntp, 10)
 
 All the protocols supports the usage of the stack method get_counters, that allows to extract crucial information from any of the protocols.
 
@@ -515,7 +526,7 @@ You can use this mechanism for detect anomalies that depends on the time and sen
 
   def fragmentation_handler():
 
-      ipstats = st.get_counters("IP")
+      ipstats = stack.get_counters("IP")
 
       current_ip_packets = ipstats["packets"]
       current_fragmented = ipstats["fragmented packets"]
@@ -526,21 +537,23 @@ You can use this mechanism for detect anomalies that depends on the time and sen
       previous_ip_packets = current_ip_packets
       previous_fragments = current_fragmented
 
-  """ On the PacketDispatcher set a timer every 20 seconds """
-  pd.add_timer(fragmentation_handler, 20)
+  # On the PacketDispatcher set a timer every 20 seconds
+  pdis.add_timer(fragmentation_handler, 20)
 
 
 .. code:: python
 
    """ Get statistics of the BitcoinProtocol """
-   c = st.get_counters("bitcoin")
-   print(c)
+   counters = st.get_counters("bitcoin")
+   print(counters)
    {'transaction': 1450, 'get blocks': 200, 'network addr': 4, 'packets': 14963,
     'inv': 1, 'reject': 0, 'bytes': 1476209, 'ping': 0, 'not found': 0, 
     'alert': 0, 'headers': 0, 'getaddr': 24, 'version': 0, 'version ack': 34,
     'get headers': 12, 'pong': 0, 'getdata': 126, 'mempool': 0, 'block': 0}
     
 
+Also timers can be removed with the method remove_timer from the PacketDispatcher
+
 .. raw:: pdf
 
    PageBreak
@@ -605,20 +618,20 @@ So just choose or write your adaptor and plugin to the stack as the example bell
 
 .. code:: python
 
-    st = pyaiengine.StackLan()
+    stack = pyaiengine.StackLan()
 
-    st.tcp_flows = 163840
-    st.udp_flows = 163840
+    stack.tcp_flows = 163840
+    stack.udp_flows = 163840
 
     # Use your own adaptor (redisAdaptor, cassandraAdaptor, hadoopAdaptor, or whatever)
     db = redisAdaptor()
     db.connect("localhost")
 
-    st.set_udp_database_adaptor(db, 16)
+    stack.set_udp_database_adaptor(db, 16)
 
-    with pyaiengine.PacketDispatcher("eth0") as pd:
-        pd.stack = st
-        pd.run()
+    with pyaiengine.PacketDispatcher("eth0") as pdis:
+        pdis.stack = stack
+        pdis.run()
 
 Here is the information that the engine provides on JSON format.
 
@@ -1137,10 +1150,10 @@ In some cases there is a need for generate evidences of a receive attack or a sp
       """ Some code on the flow """
       flow.evidence = True
 
-  with PacketDispatcher("eth0") as pd:
-        pd.stack = st
-        pd.evidences = True 
-        pd.run()
+  with PacketDispatcher("eth0") as pdis:
+        pdis.stack = stack
+        pdis.evidences = True 
+        pdis.run()
 
 .. raw:: pdf
 
@@ -1154,11 +1167,11 @@ For activate this functionality is just easy as set the variable enable_shell to
 
 .. code:: python
 
-  with PacketDispatcher("eth0") as pd:
-        pd.stack = st
-        """ Enable the internal shell for interact with the engine """
-        pd.enable_shell = True 
-        pd.run()
+  with PacketDispatcher("eth0") as pdis:
+        pdis.stack = stack
+        # Enable the internal shell for interact with the engine
+        pdis.enable_shell = True 
+        pdis.run()
 
 .. code:: lua
 
@@ -1175,14 +1188,14 @@ For manage the engine remotely or localy you can use the property port of the Pa
 .. code:: python
 
   """ Open a UDP socket on port 3000 for allow remote commands"""
-  pd.port = 3000
+  pdis.port = 3000
 
 And access remotely from another process or machine
 
 .. code:: bash
 
    luis@debian:~$ telnet freebsd11 2000
-   pd.show()
+   pdis.show()
    PacketDispatcher(0xd7f5a0) statistics
 	Connected to Lan network stack
 	Capturing from:          enp0s31f6
@@ -1264,7 +1277,7 @@ Some attacks are very dependent of the protocol in use. Incorrect offset of head
     print("HTTP Anomaly detected")
     """ Some extra code here """
 
-  st.set_anomaly_callback(my_function_for_http, "HTTPProtocol")
+  stack.set_anomaly_callback(my_function_for_http, "HTTPProtocol")
 
 The example above shows how to generate make specific use of HTTP anomalies and take advantage and create new detection functions.
 
diff --git a/docs/databaseintegration.rst b/docs/databaseintegration.rst
index e8800c7c..fd224d84 100644
--- a/docs/databaseintegration.rst
+++ b/docs/databaseintegration.rst
@@ -252,18 +252,18 @@ Create a new instance of the DatabaseAdaptor and plug it to the UDP part of the
 .. code:: python
        
     # Use your own adaptor (redisAdaptor, cassandraAdaptor, hadoopAdaptor)
-    db = redisAdaptor()
-    db.connect("localhost")
+    db_redis = redisAdaptor()
+    db_redis.connect("localhost")
 
-    """ The UDP traffic will be updated every 16 packets """ 
-    st.set_udp_database_adaptor(db, 16)
+    # The UDP traffic will be updated every 16 packets
+    stack.set_udp_database_adaptor(db_redis, 16)
      
 Open the network device, attach the stack and let the engine run
 
 .. code:: python
         
-    with pyaiengine.PacketDispatcher("eth0") as pd:
-        pd.stack = st 
-        pd.run()
+    with pyaiengine.PacketDispatcher("eth0") as pdis:
+        pdis.stack = stack
+        pdis.run()
 
 Now you can check the results on the redis/cassandra/hadoop database.
diff --git a/docs/ja3_fingerprints.rst b/docs/ja3_fingerprints.rst
index c664f498..43710cf2 100644
--- a/docs/ja3_fingerprints.rst
+++ b/docs/ja3_fingerprints.rst
@@ -13,8 +13,8 @@ First we load the signatures on a dict() object. The signatures used are form ss
    def load_fingerprints():
 
        # The file has been download from https://sslbl.abuse.ch/blacklist/ja3_fingerprints.rules
-       with open("ja3_fingerprints.rules") as f:
-           for line in f.readlines():
+       with open("ja3_fingerprints.rules") as fja3:
+           for line in fja3.readlines():
                if (not line.startswith("#")):
                    l = line.strip()
                    a = re.split("\(msg:", l)
@@ -79,9 +79,9 @@ The second method is to do the detection on the database adaptor, basically is m
            self.__detections = 0
 
        def update(self, key, data):
-           d = json.loads(data)
-           if (d["layer7"] == "ssl"]):
-               f = d["info"]["fingerprint"]
+           jdata = json.loads(data)
+           if (jdata["layer7"] == "ssl"]):
+               f = jdata["info"]["fingerprint"]
                 if (f):
                     if f in fingerprints:
                         print("WARNING: Malware '%s' on '%s'" % (fingerprints[f], key))
diff --git a/docs/zeusmalware.rst b/docs/zeusmalware.rst
index 8aa06aa8..ada02d77 100644
--- a/docs/zeusmalware.rst
+++ b/docs/zeusmalware.rst
@@ -52,26 +52,26 @@ Create a new virtual stack object used on cloud environments on the main.
 
 .. code:: python
 
-    st = pyaiengine.StackVirtual()
+    stack = pyaiengine.StackVirtual()
 
 Allocate the maximum number of flows on the UDP stack.
 
 .. code:: python
 
-    st.tcp_flows = 500000
-    st.udp_flows = 163840
+    stack.tcp_flows = 500000
+    stack.udp_flows = 163840
 
 Load the malware data on the HTTPProtocol and assign them to the stack
 
 .. code:: python
 
-    st.set_domain_name_manager(loadZeusMalwareData(),"HTTPProtocol")
+    stack.set_domain_name_manager(loadZeusMalwareData(),"HTTPProtocol")
 
 Open the network device, set the previous stack and run the engine
 
 .. code:: python
     
-    with  pyaiengine.PacketDispatcher("eth0") as pd:    
-        pd.stack = st
-        pd.run()
+    with  pyaiengine.PacketDispatcher("eth0") as pdis:
+        pdis.stack = stack
+        pdis.run()
 
diff --git a/examples/ddos.py b/examples/ddos.py
index ffea44f7..6c4d339a 100644
--- a/examples/ddos.py
+++ b/examples/ddos.py
@@ -11,27 +11,28 @@ import sys
 sys.path.append("../src/")
 import pyaiengine
 
-st = None
+stack = None
 
 def scheduler_handler_tcp():
 
     print("TCP DoS Checker")
-    c = st.get_counters("TCPProtocol")
+    counters = stack.get_counters("TCPProtocol")
     # Code the intelligence for detect DDoS based on 
     # combination flags, bytes, packets and so on. 
-    syns = int(c["syns"])
-    synacks = int(c["synacks"])
+    syns = int(counters["syns"])
+    synacks = int(counters["synacks"])
     if (syns > (synacks * 100)):
         print("System under a SYN DoS attack")
 
+    # Check also if there is no ack packets or whatever
+
 def scheduler_handler_ntp():
 
     total_ips = dict()
     print("NTP DDoS Checker")
-    # c = st.get_counters("NTPProtocol")
 
     # Count the number different ips of the NTP flows
-    for flow in st.udp_flow_manager:
+    for flow in stack.udp_flow_manager:
         if (flow.l7_protocol_name == "NTPProtocol"):
             total_ips[flow.src_ip] = 1
 
@@ -41,17 +42,17 @@ def scheduler_handler_ntp():
 if __name__ == '__main__':
 
     # Load an instance of a Network Stack Lan 
-    st = pyaiengine.StackLan()
+    stack = pyaiengine.StackLan()
 
-    st.tcp_flows = 327680
-    st.udp_flows = 163840
+    stack.tcp_flows = 327680
+    stack.udp_flows = 163840
 
     # Create a instace of a PacketDispatcher
     with pyaiengine.PacketDispatcher("ens7") as pd:
-        pd.stack = st
+        pd.stack = stack
         # Sets a handler method that will be call
         # every 5 seconds for check the values
-        pd.set_scheduler(scheduler_handler_tcp,5)
+        pd.set_scheduler(scheduler_handler_tcp, 5)
         pd.run()
 
     sys.exit(0)
diff --git a/examples/jboss_exploit.py b/examples/jboss_exploit.py
index 06a3b627..b54beebf 100644
--- a/examples/jboss_exploit.py
+++ b/examples/jboss_exploit.py
@@ -35,7 +35,7 @@ def callback_uri(flow):
 
 if __name__ == '__main__':
 
-    st = pyaiengine.StackLan()
+    stack = pyaiengine.StackLan()
 
     http_mng = pyaiengine.DomainNameManager()
     dom = pyaiengine.DomainName("My jboss host" ,"52.90.136.228:8080")
@@ -50,13 +50,13 @@ if __name__ == '__main__':
     re.callback = callback_uri
 
     """ Plug the DomainNameManager on the HTTPProtocol """ 
-    st.set_domain_name_manager(http_mng,"HTTPProtocol")
+    stack.set_domain_name_manager(http_mng,"HTTPProtocol")
 
-    st.tcp_flows = 50000
-    st.udp_flows = 16380
+    stack.tcp_flows = 50000
+    stack.udp_flows = 16380
 
     with pyaiengine.PacketDispatcher("eth0") as pd:
-        pd.stack = st
+        pd.stack = stack
         pd.run()
 
     sys.exit(0)
diff --git a/examples/tls_fingerprints.py b/examples/tls_fingerprints.py
index a127ddeb..9788bdd7 100644
--- a/examples/tls_fingerprints.py
+++ b/examples/tls_fingerprints.py
@@ -69,7 +69,7 @@ if __name__ == '__main__':
     """ The detection is maded on the databaseAdaptor """
     db = databaseAdaptor()
 
-    st = pyaiengine.StackLan()
+    stack = pyaiengine.StackLan()
     dm = pyaiengine.DomainNameManager()
     dom = pyaiengine.DomainName("All .com", ".com")
     dom.callback = callback_ssl
@@ -77,21 +77,21 @@ if __name__ == '__main__':
     dm.add_domain_name(dom)
 
     """ The detection is maded on the SSL client hello """
-    st.set_domain_name_manager(dm, "SSLProtocol")
+    stack.set_domain_name_manager(dm, "SSLProtocol")
 
     source = "/home/luis/pcapfiles/malware/2018-09-06-Emotet-infection-with-IcedID-and-AZORult.pcap"
 
-    st.tcp_flows = 500000
-    st.udp_flows = 163840
+    stack.tcp_flows = 500000
+    stack.udp_flows = 163840
 
     """ Depending on where you want to carrie out the detection you set the adaptor or not """
-    st.set_tcp_database_adaptor(db)
+    stack.set_tcp_database_adaptor(db)
 
     with pyaiengine.PacketDispatcher(source) as pd:
-        pd.stack = st
+        pd.stack = stack
         pd.run()
 
-    st.show_protocol_statistics()
+    stack.show_protocol_statistics()
     dm.show()
     sys.exit(0)
 
diff --git a/examples/zeus_malware.py b/examples/zeus_malware.py
index 3ea31dd2..663fece4 100644
--- a/examples/zeus_malware.py
+++ b/examples/zeus_malware.py
@@ -23,7 +23,7 @@ def callback_host(flow):
 
 if __name__ == '__main__':
 
-    st = pyaiengine.StackLan()
+    stack = pyaiengine.StackLan()
 
     data = dict()
     # Load the hosts and Urls on memory
@@ -49,13 +49,13 @@ if __name__ == '__main__':
             data[r_host][1].addURI(r_uri)
 
     """ Plug the DomainNameManager on the HTTPProtocol """ 
-    st.set_domain_name_manager(h_mng, "HTTPProtocol")
+    stack.set_domain_name_manager(h_mng, "HTTPProtocol")
 
-    st.tcp_flows = 500000
-    st.udp_flows = 163840
+    stack.tcp_flows = 500000
+    stack.udp_flows = 163840
 
     with pyaiengine.PacketDispatcher("eth0") as pd:
-        pd.stack = st
+        pd.stack = stack
         pd.run()
 
     print(h_mng)
diff --git a/man/aiengine.1 b/man/aiengine.1
index 1fbd3a0b..7b1aba1c 100644
--- a/man/aiengine.1
+++ b/man/aiengine.1
@@ -1,6 +1,6 @@
 .\" Manpage for AIEngine.
 .\" Contact luis.camp0.2009@gmail.com to correct errors or typos.
-.TH man 8 "21 Nov 2019" "1.9.1" "aiengine man page"
+.TH man 8 "21 Nov 2019" "1.9.2" "aiengine man page"
 .SH NAME
 aiengine \- AIEngine (in binary form) is a next generation network intrusion detection system engine with capabilities of learning without any human intervention, NIDS(Network Intrusion Detection System) functionality, DNS domain classification, network collector and many others.
 .SH SYNOPSIS
@@ -143,6 +143,9 @@ Keep the network flows on memory for static analisys. The TCP and UDP connection
 \fB\-o\fR, \fB\-\-summary\fR
 Shows a summary of protocols, such as bytes, packets, memory comsumption, cache miss.
 .TP
+\fB\-A\fR, \fB\-\-anomalies\fR
+Shows a summary of the anomalies of the packets.
+.TP
 \fB\-h\fR, \fB\-\-help\fR
 display this help and exit
 .TP
diff --git a/src/Cache.h b/src/Cache.h
index 65eaba84..019ca1d2 100644
--- a/src/Cache.h
+++ b/src/Cache.h
@@ -43,7 +43,7 @@ public:
 
     	explicit Cache(const std::string& name);
     	explicit Cache():Cache("") {}
-    	virtual ~Cache() { destroy(items_.size()); }
+    	virtual ~Cache() { destroy((int)items_.size()); }
 
 	static constexpr int classSize = sizeof(A_Type) + sizeof(SharedPointer<A_Type>);
 
@@ -53,7 +53,7 @@ public:
 	void create(int number); 
 	void destroy(int number); 
 
-	int32_t getTotal() const { return items_.size(); }
+	int32_t getTotal() const { return (int32_t)items_.size(); }
 	int32_t getTotalAcquires() const { return total_acquires_; }
 	int32_t getTotalReleases() const { return total_releases_; }
 	int32_t getTotalFails() const { return total_fails_; }
@@ -64,8 +64,8 @@ public:
 	int32_t getCurrentAllocatedMemory() const { return (items_.size() * classSize); }
 	const char *getName() const { return name_.c_str(); }
 
-        void statistics(std::basic_ostream<char> &out); 
-        void statistics() { statistics(std::cout); }
+        void statistics(std::basic_ostream<char> &out) const; 
+        void statistics() const { statistics(std::cout); }
 
 	void setDynamicAllocatedMemory(bool value) { is_dynamic_ = value; }
 	bool isDynamicAllocatedMemory() const { return  is_dynamic_; }
diff --git a/src/Cache_Impl.h b/src/Cache_Impl.h
index b24ed134..5f609d69 100644
--- a/src/Cache_Impl.h
+++ b/src/Cache_Impl.h
@@ -105,11 +105,12 @@ void Cache<A_Type>::destroy(int number) {
 
 
 template <class A_Type> 
-void Cache<A_Type>::statistics(std::basic_ostream<char> &out) {
+void Cache<A_Type>::statistics(std::basic_ostream<char> &out) const {
 
 	const char *units[] = { "KBytes", "MBytes", "GBytes" };
 	const char *unit = "Bytes";
-	int alloc_memory = items_.size() * classSize;
+	int alloc_memory = (int)items_.size() * classSize;
+        const char *dynamic_memory = (isDynamicAllocatedMemory() ? "yes":"no");
 
 	// compute the current memory allocated now on the cache 
 	for(auto i: units) {
@@ -135,8 +136,9 @@ void Cache<A_Type>::statistics(std::basic_ostream<char> &out) {
 	}
 
 	out << name_ << " statistics" << "\n";
+        out << "\t" << "Dynamic memory alloc:   " << std::setw(10) << dynamic_memory << "\n";
 	out << "\t" << "Total items:            " << std::setw(10) << items_.size() << "\n";
-	out << "\t" << "Total allocated:        " << std::setw(9 - std::strlen(cunit)) << calloc_memory << " " << cunit << "\n";
+	out << "\t" << "Total allocated:        " << std::setw(9 - (int)std::strlen(cunit)) << calloc_memory << " " << cunit << "\n";
 	out << "\t" << "Total current alloc:    " << std::setw(9 - std::strlen(unit)) << alloc_memory << " " << unit << "\n";
 	out << "\t" << "Total acquires:         " << std::setw(10) << total_acquires_ << "\n";
 	out << "\t" << "Total releases:         " << std::setw(10) << total_releases_ << "\n";
diff --git a/src/Callback.cc b/src/Callback.cc
index 32e1696a..935cdb55 100644
--- a/src/Callback.cc
+++ b/src/Callback.cc
@@ -139,15 +139,30 @@ void Callback::executeCallback(Flow *flow) {
         }
 }
 
-void Callback::executeCallback() {
+bool Callback::executeCallback() {
 
+	bool correct = true;
         try {
                 [[maybe_unused]] PyGilContext gil_lock;
 
                 boost::python::call<void>(callback_);
-        } catch (std::exception &e) {
-                std::cout << __FILE__ << ":" << __func__ << ":ERROR:" << e.what() << std::endl;
+	} catch (const boost::python::error_already_set& e) {
+
+                if (isatty(fileno(stdout))) {
+                        Color::Modifier red(Color::FG_RED);
+                        Color::Modifier def(Color::FG_DEFAULT);
+                        std::cout << red;
+                        PyErr_Print();
+			std::cout << "The timer has been disabled" << std::endl;
+                        std::cout << def;
+                } else {
+                        PyErr_Print();
+			std::cout << "The timer has been disabled" << std::endl;
+		}
+
+		correct = false;
         }
+	return correct;
 }
 
 #elif defined(RUBY_BINDING)
@@ -220,10 +235,12 @@ void Callback::executeCallback(Flow *flow) {
         }
 }
 
-void Callback::executeCallback() {
+bool Callback::executeCallback() {
 
         if (!NIL_P(callback_))
         	rb_funcall(callback_, rb_intern("call"), 0, 0);
+
+	return true;
 }
 
 void Callback::mark() {
@@ -312,13 +329,18 @@ void Callback::executeCallback(Flow *flow) {
 	}	
 }
 
-void Callback::executeCallback() {
+bool Callback::executeCallback() {
 
+	bool correct = true;
 	lua_rawgeti(L_, LUA_REGISTRYINDEX, ref_function_);
 
        	int ret; 
-       	if ((ret = lua_pcall(L_, 0, 0, 0)) != 0)
+       	if ((ret = lua_pcall(L_, 0, 0, 0)) != 0 {
 		std::cout << __FILE__ << ":" << __func__ << ":ERROR:" << lua_tostring(L_, -1) << std::endl;
+		correct = false;
+	}
+
+	return correct;
 }
 
 #elif defined(GO_BINDING)
diff --git a/src/Callback.h b/src/Callback.h
index 262cdabe..80171f01 100644
--- a/src/Callback.h
+++ b/src/Callback.h
@@ -29,6 +29,7 @@
 #include <config.h>
 #endif
 
+#include <iostream>
 #if defined(PYTHON_BINDING)
 #include "PyGilContext.h"
 #include <boost/python.hpp>
@@ -43,7 +44,7 @@
 #elif defined(GO_BINDING)
 #include "GoaiCallback.h"
 #endif
-#include <iostream>
+#include "Color.h"
 
 namespace aiengine {
 
@@ -60,7 +61,7 @@ public:
 	void setCallbackWithNoArgs(PyObject *callback);
 	void setCallback(PyObject *callback); 
 	void executeCallback(Flow *flow);
-	void executeCallback();
+	bool executeCallback();
 	
 	PyObject *getCallback() const { return callback_; }
 	const char *getCallbackName() const;
diff --git a/src/EvidenceManager.cc b/src/EvidenceManager.cc
index 01844ee9..650ad7fe 100644
--- a/src/EvidenceManager.cc
+++ b/src/EvidenceManager.cc
@@ -128,7 +128,7 @@ std::ostream& operator<< (std::ostream &out, const EvidenceManager &em) {
         unitConverter(alloc_memory, unit);
 
         out << "EvidenceManager(" << &em <<") statistics" << "\n";
-        out << "\t" << "Total bytes on disk:    " << std::setw(9 - unit_disk.length()) << total_bytes << " " << unit << "\n";
+        out << "\t" << "Total bytes on disk:    " << std::setw(9 - (int)unit_disk.length()) << total_bytes << " " << unit << "\n";
         out << "\t" << "Total file allocated:   " << std::setw(9 - unit.length()) << alloc_memory << " " << unit << "\n";
         out << "\t" << "Total write packets:    " << std::setw(10) << em.total_write_packets_ << "\n";
         out << "\t" << "Total files:        " << std::setw(14) << em.total_files_ << std::endl;
diff --git a/src/Flow.cc b/src/Flow.cc
index 8d2ab823..39ce1c18 100644
--- a/src/Flow.cc
+++ b/src/Flow.cc
@@ -86,13 +86,17 @@ void Flow::reset() {
 #if defined(BINDING) 
         is_accept_ = true;
 #endif
+	upstream_ttl = 0;
+	downstream_ttl = 0;
 }
 
-void Flow::showFlowInfo(std::ostream &out) const {
+void Flow::show(std::ostream &out) const {
 
 	if (haveTag() == true)
         	out << " Tag:" << getTag();
 
+	out << " TTL(" << (int)upstream_ttl << "," << (int)downstream_ttl << ")";
+
         if (getPacketAnomaly() != PacketAnomalyType::NONE)
 		out << " Anomaly:" << getFlowAnomalyString();
 
@@ -249,13 +253,15 @@ const char *Flow::__str__() {
 IPAbstractSet& Flow::getIPSet() const { return *ipset.lock().get();}
 #endif
 
-void Flow::showFlowInfo(nlohmann::json &out) const {
+void Flow::show(nlohmann::json &out) const {
 
 	out["ip"]["src"] = address_.getSrcAddrDotNotation();
         out["ip"]["dst"] = address_.getDstAddrDotNotation();
         out["port"]["src"] = source_port_;
         out["port"]["dst"] = dest_port_;
 
+	out["upstream_ttl"] = upstream_ttl;
+	out["downstream_ttl"] = downstream_ttl;
 	out["packets"] = total_packets;
         out["proto"] = protocol_;
         out["bytes"] = total_bytes;
diff --git a/src/Flow.h b/src/Flow.h
index 69bf787e..bd44e103 100644
--- a/src/Flow.h
+++ b/src/Flow.h
@@ -155,6 +155,8 @@ public:
 	int getDuration() const { return (int)(current_time_ - arrive_time_); }
 	std::time_t getArriveTime() const { return arrive_time_; }
 
+	uint8_t upstream_ttl;
+	uint8_t downstream_ttl;
 	int32_t total_bytes;
 	int32_t total_packets_l7;
 	int32_t total_packets;
@@ -205,8 +207,8 @@ public:
 
 	friend std::ostream& operator<< (std::ostream &out, const Flow &flow); 
 
-	void showFlowInfo(std::ostream &out) const;
-	void showFlowInfo(nlohmann::json &out) const;
+	void show(std::ostream &out) const;
+	void show(nlohmann::json &out) const;
 
 #if defined(BINDING)
 
@@ -217,6 +219,8 @@ public:
         int32_t getTotalBytes() const { return total_bytes; }
         int32_t getTotalPacketsLayer7() const { return total_packets_l7; }
         int32_t getTotalPackets() const { return total_packets; }
+	int16_t getUpstreamTTL() const { return (int16_t)upstream_ttl; }
+	int16_t getDownstreamTTL() const { return (int16_t)downstream_ttl; }
 
         Frequencies* getFrequencies() const { return frequencies.get(); }
         PacketFrequencies* getPacketFrequencies() const { return packet_frequencies.get(); }
@@ -224,6 +228,8 @@ public:
         Regex* getRegex() const { return regex.lock().get(); }
 	RegexManager *getRegexManager() const { return regex_mng.get(); }
 
+	TCPInfo* getTCPInfoObject() const { return getTCPInfo().get(); }
+
 	IPAbstractSet* getIPSetInfo() const { return ipset.lock().get(); }
         HTTPInfo* getHTTPInfoObject() const { return getHTTPInfo().get(); }
         SIPInfo* getSIPInfoObject() const { return getSIPInfo().get(); }
diff --git a/src/FlowForwarder.h b/src/FlowForwarder.h
index bd5a26ae..017f01de 100644
--- a/src/FlowForwarder.h
+++ b/src/FlowForwarder.h
@@ -75,7 +75,6 @@ private:
 	int64_t total_forward_flows_ = 0;
 	int64_t total_fail_flows_ = 0;
 	WeakPointer<FlowForwarder> muxDown_ = WeakPointer<FlowForwarder>();
-	uint16_t protocol_id_ = 0; // the protocol analiyzer owned by the multiplexer
     	std::vector<WeakPointer<FlowForwarder>> flowForwarderVector_ {};
 	std::function <void (Flow*)> flow_func_ = [&] (Flow*) { return; };
 	std::function <bool (Packet&)> check_func_ = [&] (Packet&) { return true; };	
diff --git a/src/HTTPSession.cc b/src/HTTPSession.cc
index 3e511c36..24fef9c5 100644
--- a/src/HTTPSession.cc
+++ b/src/HTTPSession.cc
@@ -105,14 +105,13 @@ void HTTPSession::process_request(bhttp::request<bhttp::dynamic_body>&& req) {
         response.content_length(0);
 
 	if (stack_ == nullptr) {
-		const constexpr char *message = "No stack available";
-		constexpr std::size_t len = std::strlen(message);
+		std::string_view message = "No stack available";
 
 		response.keep_alive(false);
 		response.set(bhttp::field::content_type, "text/html");
 		response.result(bhttp::status::service_unavailable);
 		boost::beast::ostream(response.body()) << message;
-		response.content_length(len);
+		response.content_length(message.length());
 
         	AIINFO << req.method() << " " << req.target()
                 	<< " " << response[bhttp::field::content_type] << " " << response.result_int();
@@ -548,8 +547,11 @@ void HTTPSession::upload_pcapfile(bhttp::response<bhttp::dynamic_body> &response
         // Now get the filename and the content type to verify that is a pcap file
 
         std::ostringstream body;
+#if BOOST_BEAST_VERSION >= 266 
+        body << boost::beast::make_printable(request.body().data());
+#else
         body << boost::beast::buffers(request.body().data());
-
+#endif
         std::string boundary(ct.substr(off + 9));
 
         if (off = body.str().find(boundary); off == std::string::npos) {
@@ -617,7 +619,11 @@ void HTTPSession::upload_python_script(bhttp::response<bhttp::dynamic_body> &res
         boost::beast::string_view ct = request[bhttp::field::content_type];
 	std::string code;
         std::ostringstream body, out;
+#if BOOST_BEAST_VERSION >= 266 
+        body << boost::beast::make_printable(request.body().data());
+#else
         body << boost::beast::buffers(request.body().data());
+#endif
         response.content_length(0);
 
         if (off = ct.find("multipart/form-data"); off != std::string::npos) {
@@ -654,12 +660,18 @@ void HTTPSession::upload_python_script(bhttp::response<bhttp::dynamic_body> &res
 
 	if (code.length() > 0) {
         	std::ostringstream filename, scode;
-		std::error_code ec;
 		int pid = getpid();
 
 		filename << "/tmp/aiengine.pcode." << pid;
-		std::filesystem::resize_file(filename.str(), 0, ec); // truncate file
+#if defined(IS_DARWIN)
+		boost::system::error_code ec;
 
+		boost::filesystem::resize_file(filename.str(), 0, ec); // truncate file
+#else
+		std::error_code ec;
+
+		std::filesystem::resize_file(filename.str(), 0, ec); // truncate file
+#endif
 		// We create a execution with a redirection of the output
 		// bear in mind that the user could put print statements 
 		// so we need to redirect properly the things
@@ -724,6 +736,10 @@ SharedPointer<Flow> HTTPSession::get_flow_from_uri(const std::string &uri) const
         std::string addrsrc, addrdst;
         int portsrc, portdst, proto;
 
+	// The URI can have encoded charaters for [] so need to replace them
+	boost::replace_all(address, "%5B", "[");
+	boost::replace_all(address, "%5D", "]");
+
         // Do a basic parsing
         qi::phrase_parse(address.begin(), address.end(),
                 qi::lit("[") >> *(~qi::char_("") - "]") >> qi::lit("]:") >>
@@ -771,11 +787,11 @@ void HTTPSession::show_network_flow(bhttp::response<bhttp::dynamic_body> &respon
 			nlohmann::json j;
 			response.set(bhttp::field::content_type, "application/json");
 
-			flow->showFlowInfo(j);
+			flow->show(j);
 			out << j;
 		} else {
 			response.set(bhttp::field::content_type, "text/plain");
-			const char *ev = flow->haveEvidence() ? "yes": "no";
+			std::string_view ev = flow->haveEvidence() ? "yes": "no";
 
 			std::time_t duration = std::time(nullptr) - flow->getArriveTime();
 			out << "Network flow:" << *flow << "\n";
@@ -784,7 +800,7 @@ void HTTPSession::show_network_flow(bhttp::response<bhttp::dynamic_body> &respon
 			out << "Bytes:" << flow->total_bytes << "\n";
 			out << "Packets:" << flow->total_packets << "\n";
 			out << "Duration:" << (int)duration << " secs\n";
-			flow->showFlowInfo(out);
+			flow->show(out);
 		}
 	} else  
                 response.result(bhttp::status::not_found);
@@ -809,8 +825,12 @@ void HTTPSession::update_network_flow(bhttp::response<bhttp::dynamic_body> &resp
         if (content_type.compare("application/json") == 0) {
 		std::string uri(request.target());
                 std::ostringstream bodydata;
-                bodydata << boost::beast::buffers(request.body().data());
 
+#if BOOST_BEAST_VERSION >= 266 
+        	bodydata << boost::beast::make_printable(request.body().data());
+#else
+        	bodydata << boost::beast::buffers(request.body().data());
+#endif
         	uri.erase(0, strlen(http_uri_show_network_flow));
 
         	if (SharedPointer<Flow> flow = get_flow_from_uri(uri); flow) {
@@ -818,13 +838,12 @@ void HTTPSession::update_network_flow(bhttp::response<bhttp::dynamic_body> &resp
 
                 	nlohmann::json j = nlohmann::json::parse(bodydata.str(), nullptr, false);
                 	if (j.is_discarded()) {
-                        	const constexpr char *message = "Not valid json content";
-                        	constexpr std::size_t len = std::strlen(message);
+                        	std::string_view message = "Not valid json content";
 
                         	response.set(bhttp::field::content_type, "text/html");
                         	response.result(bhttp::status::bad_request);
                         	boost::beast::ostream(response.body()) << message;
-                        	response.content_length(len);
+                        	response.content_length(message.length());
                 	} else {
 				// The user wants to change the label of the flow
 				if (j.find("label") != j.end(); j["label"].is_string())
diff --git a/src/HTTPSession.h b/src/HTTPSession.h
index 0a93215e..ca470414 100644
--- a/src/HTTPSession.h
+++ b/src/HTTPSession.h
@@ -33,7 +33,11 @@
 #include <boost/beast/version.hpp>
 #include <boost/asio/ip/tcp.hpp>
 #include <boost/asio.hpp>
+#if !defined(IS_DARWIN)
 #include <filesystem>
+#else
+#include <boost/filesystem.hpp>
+#endif
 #include "Pointer.h"
 #include "json.hpp"
 #include "NetworkStack.h"
@@ -146,7 +150,6 @@ private:
 	bhttp::request<bhttp::dynamic_body> request;
         send_lambda send_response;
         std::string ipsrc = "";
-        int portsrc = 0;
         int32_t total_requests_ = 0;
         int32_t total_responses_ = 0;
         int64_t total_bytes_ = 0;
diff --git a/src/Interpreter.cc b/src/Interpreter.cc
index ce93a594..8f79bfe5 100644
--- a/src/Interpreter.cc
+++ b/src/Interpreter.cc
@@ -52,11 +52,11 @@ void Interpreter::start() {
 
 	shell_enable_ = true;
 #if defined(PYTHON_BINDING) 
-	const char *interpreter_banner = "Python " PY_VERSION;
+	std::string_view interpreter_banner = "Python " PY_VERSION;
 #elif defined(RUBY_BINDING)
-	const char *interpreter_banner = "Ruby";
+	std::string_view interpreter_banner = "Ruby";
 #elif  defined(LUA_BINDING)
-	const char *interpreter_banner = LUA_VERSION;
+	std::string_view interpreter_banner = LUA_VERSION;
 #endif
 	std::ostringstream msg;
        	msg << interpreter_banner << " AIEngine " << VERSION << " shell enable on ";
diff --git a/src/Multiplexer.h b/src/Multiplexer.h
index 4b1300c1..d2e41c49 100644
--- a/src/Multiplexer.h
+++ b/src/Multiplexer.h
@@ -72,7 +72,7 @@ public:
         void statistics(std::basic_ostream<char> &out);
         void statistics() { statistics(std::cout); }
 
-	int getNumberUpMultiplexers() const { return muxUpMap_.size(); }
+	int getNumberUpMultiplexers() const { return (int)muxUpMap_.size(); }
 
 	void setProtocolIdentifier(uint16_t protocol_id) { protocol_id_ = protocol_id; }
 	uint16_t getProtocolIdentifier() const { return protocol_id_; }
@@ -109,7 +109,6 @@ private:
 	uint64_t total_fail_packets_ = 0;
 	MultiplexerPtrWeak muxDown_ = MultiplexerPtrWeak();
 	int header_size_ = 0;
-	int offset_ = 0;
 	uint16_t protocol_id_ = NO_PROTOCOL_SELECTED; // the protocol analiyzer owned by the multiplexer
 	uint16_t next_protocol_id_ = NO_PROTOCOL_SELECTED; // the next protocol to check by the multiplexer
     	typedef std::unordered_map<int,MultiplexerPtrWeak> MuxMap;
diff --git a/src/NetworkStack.cc b/src/NetworkStack.cc
index 567dbcab..c4689b0b 100644
--- a/src/NetworkStack.cc
+++ b/src/NetworkStack.cc
@@ -326,8 +326,6 @@ void NetworkStack::statistics(std::basic_ostream<char> &out, int level) const {
 				out << std::endl;
 			}
 		});
-		anomaly_->statistics(out);	
-		out << std::endl;
 	}
 }
 
@@ -463,12 +461,6 @@ void NetworkStack::disableProtocol(const std::string &name) {
 }
 
 #if defined(PYTHON_BINDING)
-void NetworkStack::showCache(const std::string &name) {
-
-        if (ProtocolPtr pp = get_protocol(name); pp)
-                pp->showCache(OutputManager::getInstance()->out());
-}
-
 void NetworkStack::setUDPDatabaseAdaptor(boost::python::object &dbptr) {
 
 	setUDPDatabaseAdaptor(dbptr, default_update_frequency);
@@ -587,15 +579,24 @@ boost::python::dict NetworkStack::getCounters(const std::string &name) {
         return counters;
 }
 
-boost::python::dict NetworkStack::getCache(const std::string &name) {
+boost::python::dict NetworkStack::getCacheData(const std::string &protocol, const std::string &name) {
         boost::python::dict cache;
 
-        if (ProtocolPtr pp = get_protocol(name); pp)
-                cache = pp->getCache();
+        if (ProtocolPtr pp = get_protocol(protocol); pp)
+                cache = pp->getCacheData(name);
 
         return cache;
 }
 
+SharedPointer<Cache<StringCache>> NetworkStack::getCache(const std::string &protocol, const std::string &name) {
+	SharedPointer<Cache<StringCache>> cache = nullptr;
+
+        if (ProtocolPtr pp = get_protocol(protocol); pp)
+		return pp->getCache(name);
+
+	return cache;
+} 
+
 #elif defined(RUBY_BINDING)
 
 VALUE NetworkStack::getCounters(const std::string &name) {
@@ -609,11 +610,11 @@ VALUE NetworkStack::getCounters(const std::string &name) {
 	return counters;
 }
 
-VALUE NetworkStack::getCache(const std::string &name) {
+VALUE NetworkStack::getCacheData(const std::string &protocol, const std::string &name) {
 	VALUE cache = Qnil;
 
-	if (ProtocolPtr pp = get_protocol(name); pp)
-		cache = pp->getCache();
+	if (ProtocolPtr pp = get_protocol(protocol); pp)
+		cache = pp->getCacheData(name);
 
 	return cache;
 }
@@ -809,7 +810,7 @@ void NetworkStack::showProtocolSummary(std::basic_ostream<char> &out) const {
 		total_bytes = proto->getTotalBytes();
 	}	
 
-	out << "Protocol statistics summary" << std::endl;
+	out << "Protocol statistics summary\n";
 	out << "\t" << boost::format(header) % "Protocol" % "Bytes" % "Packets" % "% Bytes" % "CacheMiss" % "Memory" % "UseMemory" % "CacheMemory" % "Dynamic" % "Events";
 	out << std::endl;
 
@@ -837,7 +838,7 @@ void NetworkStack::showProtocolSummary(std::basic_ostream<char> &out) const {
 		if (total_bytes > 0) 
 			per = ( bytes * 100.00) / total_bytes; 
 
-		const char *dynamic_mem = proto->isDynamicAllocatedMemory() ? "yes": "no";
+		std::string_view dynamic_mem = proto->isDynamicAllocatedMemory() ? "yes": "no";
 
 		std::string unit = "Bytes";
 		std::string used_unit = "Bytes";
diff --git a/src/NetworkStack.h b/src/NetworkStack.h
index 863f3d30..20869958 100644
--- a/src/NetworkStack.h
+++ b/src/NetworkStack.h
@@ -134,7 +134,6 @@ public:
 	void enableProtocol(const std::string &name);
 	void disableProtocol(const std::string &name);
 
-	void showAnomalies() const { anomaly_->statistics(OutputManager::getInstance()->out()); }
 	void showProtocolSummary() const { showProtocolSummary(OutputManager::getInstance()->out()); }
 
 	virtual FlowManager& getTCPFlowManager() = 0;
@@ -172,15 +171,14 @@ public:
 	virtual void setUDPIPSetManager(const SharedPointer<IPSetManager> &ipset_mng) { udp_ipset_mng_ = ipset_mng; }
 
 #if defined(PYTHON_BINDING)
-	void showCache(const std::string &name);
-
 	void setTCPDatabaseAdaptor(boost::python::object &dbptr);
 	void setTCPDatabaseAdaptor(boost::python::object &dbptr, int packet_sampling);
 	void setUDPDatabaseAdaptor(boost::python::object &dbptr);
 	void setUDPDatabaseAdaptor(boost::python::object &dbptr, int packet_sampling);
 
 	boost::python::dict getCounters(const std::string &name);
-	boost::python::dict getCache(const std::string &name);
+	boost::python::dict getCacheData(const std::string &protocol, const std::string &name);
+	SharedPointer<Cache<StringCache>> getCache(const std::string &protocol, const std::string &name);
 
 	SharedPointer<RegexManager> getTCPRegexManager() const { return tcp_regex_mng_; }
 	SharedPointer<RegexManager> getUDPRegexManager() const { return udp_regex_mng_; }
@@ -199,7 +197,7 @@ public:
 	void setUDPDatabaseAdaptor(VALUE dbptr, int packet_sampling);
 
 	VALUE getCounters(const std::string &name);
-	VALUE getCache(const std::string &name);
+	VALUE getCacheData(const std::string &protocol, const std::string &name);
 
 	void setAnomalyCallback(VALUE callback, const std::string &proto_name);
 
@@ -248,6 +246,7 @@ public:
 
 	void showProtocolSummary(std::basic_ostream<char> &out) const;
 	void showProtocolSummary(nlohmann::json &out) const;
+	void showAnomalies() const { anomaly_->statistics(OutputManager::getInstance()->out()); }
 
 	friend std::ostream& operator<< (std::ostream &out, const NetworkStack &ns);
 
diff --git a/src/Packet.cc b/src/Packet.cc
index 3dc52cf6..52321dc5 100644
--- a/src/Packet.cc
+++ b/src/Packet.cc
@@ -48,6 +48,7 @@ Packet::Packet(const Packet &p):
 	dest_port_(p.dest_port_),
 	pa_(p.pa_),
 	packet_time_(p.packet_time_),
+	ttl_(p.ttl_),
 	have_tag_(p.have_tag_),
 	have_evidence_(p.have_evidence_),
 	force_adaptor_write_(p.force_adaptor_write_),
diff --git a/src/Packet.h b/src/Packet.h
index 169963dc..b1ae1a1e 100644
--- a/src/Packet.h
+++ b/src/Packet.h
@@ -136,6 +136,9 @@ public:
 	int getLength()  { return curr_packet.getLength(); }
 	int getPrevHeaderSize()  { return prev_header_size_; }
 
+	void setTTL(uint8_t ttl) { ttl_ = ttl; }
+	uint8_t getTTL() const { return ttl_; }
+
 	friend std::ostream& operator<<(std::ostream &os, const Packet &p); 
 
 	RawPacket curr_packet;
@@ -149,6 +152,7 @@ private:
 	uint16_t dest_port_ = 0;
 	PacketAnomalyType pa_ = PacketAnomalyType::NONE;
 	time_t packet_time_ = 0;
+	uint8_t ttl_ = 0;
 	bool have_tag_ = false;
 	bool have_evidence_ = false;
 	bool force_adaptor_write_ = false; // Force to call the databaseAdaptor update method
diff --git a/src/PacketDispatcher.cc b/src/PacketDispatcher.cc
index b670e588..78281cb8 100644
--- a/src/PacketDispatcher.cc
+++ b/src/PacketDispatcher.cc
@@ -104,7 +104,7 @@ int PacketDispatcher::get_mtu_of_network_device(const std::string &name) {
 void PacketDispatcher::open_device(const std::string &device) {
 
 	char errorbuf[PCAP_ERRBUF_SIZE];
-#if defined(IS_FREEBSD)
+#if defined(IS_FREEBSD) || defined(IS_DARWIN)
 	int timeout = 1000; // miliseconds
 #else
 	int timeout = -1;
@@ -566,6 +566,11 @@ void PacketDispatcher::addTimer(PyObject *callback, int seconds) {
 	tm_->addTimer(callback, seconds);
 }
 
+void PacketDispatcher::removeTimer(int seconds) {
+
+	tm_->removeTimer(seconds);
+}
+
 #elif defined(RUBY_BINDING)
 void PacketDispatcher::addTimer(VALUE callback, int seconds) {
 
@@ -878,10 +883,14 @@ void PacketDispatcher::accept_http_connections() {
 
                                 	// Start processing the HTTP
                                 	conn->start();
-				} else 
+				} else {
+					AIWARN << "No stack plugged to the PacketDispatcher";
 					http_socket_.close();
-                        } else 
+				}
+                        } else {
+				AIWARN << "IP addresss " << ipaddress << " not allowed";
                                 http_socket_.close();
+			}
                 }
                 accept_http_connections();
         });
diff --git a/src/PacketDispatcher.h b/src/PacketDispatcher.h
index e740e926..6cff7768 100644
--- a/src/PacketDispatcher.h
+++ b/src/PacketDispatcher.h
@@ -140,6 +140,7 @@ public:
 
 	void forwardPacket(const std::string &packet, int length);
 	void addTimer(PyObject *callback, int seconds);
+	void removeTimer(int seconds);
 
 	void setPort(int port);
 	int getPort() const;
diff --git a/src/Protocol.cc b/src/Protocol.cc
index efd13c15..774b6fef 100644
--- a/src/Protocol.cc
+++ b/src/Protocol.cc
@@ -219,7 +219,7 @@ void Protocol::databaseAdaptorUpdateHandler(Flow *flow) {
 	data_.clear();
 
         key_ << *flow;
-	flow->showFlowInfo(j);
+	flow->show(j);
 
 	data_ << j;
 
@@ -402,7 +402,7 @@ void Protocol::showStatisticsHeader(std::basic_ostream<char> &out, int level) {
         if (level > 0) {
                 int64_t alloc_memory = getAllocatedMemory();
                 std::string unit = "Bytes";
-                const char *dynamic_memory = (isDynamicAllocatedMemory() ? "yes":"no");
+                std::string_view dynamic_memory = (isDynamicAllocatedMemory() ? "yes":"no");
 
                 unitConverter(alloc_memory, unit);
 
diff --git a/src/Protocol.h b/src/Protocol.h
index d88e6969..c8d949ba 100644
--- a/src/Protocol.h
+++ b/src/Protocol.h
@@ -171,16 +171,15 @@ public:
 	virtual CounterMap getCounters() const = 0;
 
 #if defined(PYTHON_BINDING)
-	virtual boost::python::dict getCache() const { return boost::python::dict(); }
-
-	virtual void showCache(std::basic_ostream<char> &out) const {};
+	virtual boost::python::dict getCacheData(const std::string &name) const { return boost::python::dict(); }
+	virtual SharedPointer<Cache<StringCache>> getCache(const std::string &name) { return nullptr; }
 
 	void setDatabaseAdaptor(boost::python::object &dbptr, int packet_sampling);  
 
 	boost::python::dict addMapToHash(const GenericMapType &mt, const char *header = "") const;
 
 #elif defined(RUBY_BINDING)
-	virtual VALUE getCache() const { return Qnil; }
+	virtual VALUE getCacheData(const std::string &name) const { return Qnil; }
 	void setDatabaseAdaptor(VALUE dbptr, int packet_sampling);  
 	
 	VALUE addMapToHash(const GenericMapType &mt, const char *header = "") const;
@@ -223,7 +222,6 @@ protected:
 private:
 	std::string name_ = "";
 	std::string short_name_ = "";
-	uint16_t protocol_id_ = 0;
 	uint16_t protocol_layer_ = 0; // TCP or UDP
 	std::time_t last_cache_log_fail_ = 0;
 	bool is_active_ = false;
diff --git a/src/StringCache.cc b/src/StringCache.cc
index 12030fd3..f03bfa6d 100644
--- a/src/StringCache.cc
+++ b/src/StringCache.cc
@@ -52,7 +52,7 @@ void StringCache::setName(const char *name, int length) {
 
 void StringCache::setName(const char *name) { 
 
-	setName(name, std::strlen(name));
+	setName(name, (int)std::strlen(name));
 }
 
 } // namespace aiengine  
diff --git a/src/TimerManager.cc b/src/TimerManager.cc
index 940507c7..fbd9105f 100644
--- a/src/TimerManager.cc
+++ b/src/TimerManager.cc
@@ -36,10 +36,25 @@ void TimerManager::start_timer(const SharedPointer<Timer> t) {
 
 void TimerManager::stop_timer(const SharedPointer<Timer> t) {
 
-	// t->setCallbackWithNoArgs(nullptr);
 	t->timer->cancel();
 }
 
+void TimerManager::removeTimer(int seconds) {
+
+	remove_timer(seconds);
+}
+
+void TimerManager::remove_timer(int seconds) {
+
+	auto it = timers_.find(seconds);
+	if (it != timers_.end()) {
+		SharedPointer<Timer> t = (*it).second;
+
+		stop_timer(t);
+		timers_.erase(it);
+	}
+}
+
 void TimerManager::scheduler_handler(boost::system::error_code error, const WeakPointer<Timer> wt) {
 
 	if (wt.expired()) {
@@ -60,9 +75,10 @@ void TimerManager::scheduler_handler(boost::system::error_code error, const Weak
                	return;
        	}
 
-	t->executeCallback();
-
-	start_timer(t);
+	if (t->executeCallback() == true)
+		start_timer(t);
+	else // The callback generates an exception so remove the timer
+		remove_timer(t->seconds);
 
        	return;
 }
@@ -83,14 +99,8 @@ void TimerManager::addTimer(lua_State* L, const char *callback, int seconds) {
 #elif defined(LUA_BINDING)
 	if (callback == nullptr) {
 #endif
-		// Find any Timer for that seconds
-		auto it = timers_.find(seconds);
-        	if (it != timers_.end()) {
-			SharedPointer<Timer> t = (*it).second;
-
-        		stop_timer(t);	
-			timers_.erase(it);
-		}
+		// Find any Timer for that seconds and remove it
+		remove_timer(seconds);
         } else {
 		// Verify that the object/callback or whatever can be called
 #if defined(PYTHON_BINDING)
diff --git a/src/TimerManager.h b/src/TimerManager.h
index bac8b2d7..bf3e8f3b 100644
--- a/src/TimerManager.h
+++ b/src/TimerManager.h
@@ -48,14 +48,17 @@ public:
 
 #if defined(PYTHON_BINDING)
 	void addTimer(PyObject *callback, int seconds);
+	void removeTimer(int seconds);
 	void statistics(std::basic_ostream<char> &out) const;
 	friend std::ostream& operator<< (std::ostream &out, const TimerManager &tm);
 #elif defined(LUA_BINDING)
 	void addTimer(lua_State* L, const char *callback, int seconds);
+	void removeTimer(int seconds);
 	void statistics(std::basic_ostream<char> &out) const;
 	friend std::ostream& operator<< (std::ostream &out, const TimerManager &tm);
 #elif defined(RUBY_BINDING)
 	void addTimer(VALUE callback, int seconds);
+	void removeTimer(int seconds);
 	void statistics(std::basic_ostream<char> &out) const;
 	friend std::ostream& operator<< (std::ostream &out, const TimerManager &tm);
 #endif
@@ -64,6 +67,7 @@ private:
 #if defined(PYTHON_BINDING) || defined(RUBY_BINDING) || defined(LUA_BINDING)
  	void start_timer(const SharedPointer<Timer> timer); 
  	void stop_timer(const SharedPointer<Timer> timer); 
+	void remove_timer(int seconds);
 	void scheduler_handler(boost::system::error_code error, const WeakPointer<Timer> timer); 
 #endif
 	boost::asio::io_service &io_service_;
diff --git a/src/common.mk b/src/common.mk
index 83035202..233a5555 100644
--- a/src/common.mk
+++ b/src/common.mk
@@ -20,3 +20,9 @@ TEST_FLOW_OBJECTS =     ../dns/DNSInfo.cc \
 			../quic/QuicInfo.cc \
 			../frequency/Frequencies.cc \
 			../frequency/PacketFrequencies.cc
+
+if IS_DARWIN
+  LOGGING_FLAGS = -lboost_log-mt -lboost_thread-mt
+else
+  LOGGING_FLAGS = -lboost_log -lboost_thread
+endif
diff --git a/src/flow/FlowCache.h b/src/flow/FlowCache.h
index 52ac9e5d..f9b6a689 100644
--- a/src/flow/FlowCache.h
+++ b/src/flow/FlowCache.h
@@ -65,11 +65,11 @@ public:
 		}
 
 		out << "FlowCache statistics" << std::endl;
-		out << "\t" << "Total flows:            " << std::setw(10) << getTotalFlows() <<std::endl;
-		out << "\t" << "Total allocated:        " << std::setw(9 - std::strlen(unit)) << alloc_memory << " " << unit <<std::endl;
-		out << "\t" << "Total acquires:         " << std::setw(10) << getTotalAcquires() <<std::endl;
-		out << "\t" << "Total releases:         " << std::setw(10) << getTotalReleases() <<std::endl;
-		out << "\t" << "Total fails:            " << std::setw(10) << getTotalFails() <<std::endl;
+		out << "\t" << "Total flows:            " << std::setw(10) << getTotalFlows() << "\n";
+		out << "\t" << "Total allocated:        " << std::setw(9 - (int)std::strlen(unit)) << alloc_memory << " " << unit << "\n";
+		out << "\t" << "Total acquires:         " << std::setw(10) << getTotalAcquires() << "\n";
+		out << "\t" << "Total releases:         " << std::setw(10) << getTotalReleases() << "\n";
+		out << "\t" << "Total fails:            " << std::setw(10) << getTotalFails() << std::endl;
 	}
 
         void statistics() { statistics(std::cout);}
diff --git a/src/flow/FlowManager.cc b/src/flow/FlowManager.cc
index 8c04634c..e9e8a443 100644
--- a/src/flow/FlowManager.cc
+++ b/src/flow/FlowManager.cc
@@ -32,7 +32,6 @@ namespace aiengine {
 
 FlowManager::FlowManager(const std::string &name):
 	name_(name),
-	now_({0, 0}),
 	total_process_flows_(0),
 	total_timeout_flows_(0),
 	timeout_(flowTimeout),
@@ -259,14 +258,14 @@ void FlowManager::print_pretty_flow(std::basic_ostream<char> &out, const Flow &f
 
 	out << boost::format("%-64s %-10d %-10d %-18s") % fivetuple.str() % flow.total_bytes % flow.total_packets % proto_name;
 
-	flow.showFlowInfo(out);
+	flow.show(out);
 }
 
 void FlowManager::print_pretty_flow(nlohmann::json &out, const Flow &flow, const char *proto_name) const {
 
 	out["name"] = proto_name;
 
-        flow.showFlowInfo(out);
+        flow.show(out);
 }
 
 void FlowManager::showFlows(int limit) const {
@@ -416,8 +415,8 @@ SharedPointer<Flow> FlowManager::findFlow(const char *ipsrc, int portsrc, int pr
        uint32_t ipsrc4 = inet_addr(ipsrc);
 
        if (ipsrc4 == INADDR_NONE) { // The address is IPv6
-               struct in6_addr src6 = { 0 };
-               struct in6_addr dst6 = { 0 };
+               struct in6_addr src6 = {{ .__u6_addr32 = { 0, 0, 0, 0}}};
+               struct in6_addr dst6 = {{ .__u6_addr32 = { 0, 0, 0, 0}}};
 
                inet_pton(AF_INET6, ipsrc, &src6);
                inet_pton(AF_INET6, ipdst, &dst6);
diff --git a/src/flow/FlowManager.h b/src/flow/FlowManager.h
index 90b1f361..d5ddeeec 100644
--- a/src/flow/FlowManager.h
+++ b/src/flow/FlowManager.h
@@ -88,7 +88,7 @@ public:
 
 	void setTimeout(int timeout) { timeout_ = timeout; }
 	int getTimeout() const { return timeout_; }
-	int getTotalFlows() const { return flowTable_.size();}
+	int getTotalFlows() const { return (int)flowTable_.size();}
 
 	int32_t getTotalProcessFlows() const { return total_process_flows_;}
 	int32_t getTotalTimeoutFlows() const { return total_timeout_flows_;}
@@ -103,7 +103,7 @@ public:
 	void showFlows(nlohmann::json &out, int limit) const;
 	void showFlows(nlohmann::json &out, int limit, const std::string &protoname) const;
 
-	int32_t getAllocatedMemory() const { return (flowTable_.size() * FlowCache::flowSize); }
+	int32_t getAllocatedMemory() const { return ((int)flowTable_.size() * FlowCache::flowSize); }
 
 	// Method for flush the flows of the FlowManager in order to analyse more times
 	// This method just retrieve the flows to their corresponding caches and frees the 
@@ -139,11 +139,10 @@ private:
 	void release_flow(const SharedPointer<Flow> &flow);
 
 	std::string name_;
-    	timeval now_;
 	int32_t total_process_flows_ = 0;
 	int32_t total_timeout_flows_ = 0;
 	int timeout_ = flowTimeout;
-	bool release_flows_;
+	bool release_flows_ = false;
     	FlowTable flowTable_;
 	FlowByID::iterator flow_it_; // a cacheable iterator
 	FlowCachePtr flow_cache_ = nullptr;
diff --git a/src/flow/Makefile.am b/src/flow/Makefile.am
index 96dfb737..aad5929f 100644
--- a/src/flow/Makefile.am
+++ b/src/flow/Makefile.am
@@ -1,3 +1,5 @@
+include $(top_srcdir)/src/common.mk
+
 AUTOMAKE_OPTIONS = gnu
 
 TEST = test_flows 
@@ -31,7 +33,7 @@ test_flows_SOURCES =     ../Flow.cc ../IPAddress.cc \
 			../AnomalyManager.cc FlowManager.cc test_flows.cc
 
 test_flows_LDFLAGS   = $(EXTRA_TEST_LDFLAGS)
-test_flows_LDADD   = $(BOOST_LDFLAGS) -lboost_thread -lboost_unit_test_framework
+test_flows_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/flow/test_flows.cc b/src/flow/test_flows.cc
index 3047dedd..d6998561 100644
--- a/src/flow/test_flows.cc
+++ b/src/flow/test_flows.cc
@@ -237,7 +237,7 @@ BOOST_AUTO_TEST_CASE (test07)
 	f1->setFiveTuple(inet_addr("192.168.1.1"), 2345, IPPROTO_TCP, inet_addr("54.12.5.1"), 80);
 
 	nlohmann::json j;
-	f1->showFlowInfo(j);
+	f1->show(j);
 
 	BOOST_CHECK(j["bytes"] == 0);
 	BOOST_CHECK(j["ip"]["dst"] == "54.12.5.1");
diff --git a/src/ipset/IPRadixTree.cc b/src/ipset/IPRadixTree.cc
index d800f6bf..b44a863f 100644
--- a/src/ipset/IPRadixTree.cc
+++ b/src/ipset/IPRadixTree.cc
@@ -46,7 +46,7 @@ IPRadixTree::IPRadixTree(const std::string &name, boost::python::list &ips):
 
 int32_t IPRadixTree::getTotalBytes() const {
 
-	int32_t value = rttable_.size() * sizeof(IPRadixEntry);
+	int32_t value = (int)rttable_.size() * sizeof(IPRadixEntry);
 
 	return value;
 }
diff --git a/src/ipset/IPSet.cc b/src/ipset/IPSet.cc
index 93ca56bf..75dd48ea 100644
--- a/src/ipset/IPSet.cc
+++ b/src/ipset/IPSet.cc
@@ -58,7 +58,7 @@ IPSet::IPSet(const std::string &name, boost::python::list &ips, boost::python::o
 
 int32_t IPSet::getTotalBytes() const {
 
-	int32_t value = imap_.size() * sizeof(uint32_t);
+	int32_t value = (int)imap_.size() * sizeof(int32_t);
 
 	for (auto &it: smap_) 
 		value += it.capacity();
diff --git a/src/ipset/IPSet.h b/src/ipset/IPSet.h
index a4f06c1c..459f958a 100644
--- a/src/ipset/IPSet.h
+++ b/src/ipset/IPSet.h
@@ -51,7 +51,7 @@ public:
 	explicit IPSet(const std::string &name, boost::python::list &ips);
 	explicit IPSet(boost::python::list &ips):IPSet("Generic IPSet", ips) {}
 #endif
-	explicit IPSet(const std::string &name):IPAbstractSet(name), total_bytes_(0) {}
+	explicit IPSet(const std::string &name):IPAbstractSet(name) {}
     	explicit IPSet():IPSet("Generic IPSet") {}
     	virtual ~IPSet() {}
 
@@ -93,7 +93,6 @@ public:
 private:
 	std::unordered_set<std::string> smap_; // For ipv6
 	std::unordered_set<uint32_t> imap_; // For ipv4
-	int32_t total_bytes_;
 };
 
 typedef std::shared_ptr<IPSet> IPSetPtr;
diff --git a/src/ipset/IPSetManager.h b/src/ipset/IPSetManager.h
index 4442bbbd..b145d444 100644
--- a/src/ipset/IPSetManager.h
+++ b/src/ipset/IPSetManager.h
@@ -58,7 +58,7 @@ public:
 	bool lookupIPAddress(const std::string &ip); 
 	bool lookupIPAddress(const IPAddress &address); 
 
-	int32_t getTotalSets() const { return sets_.size(); }
+	int32_t getTotalSets() const { return (int32_t)sets_.size(); }
 
 	void statistics(std::basic_ostream<char> &out) { out << *this; }
 	void statistics() { statistics(OutputManager::getInstance()->out());}
diff --git a/src/ipset/Makefile.am b/src/ipset/Makefile.am
index a08991b6..49a98ea2 100644
--- a/src/ipset/Makefile.am
+++ b/src/ipset/Makefile.am
@@ -1,3 +1,5 @@
+include $(top_srcdir)/src/common.mk
+
 AUTOMAKE_OPTIONS = gnu
 
 noinst_HEADERS =	test_ipset.h IPAbstractSet.h IPBloomSet.h IPRadixTree.h \
@@ -51,7 +53,7 @@ test_ipset_SOURCES = 	../Multiplexer.cc  ../Protocol.cc \
 
 test_ipset_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../ $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_ipset_LDFLAGS   = $(EXTRA_TEST_LDFLAGS) 
-test_ipset_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_unit_test_framework -lboost_log -lboost_thread -lboost_system -lpcre
+test_ipset_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_unit_test_framework -lboost_system -lpcre
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/ipset/test_ipset.cc b/src/ipset/test_ipset.cc
index 801328f0..4e050ce7 100644
--- a/src/ipset/test_ipset.cc
+++ b/src/ipset/test_ipset.cc
@@ -234,7 +234,7 @@ BOOST_AUTO_TEST_CASE (test07)
         ipset->addIPAddress("2000:aaaa:bbbb::7");
         ipset->addIPAddress("2000:aaaa:bbbb::8");
 
-#if defined(IS_FREEBSD)
+#if defined(IS_FREEBSD) || defined(IS_DARWIN)
 	BOOST_CHECK(ipset->getTotalBytes() == 22 * 2);
 #else	
 	BOOST_CHECK(ipset->getTotalBytes() == 17 * 2);
diff --git a/src/learner/Makefile.am b/src/learner/Makefile.am
index 8cb672e6..3ac67373 100644
--- a/src/learner/Makefile.am
+++ b/src/learner/Makefile.am
@@ -1,3 +1,5 @@
+include $(top_srcdir)/src/common.mk
+
 AUTOMAKE_OPTIONS = gnu
 
 noinst_HEADERS =	test_learner.h
@@ -12,7 +14,7 @@ test_learner_SOURCES = 	../protocols/frequency/PacketFrequencies.cc \
 
 test_learner_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_learner_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_learner_LDADD   = $(BOOST_LDFLAGS) -lboost_thread -lboost_unit_test_framework
+test_learner_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/main.cc b/src/main.cc
index 1f7f29af..a3fb92bd 100644
--- a/src/main.cc
+++ b/src/main.cc
@@ -91,6 +91,7 @@ bool option_enable_regex_evidence = false;
 bool option_continue_regex = false;
 bool option_show_protocol_summary = false;
 bool option_keep_flows_in_memory = false;
+bool option_show_anomalies = false;
 int tcp_flows_cache = 0;
 int udp_flows_cache = 0;
 int option_statistics_level = 0;
@@ -271,10 +272,9 @@ void showStackStatistics() {
 		
 			boost::split(items, option_selected_protocols, boost::is_any_of(","));
 		
-			for (auto &p: items) {	
+			for (auto &p: items)
                 		stack->statistics(p);
-				std::cout << std::endl;
-			}
+
                	} else {
                 	stack->statistics();
                	}
@@ -300,6 +300,8 @@ void aiengineExit() {
 				stack->showFlows(option_show_flows_name);
 			else
               			stack->showFlows();
+
+			std::cout << std::endl;
 		}
 
 		if (option_enable_frequencies) {
@@ -321,6 +323,11 @@ void aiengineExit() {
 			std::cout << std::endl;
         	}
 
+		if (option_show_anomalies) {
+			stack->showAnomalies();
+			std::cout << std::endl;
+		}
+
 		if (option_show_protocol_summary)
 			stack->showProtocolSummary(std::cout);
 
@@ -447,6 +454,7 @@ int main(int argc, char* argv[]) {
 		("pstatistics,p",      	"Show statistics of the process.")
 		("keep-flows,K",      	"Keep the flows in memory for analisys.")
 		("summary,o",      	"Show protocol summmary statistics (bytes, packets, % bytes, cache miss, memory).")
+		("anomalies,A",      	"Show anomalies.")
 		("help,h",     		"Show help.")
 		("version,v",   	"Show version string.")
 		;
@@ -489,6 +497,7 @@ int main(int argc, char* argv[]) {
 		if (var_map.count("evidence")) option_enable_regex_evidence = true;
 		if (var_map.count("summary")) option_show_protocol_summary = true;
 		if (var_map.count("keep-flows")) option_keep_flows_in_memory = true;
+		if (var_map.count("anomalies")) option_show_anomalies = true;
 
         	po::notify(var_map);
     	
diff --git a/src/names/DomainNameManager.cc b/src/names/DomainNameManager.cc
index 11bb53e6..80d4dc68 100644
--- a/src/names/DomainNameManager.cc
+++ b/src/names/DomainNameManager.cc
@@ -54,9 +54,8 @@ SharedPointer<DomainNode> DomainNameManager::find_domain_name_node(const SharedP
                 if (token.length() > 0) {
 			boost::string_ref key(token);
                         auto node = curr_node->haveKey(key);
-                        if (node) {
+                        if (node)
 				curr_node = node; 
-                        }
                 }
         }
 
@@ -148,10 +147,6 @@ SharedPointer<DomainName> DomainNameManager::getDomainName(const char *name) {
 SharedPointer<DomainName> DomainNameManager::getDomainName(const boost::string_ref &name) {
 
 	int start = 0;
-	if (name.starts_with('.')) {
-		start = 1;
-	} 
-
 	int pad = 0;
 	int off = 0;	
         int prev_idx = name.length() - 1;
@@ -160,6 +155,9 @@ SharedPointer<DomainName> DomainNameManager::getDomainName(const boost::string_r
         SharedPointer<DomainName> domain_candidate(nullptr), domain_alt(nullptr);
 	bool have_token = false;
 
+	if (name.starts_with('.'))
+		start = 1;
+
         for (offset = prev_idx ; offset >= start ; --offset) {
                 if (name.at(offset) == '.') {
 			have_token = true;
@@ -174,7 +172,8 @@ SharedPointer<DomainName> DomainNameManager::getDomainName(const boost::string_r
 
                         if (auto node = curr_node->haveKey(key_); node) {
                                 curr_node = node;
-				if (domain_candidate) domain_alt = domain_candidate;
+				if (domain_candidate)
+					domain_alt = domain_candidate;
                                 domain_candidate = node->getDomainName();
                         } else {
                                 if (domain_candidate) {
@@ -212,10 +211,11 @@ void DomainNameManager::transverse(const SharedPointer<DomainNode> node,
 	for (auto &it: *node) {
 		auto nod = it.second;
 		auto dname = nod->getDomainName();
-		if (nod->getTotalKeys() > 0 ) {
+		if (nod->getTotalKeys() > 0)
 			transverse(nod, condition);
-		}
-		if (dname) condition(nod, dname);
+
+		if (dname)
+			condition(nod, dname);
 	}
 }
 
@@ -223,16 +223,14 @@ void DomainNameManager::statistics(const std::string &name) {
 
         std::cout << "DomainNameManager (" << name_ <<")[" << name << "]"; 
 
-	if (plugged_to_name_.length() > 0) {
+	if (plugged_to_name_.length() > 0)
 		std::cout << " Plugged on " << plugged_to_name_;
-	}
 
 	std::cout << std::endl;
 
 	transverse(root_, [&] (const SharedPointer<DomainNode> &n ,const SharedPointer<DomainName> &d) {
-		if (name.compare(d->getName()) == 0) {
+		if (name.compare(d->getName()) == 0)
 			std::cout << *d;		
-		}
 	});
 }
 
@@ -267,17 +265,16 @@ std::ostream& operator<< (std::ostream &out, const DomainNameManager &domain) {
 
         out << "DomainNameManager (" << domain.name_ <<")"; 
 	
-	if (domain.plugged_to_name_.length() > 0) {
+	if (domain.plugged_to_name_.length() > 0)
 		out << " Plugged on " << domain.plugged_to_name_;
-	}
+
 	out << std::endl;
 
-	auto d = domain.root_->getDomainName();
-	if (d) {
-        	out << "\t" << *d;	
-	}
+	auto name = domain.root_->getDomainName();
+	if (name)
+		out << "\t" << *name;
 
-        domain.transverse(domain.root_, [&domain, &out] (const SharedPointer<DomainNode> &n ,const SharedPointer<DomainName> &d) {
+        domain.transverse(domain.root_, [&out] (const SharedPointer<DomainNode> &n ,const SharedPointer<DomainName> &d) {
                 out << "\t" << *d;
         });
        	return out;
@@ -285,10 +282,10 @@ std::ostream& operator<< (std::ostream &out, const DomainNameManager &domain) {
 
 void DomainNameManager::resetStatistics() {
 
-	auto d = root_->getDomainName();
-	if (d) {        
-		d->total_matchs_ = 0;
-		d->total_evaluates_ = 0;
+	auto name = root_->getDomainName();
+	if (name) {
+		name->total_matchs_ = 0;
+		name->total_evaluates_ = 0;
         }
 
         transverse(root_, [&] (const SharedPointer<DomainNode> &n ,const SharedPointer<DomainName> &d) {
@@ -303,11 +300,10 @@ void DomainNameManager::showMatchedDomains(std::basic_ostream<char> &out) const
 
 	std::vector<SharedPointer<DomainName>> matched_domains;
 
-	auto d = root_->getDomainName();
-	if (d) {        
-		if (d->getMatchs() > 0)
-			matched_domains.push_back(d);
-	}
+	auto name = root_->getDomainName();
+	if (name)
+		if (name->getMatchs() > 0)
+			matched_domains.push_back(name);
 
         transverse(root_, [&] (const SharedPointer<DomainNode> &n ,const SharedPointer<DomainName> &d) {
 		if (d->getMatchs() > 0)
@@ -326,9 +322,9 @@ void DomainNameManager::showMatchedDomains(std::basic_ostream<char> &out) const
 
         out << "DomainNameManager (" << name_ <<")";
 
-        if (plugged_to_name_.length() > 0) {
+        if (plugged_to_name_.length() > 0)
                 out << " Plugged on " << plugged_to_name_;
-        }
+
         out << "\n";
         
 	for (auto &item: matched_domains) 
diff --git a/src/names/DomainNode.h b/src/names/DomainNode.h
index 320347d9..3a72deae 100644
--- a/src/names/DomainNode.h
+++ b/src/names/DomainNode.h
@@ -56,7 +56,7 @@ public:
 	void addKey(const SharedPointer<DomainNode> &node); 
 	void removeKey(const SharedPointer<DomainNode> &node); 
 
-	int getTotalKeys() const { return map_.size(); }
+	int getTotalKeys() const { return (int)map_.size(); }
 
 	void setDomainName(const SharedPointer<DomainName> &domain) { domain_ = domain;}
 	SharedPointer<DomainName> getDomainName() { return domain_;}
diff --git a/src/protocols/bitcoin/BitcoinProtocol.h b/src/protocols/bitcoin/BitcoinProtocol.h
index fc97b7e2..a486d1c8 100644
--- a/src/protocols/bitcoin/BitcoinProtocol.h
+++ b/src/protocols/bitcoin/BitcoinProtocol.h
@@ -96,7 +96,7 @@ public:
 
 	// Returns the length of the last block process on a packet
 	int32_t getPayloadLength() const { return header_->length; }	
-	int32_t getTotalBitcoinOperations() const { return total_bitcoin_operations_; }	
+	int64_t getTotalBitcoinOperations() const { return total_bitcoin_operations_; }	
 
 	int64_t getCurrentUseMemory() const override; 
 	int64_t getAllocatedMemory() const override;
diff --git a/src/protocols/bitcoin/Makefile.am b/src/protocols/bitcoin/Makefile.am
index 32f051f4..ed5cf4d4 100644
--- a/src/protocols/bitcoin/Makefile.am
+++ b/src/protocols/bitcoin/Makefile.am
@@ -37,7 +37,7 @@ test_bitcoin_SOURCES = 	../../Multiplexer.cc \
 
 test_bitcoin_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_bitcoin_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_bitcoin_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_system -lboost_thread -lboost_log -lboost_unit_test_framework
+test_bitcoin_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/coap/CoAPInfo.cc b/src/protocols/coap/CoAPInfo.cc
index 43f0b8e2..bc84cc66 100644
--- a/src/protocols/coap/CoAPInfo.cc
+++ b/src/protocols/coap/CoAPInfo.cc
@@ -36,7 +36,7 @@ void CoAPInfo::reset() {
 std::ostream& operator<< (std::ostream& out, const CoAPInfo &info) {
 
 	if (info.isBanned()) 
-		out << "Banned";
+		out << " Banned";
 
 	if (info.host_name) 
 		out << " Host:" << info.host_name->getName();
diff --git a/src/protocols/coap/CoAPProtocol.cc b/src/protocols/coap/CoAPProtocol.cc
index b9e7589a..1ea32dcb 100644
--- a/src/protocols/coap/CoAPProtocol.cc
+++ b/src/protocols/coap/CoAPProtocol.cc
@@ -434,17 +434,27 @@ CounterMap CoAPProtocol::getCounters() const {
 
 #if defined(PYTHON_BINDING) || defined(RUBY_BINDING) 
 #if defined(PYTHON_BINDING)
-boost::python::dict CoAPProtocol::getCache() const {
+boost::python::dict CoAPProtocol::getCacheData(const std::string &name) const {
 #elif defined(RUBY_BINDING)
-VALUE CoAPProtocol::getCache() const {
+VALUE CoAPProtocol::getCacheData(const std::string &name) const {
 #endif
-        return addMapToHash(host_map_);
+        if (boost::iequals(name, "host"))
+		return addMapToHash(host_map_);
+        else if (boost::iequals(name, "uri"))
+		return addMapToHash(uri_map_);
+
+        return addMapToHash({});
 }
 
 #if defined(PYTHON_BINDING)
-void CoAPProtocol::showCache(std::basic_ostream<char> &out) const {
+SharedPointer<Cache<StringCache>> CoAPProtocol::getCache(const std::string &name) {
+
+        if (boost::iequals(name, "host"))
+                return host_cache_;
+        else if (boost::iequals(name, "uri"))
+                return uri_cache_;
 
-        showCacheMap(out, "", host_map_, "CoAP Hosts", "Hostname");
+        return nullptr;
 }
 #endif
 
diff --git a/src/protocols/coap/CoAPProtocol.h b/src/protocols/coap/CoAPProtocol.h
index dcd555c7..12dfc5f2 100644
--- a/src/protocols/coap/CoAPProtocol.h
+++ b/src/protocols/coap/CoAPProtocol.h
@@ -125,10 +125,10 @@ public:
 	CounterMap getCounters() const override; 
 
 #if defined(PYTHON_BINDING)
-        boost::python::dict getCache() const override;
-	void showCache(std::basic_ostream<char> &out) const override;
+        boost::python::dict getCacheData(const std::string &name) const override;
+	SharedPointer<Cache<StringCache>> getCache(const std::string &name) override;
 #elif defined(RUBY_BINDING)
-	VALUE getCache() const;
+	VALUE getCacheData(const std::string &name) const;
 #endif
 	void setFlowManager(FlowManagerPtrWeak flow_mng) { flow_mng_ = flow_mng; }
 
diff --git a/src/protocols/coap/Makefile.am b/src/protocols/coap/Makefile.am
index 32f2ad61..fc5fc851 100644
--- a/src/protocols/coap/Makefile.am
+++ b/src/protocols/coap/Makefile.am
@@ -45,7 +45,7 @@ test_coap_SOURCES = 	../../Multiplexer.cc \
 
 test_coap_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST 
 test_coap_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_coap_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_system -lboost_log -lboost_thread -lboost_unit_test_framework 
+test_coap_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework 
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/dcerpc/DCERPCProtocol.cc b/src/protocols/dcerpc/DCERPCProtocol.cc
index 114aa68f..a841e1ab 100644
--- a/src/protocols/dcerpc/DCERPCProtocol.cc
+++ b/src/protocols/dcerpc/DCERPCProtocol.cc
@@ -357,10 +357,23 @@ CounterMap DCERPCProtocol::getCounters() const {
 }
 
 #if defined(PYTHON_BINDING)
-void DCERPCProtocol::showCache(std::basic_ostream<char> &out) const {
 
-        showCacheMap(out, "", uuid_map_, "UUIDs", "UUID");
+boost::python::dict DCERPCProtocol::getCacheData(const std::string &name) const {
+
+        if (boost::iequals(name, "uuid"))
+                return addMapToHash(uuid_map_);
+
+        return addMapToHash({});
 }
+
+SharedPointer<Cache<StringCache>> DCERPCProtocol::getCache(const std::string &name) {
+
+        if (boost::iequals(name, "uuid"))
+                return uuid_cache_;
+
+        return nullptr;
+}
+
 #endif
 
 void DCERPCProtocol::statistics(nlohmann::json &out, const std::string &map_name) const {
diff --git a/src/protocols/dcerpc/DCERPCProtocol.h b/src/protocols/dcerpc/DCERPCProtocol.h
index ff4a213b..6cdcd450 100644
--- a/src/protocols/dcerpc/DCERPCProtocol.h
+++ b/src/protocols/dcerpc/DCERPCProtocol.h
@@ -132,7 +132,8 @@ public:
 	void releaseFlowInfo(Flow *flow) override;
 
 #if defined(PYTHON_BINDING)
-        void showCache(std::basic_ostream<char> &out) const override;
+        boost::python::dict getCacheData(const std::string &name) const override;
+        SharedPointer<Cache<StringCache>> getCache(const std::string &name) override;
 #endif
 
 private:
diff --git a/src/protocols/dcerpc/Makefile.am b/src/protocols/dcerpc/Makefile.am
index 435d20bb..2e3acc1e 100644
--- a/src/protocols/dcerpc/Makefile.am
+++ b/src/protocols/dcerpc/Makefile.am
@@ -45,7 +45,7 @@ test_dcerpc_SOURCES = 	../../Multiplexer.cc \
 
 test_dcerpc_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_dcerpc_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_dcerpc_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_system -lboost_log -lboost_thread -lboost_unit_test_framework
+test_dcerpc_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/dcerpc/test_dcerpc.cc b/src/protocols/dcerpc/test_dcerpc.cc
index 7d88f425..75bfd583 100644
--- a/src/protocols/dcerpc/test_dcerpc.cc
+++ b/src/protocols/dcerpc/test_dcerpc.cc
@@ -260,7 +260,7 @@ BOOST_AUTO_TEST_CASE (test11)
 	{
 		RedirectOutput r;
 
-        	flow->showFlowInfo(r.cout);
+        	flow->show(r.cout);
         	r.cout << *(info.get());
 	}
 
@@ -345,7 +345,7 @@ BOOST_AUTO_TEST_CASE (test01)
 
 	flow->setLabel(std::string("12345678"));
 
-	flow->showFlowInfo(jf);
+	flow->show(jf);
 }
 
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/src/protocols/dhcp/DHCPProtocol.cc b/src/protocols/dhcp/DHCPProtocol.cc
index b6695160..49f0cb25 100644
--- a/src/protocols/dhcp/DHCPProtocol.cc
+++ b/src/protocols/dhcp/DHCPProtocol.cc
@@ -402,18 +402,29 @@ CounterMap DHCPProtocol::getCounters() const {
 
 #if defined(PYTHON_BINDING) || defined(RUBY_BINDING) 
 #if defined(PYTHON_BINDING)
-boost::python::dict DHCPProtocol::getCache() const {
+boost::python::dict DHCPProtocol::getCacheData(const std::string &name) const {
 #elif defined(RUBY_BINDING)
-VALUE DHCPProtocol::getCache() const {
+VALUE DHCPProtocol::getCache(const std::string &name) const {
 #endif
-        return addMapToHash(host_map_);
+        if (boost::iequals(name, "name")or(boost::iequals(name, "host")))
+		return addMapToHash(host_map_);
+        else if (boost::iequals(name, "ip"))
+		return addMapToHash(ip_map_);
+
+        return addMapToHash({});
 }
 
 #if defined(PYTHON_BINDING)
-void DHCPProtocol::showCache(std::basic_ostream<char> &out) const {
+SharedPointer<Cache<StringCache>> DHCPProtocol::getCache(const std::string &name) {
+
+        if (boost::iequals(name, "name")or(boost::iequals(name, "host")))
+                return host_cache_;
+        else if (boost::iequals(name, "ip"))
+                return ip_cache_;
 
-	showCacheMap(out, "", host_map_, "Host names", "Host");
+        return nullptr;
 }
+
 #endif
 
 #endif
diff --git a/src/protocols/dhcp/DHCPProtocol.h b/src/protocols/dhcp/DHCPProtocol.h
index 54e2669e..0495554d 100644
--- a/src/protocols/dhcp/DHCPProtocol.h
+++ b/src/protocols/dhcp/DHCPProtocol.h
@@ -119,10 +119,10 @@ public:
 	CounterMap getCounters() const override;
 
 #if defined(PYTHON_BINDING)
-        boost::python::dict getCache() const override;
-	void showCache(std::basic_ostream<char> &out) const override;
+        boost::python::dict getCacheData(const std::string &name) const override;
+        SharedPointer<Cache<StringCache>> getCache(const std::string &name) override;
 #elif defined(RUBY_BINDING)
-        VALUE getCache() const;
+        VALUE getCacheData(const std::string &name) const;
 #endif
 
         void setAnomalyManager(SharedPointer<AnomalyManager> amng) override { anomaly_ = amng; }
diff --git a/src/protocols/dhcp/Makefile.am b/src/protocols/dhcp/Makefile.am
index c0224f64..14478fba 100644
--- a/src/protocols/dhcp/Makefile.am
+++ b/src/protocols/dhcp/Makefile.am
@@ -39,7 +39,7 @@ test_dhcp_SOURCES = 	../../Multiplexer.cc \
 
 test_dhcp_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_dhcp_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_dhcp_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_system -lboost_log -lboost_thread -lboost_unit_test_framework
+test_dhcp_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/dhcp6/DHCPv6Protocol.cc b/src/protocols/dhcp6/DHCPv6Protocol.cc
index b19f158b..cb787486 100644
--- a/src/protocols/dhcp6/DHCPv6Protocol.cc
+++ b/src/protocols/dhcp6/DHCPv6Protocol.cc
@@ -391,18 +391,33 @@ CounterMap DHCPv6Protocol::getCounters() const {
 
 #if defined(PYTHON_BINDING) || defined(RUBY_BINDING) 
 #if defined(PYTHON_BINDING)
-boost::python::dict DHCPv6Protocol::getCache() const {
+boost::python::dict DHCPv6Protocol::getCacheData(const std::string &name) const {
 #elif defined(RUBY_BINDING)
-VALUE DHCPv6Protocol::getCache() const {
+VALUE DHCPv6Protocol::getCacheData(const std::string &name) const {
 #endif
-        return addMapToHash(host_map_);
+        if (boost::iequals(name, "name")or(boost::iequals(name, "host")))
+		return addMapToHash(host_map_);
+        else if (boost::iequals(name, "ip6"))
+		return addMapToHash(ip6_map_);
+        else if (boost::iequals(name, "ip"))
+		return addMapToHash(ip6_map_);
+
+        return addMapToHash({});
 }
 
 #if defined(PYTHON_BINDING)
-void DHCPv6Protocol::showCache(std::basic_ostream<char> &out) const {
+SharedPointer<Cache<StringCache>> DHCPv6Protocol::getCache(const std::string &name) {
 
-        showCacheMap(out, "", host_map_, "Host names", "Host");
+        if (boost::iequals(name, "name")or(boost::iequals(name, "host")))
+                return host_cache_;
+        else if (boost::iequals(name, "ip6"))
+                return ip6_cache_;
+        else if (boost::iequals(name, "ip"))
+                return ip6_cache_;
+
+        return nullptr;
 }
+
 #endif
 
 #endif
diff --git a/src/protocols/dhcp6/DHCPv6Protocol.h b/src/protocols/dhcp6/DHCPv6Protocol.h
index 41431bfd..0ad24612 100644
--- a/src/protocols/dhcp6/DHCPv6Protocol.h
+++ b/src/protocols/dhcp6/DHCPv6Protocol.h
@@ -125,10 +125,10 @@ public:
 	CounterMap getCounters() const override;
 
 #if defined(PYTHON_BINDING)
-        boost::python::dict getCache() const override;
-	void showCache(std::basic_ostream<char> &out) const override;
+        boost::python::dict getCacheData(const std::string &name) const override;
+        SharedPointer<Cache<StringCache>> getCache(const std::string &name) override;
 #elif defined(RUBY_BINDING)
-        VALUE getCache() const;
+        VALUE getCacheData(const std::string &name) const;
 #endif
 
         void setAnomalyManager(SharedPointer<AnomalyManager> amng) override { anomaly_ = amng; }
diff --git a/src/protocols/dhcp6/Makefile.am b/src/protocols/dhcp6/Makefile.am
index 4a1344a9..79f664b7 100644
--- a/src/protocols/dhcp6/Makefile.am
+++ b/src/protocols/dhcp6/Makefile.am
@@ -45,7 +45,7 @@ test_dhcpv6_SOURCES = 	../../Multiplexer.cc \
 
 test_dhcpv6_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_dhcpv6_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_dhcpv6_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_system -lboost_log -lboost_thread -lboost_unit_test_framework
+test_dhcpv6_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/dhcp6/test_dhcpv6.cc b/src/protocols/dhcp6/test_dhcpv6.cc
index 2296e3fb..f80e7720 100644
--- a/src/protocols/dhcp6/test_dhcpv6.cc
+++ b/src/protocols/dhcp6/test_dhcpv6.cc
@@ -82,14 +82,14 @@ BOOST_AUTO_TEST_CASE (test02)
 	{
 		RedirectOutput r;
         	
-        	flow->showFlowInfo(r.cout);
+        	flow->show(r.cout);
         	r.cout << *(info.get());
     	} 
 
 	BOOST_CHECK(info->getT1() == 0);
 	BOOST_CHECK(info->getT2() == 0);
 
-	flow->showFlowInfo(j);
+	flow->show(j);
 
 	j << *info;
 
diff --git a/src/protocols/dns/DNSInfo.cc b/src/protocols/dns/DNSInfo.cc
index e21ba85c..daa5eef3 100644
--- a/src/protocols/dns/DNSInfo.cc
+++ b/src/protocols/dns/DNSInfo.cc
@@ -52,7 +52,7 @@ void DNSInfo::addName(const char *name, int length) {
 std::ostream& operator<< (std::ostream &out, const DNSInfo &info) {
 
 	if (info.isBanned()) 
-		out << "Banned";
+		out << " Banned";
 
 	if (info.name) 
 		out << " Domain:" << info.name->getName();
diff --git a/src/protocols/dns/DNSProtocol.cc b/src/protocols/dns/DNSProtocol.cc
index 9595d34c..ee97a702 100644
--- a/src/protocols/dns/DNSProtocol.cc
+++ b/src/protocols/dns/DNSProtocol.cc
@@ -631,18 +631,22 @@ CounterMap DNSProtocol::getCounters() const {
 
 #if defined(PYTHON_BINDING) || defined(RUBY_BINDING)
 #if defined(PYTHON_BINDING)
-boost::python::dict DNSProtocol::getCache() const {
+boost::python::dict DNSProtocol::getCacheData(const std::string &name) const {
 #elif defined(RUBY_BINDING)
-VALUE DNSProtocol::getCache() const {
+VALUE DNSProtocol::getCacheData(const std::string &name) const {
 #endif
 	return addMapToHash(domain_map_);
 }
 
 #if defined(PYTHON_BINDING)
-void DNSProtocol::showCache(std::basic_ostream<char> &out) const {
+SharedPointer<Cache<StringCache>> DNSProtocol::getCache(const std::string &name) {
 
-        showCacheMap(out, "", domain_map_, "DNS Names", "Domain");
+        if (boost::iequals(name, "name"))
+                return name_cache_;
+
+        return nullptr;
 }
+
 #endif
 
 #endif
diff --git a/src/protocols/dns/DNSProtocol.h b/src/protocols/dns/DNSProtocol.h
index cf7a21e3..63ced2ab 100644
--- a/src/protocols/dns/DNSProtocol.h
+++ b/src/protocols/dns/DNSProtocol.h
@@ -126,10 +126,10 @@ public:
 	CounterMap getCounters() const override; 
 
 #if defined(PYTHON_BINDING)
-	boost::python::dict getCache() const override;
-	void showCache(std::basic_ostream<char> &out) const override;
+	boost::python::dict getCacheData(const std::string &name) const override;
+	SharedPointer<Cache<StringCache>> getCache(const std::string &name) override;
 #elif defined(RUBY_BINDING)
-	VALUE getCache() const;
+	VALUE getCacheData(const std::string &name) const;
 #endif
 
 	void setAnomalyManager(SharedPointer<AnomalyManager> amng) override { anomaly_ = amng; }
diff --git a/src/protocols/dns/Makefile.am b/src/protocols/dns/Makefile.am
index 071f1bfb..4d1a8482 100644
--- a/src/protocols/dns/Makefile.am
+++ b/src/protocols/dns/Makefile.am
@@ -70,7 +70,7 @@ test_dns_SOURCES = 	../../Multiplexer.cc \
 
 test_dns_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_dns_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_dns_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_system -lboost_log -lboost_thread -lboost_unit_test_framework
+test_dns_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/ethernet/Makefile.am b/src/protocols/ethernet/Makefile.am
index 1b67cf2f..b0f6948a 100644
--- a/src/protocols/ethernet/Makefile.am
+++ b/src/protocols/ethernet/Makefile.am
@@ -20,7 +20,7 @@ test_ethernet_SOURCES = ../../Multiplexer.cc \
 			EthernetProtocol.cc test_ethernet.cc
 
 test_ethernet_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_ethernet_LDADD   = $(BOOST_LDFLAGS) -lboost_unit_test_framework -lboost_system -lpthread -lboost_log -lboost_thread
+test_ethernet_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lboost_unit_test_framework -lboost_system -lpthread
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/frequency/Makefile.am b/src/protocols/frequency/Makefile.am
index a05027e8..862fc0b2 100644
--- a/src/protocols/frequency/Makefile.am
+++ b/src/protocols/frequency/Makefile.am
@@ -32,7 +32,7 @@ test_frequency_SOURCES = 	../../Multiplexer.cc \
 
 test_frequency_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_frequency_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_frequency_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_system -lboost_unit_test_framework -lboost_thread -lboost_log
+test_frequency_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/gprs/Makefile.am b/src/protocols/gprs/Makefile.am
index 09b0acb6..49897dd0 100644
--- a/src/protocols/gprs/Makefile.am
+++ b/src/protocols/gprs/Makefile.am
@@ -52,7 +52,7 @@ test_gprs_SOURCES = 	../../Multiplexer.cc \
 
 test_gprs_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_gprs_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_gprs_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_system -lboost_log -lboost_thread -lboost_unit_test_framework
+test_gprs_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/gprs/test_gprs.cc b/src/protocols/gprs/test_gprs.cc
index ae67f2e2..e10a3e6b 100644
--- a/src/protocols/gprs/test_gprs.cc
+++ b/src/protocols/gprs/test_gprs.cc
@@ -107,6 +107,7 @@ BOOST_AUTO_TEST_CASE (test02)
         BOOST_CHECK(mux_gprs->getTotalFailPackets() == 0);
 
 	// check the HIGH IP layer
+        BOOST_CHECK(ip_high->getTTL() == 255);
        	BOOST_CHECK(ip_high->getTotalBytes() == 36);
        	BOOST_CHECK(ip_high->getTotalValidPackets() == 1);
        	BOOST_CHECK(ip_high->getTotalInvalidPackets() == 0);
@@ -332,7 +333,7 @@ BOOST_AUTO_TEST_CASE (test06) // Process a pdp context creation
 		RedirectOutput r;
         
 		r.cout << *info.get();
-		flow->showFlowInfo(r.cout);
+		flow->show(r.cout);
 	}
 
 	std::string imsi("234308256005467");
@@ -341,7 +342,7 @@ BOOST_AUTO_TEST_CASE (test06) // Process a pdp context creation
 
 	nlohmann::json j;
 
-	flow->showFlowInfo(j);
+	flow->show(j);
 
 	j << *info;
 
@@ -638,6 +639,8 @@ BOOST_AUTO_TEST_CASE (test19) // user data pdu with torrent
         BOOST_CHECK(localip.compare(ip_low->getSrcAddrDotNotation()) == 0);
         BOOST_CHECK(remoteip.compare(ip_low->getDstAddrDotNotation()) == 0);
 
+	BOOST_CHECK(ip_low->getTTL() == 63);
+
         BOOST_CHECK(gprs->getTotalBytes() == 146);
         BOOST_CHECK(gprs->getTotalValidPackets() == 1);
         BOOST_CHECK(gprs->getTotalInvalidPackets() == 0);
@@ -651,6 +654,20 @@ BOOST_AUTO_TEST_CASE (test19) // user data pdu with torrent
 
         BOOST_CHECK(localip.compare(ip_high->getSrcAddrDotNotation()) == 0);
         BOOST_CHECK(remoteip.compare(ip_high->getDstAddrDotNotation()) == 0);
+	
+	BOOST_CHECK(ip_high->getTTL() == 128);
+
+	Flow *flow_down = udp_low->getCurrentFlow();
+	Flow *flow_up = udp_high->getCurrentFlow();
+
+	BOOST_CHECK(flow_down != nullptr);
+	BOOST_CHECK(flow_up != nullptr);
+
+	BOOST_CHECK(flow_down->upstream_ttl == 63);
+	BOOST_CHECK(flow_down->downstream_ttl == 0);
+	
+	BOOST_CHECK(flow_up->upstream_ttl == 128);
+	BOOST_CHECK(flow_up->downstream_ttl == 0);
 }
 
 BOOST_AUTO_TEST_CASE (test20) // Release the flow with l7 info on it
diff --git a/src/protocols/gre/Makefile.am b/src/protocols/gre/Makefile.am
index df4839aa..4dcd5f03 100644
--- a/src/protocols/gre/Makefile.am
+++ b/src/protocols/gre/Makefile.am
@@ -34,7 +34,7 @@ test_gre_SOURCES = 	../../Multiplexer.cc \
 
 test_gre_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_gre_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_gre_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_log -lboost_thread -lboost_system -lboost_unit_test_framework
+test_gre_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/http/HTTPInfo.cc b/src/protocols/http/HTTPInfo.cc
index b23e63c8..7a6b8cf7 100644
--- a/src/protocols/http/HTTPInfo.cc
+++ b/src/protocols/http/HTTPInfo.cc
@@ -56,10 +56,10 @@ std::ostream& operator<< (std::ostream &out, const HTTPInfo &info) {
 
 	out << " Req(" << info.getTotalRequests();
 	out << ")Res(" << info.getTotalResponses();
-	out << ")Code(" << info.getResponseCode() << ") ";
+	out << ")Code(" << info.getResponseCode() << ")";
 
 	if (info.isBanned()) 
-		out << "Banned";
+		out << " Banned";
 
 	if (info.host_name) 
 		out << " Host:" << info.host_name->getName();
diff --git a/src/protocols/http/HTTPProtocol.cc b/src/protocols/http/HTTPProtocol.cc
index 2b6a3ff4..50a23212 100644
--- a/src/protocols/http/HTTPProtocol.cc
+++ b/src/protocols/http/HTTPProtocol.cc
@@ -1085,18 +1085,51 @@ CounterMap HTTPProtocol::getCounters() const {
 
 #if defined(PYTHON_BINDING) || defined(RUBY_BINDING) 
 #if defined(PYTHON_BINDING)
-boost::python::dict HTTPProtocol::getCache() const {
+boost::python::dict HTTPProtocol::getCacheData(const std::string &name) const {
 #elif defined(RUBY_BINDING)
-VALUE HTTPProtocol::getCache() const {
+VALUE HTTPProtocol::getCacheData(const std::string &name) const {
 #endif
-        return addMapToHash(host_map_);
+
+        if (boost::iequals(name, "host"))
+		return addMapToHash(host_map_);
+        else if (boost::iequals(name, "useragent"))
+		return addMapToHash(ua_map_);
+        else if (boost::iequals(name, "user-agent"))
+		return addMapToHash(ua_map_);
+        else if (boost::iequals(name, "uri"))
+		return addMapToHash(uri_map_);
+        else if (boost::iequals(name, "contenttype"))
+		return addMapToHash(ct_map_);
+        else if (boost::iequals(name, "content-type"))
+		return addMapToHash(ct_map_);
+        else if (boost::iequals(name, "filename"))
+		return addMapToHash(file_map_);
+
+        return addMapToHash({});
 }
 
 #if defined(PYTHON_BINDING)
-void HTTPProtocol::showCache(std::basic_ostream<char> &out) const {
-	
-	showCacheMap(out, "", host_map_, "HTTP Hosts", "Host");
+
+SharedPointer<Cache<StringCache>> HTTPProtocol::getCache(const std::string &name) {
+
+        if (boost::iequals(name, "host"))
+		return host_cache_;
+        else if (boost::iequals(name, "useragent"))
+		return ua_cache_;
+        else if (boost::iequals(name, "user-agent"))
+		return ua_cache_;
+        else if (boost::iequals(name, "uri"))
+		return uri_cache_;
+        else if (boost::iequals(name, "contenttype"))
+		return ct_cache_;
+        else if (boost::iequals(name, "content-type"))
+		return ct_cache_;
+        else if (boost::iequals(name, "filename"))
+		return file_cache_;
+
+	return nullptr;
 }
+
 #endif
 
 #endif
diff --git a/src/protocols/http/HTTPProtocol.h b/src/protocols/http/HTTPProtocol.h
index a96365f3..57e2a2d1 100644
--- a/src/protocols/http/HTTPProtocol.h
+++ b/src/protocols/http/HTTPProtocol.h
@@ -110,8 +110,8 @@ public:
 	CounterMap getCounters() const override; 
 
 #if defined(PYTHON_BINDING)
-	boost::python::dict getCache() const override; 
-	void showCache(std::basic_ostream<char> &out) const override;
+	boost::python::dict getCacheData(const std::string &name) const override; 
+	SharedPointer<Cache<StringCache>> getCache(const std::string &name) override;
 #elif defined(RUBY_BINDING)
 	VALUE getCache() const; 
 #endif
diff --git a/src/protocols/http/Makefile.am b/src/protocols/http/Makefile.am
index 7b5b63b8..2b5b9b78 100644
--- a/src/protocols/http/Makefile.am
+++ b/src/protocols/http/Makefile.am
@@ -53,7 +53,7 @@ test_http_SOURCES = 	../../Multiplexer.cc \
 
 test_http_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_http_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_http_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_system -lboost_log -lboost_thread -lboost_unit_test_framework $(PCRE_LIB)
+test_http_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework $(PCRE_LIB)
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/icmp/ICMPProtocol.cc b/src/protocols/icmp/ICMPProtocol.cc
index 9b608aec..64696610 100644
--- a/src/protocols/icmp/ICMPProtocol.cc
+++ b/src/protocols/icmp/ICMPProtocol.cc
@@ -60,6 +60,10 @@ void ICMPProtocol::statistics(std::basic_ostream<char> &out, int level) {
 		out << "\t" << "Total ttl exceededs:    " << std::setw(10) << total_ttl_exceeded_ << "\n";
 		out << "\t" << "Total timestamp reqs:   " << std::setw(10) << total_timestamp_request_ << "\n";
 		out << "\t" << "Total timestamp reps:   " << std::setw(10) << total_timestamp_replay_ << "\n";
+		out << "\t" << "Total info request:     " << std::setw(10) << total_info_request_ << "\n";
+		out << "\t" << "Total info replays:     " << std::setw(10) << total_info_reply_ << "\n";
+		out << "\t" << "Total address request:  " << std::setw(10) << total_address_ << "\n";
+		out << "\t" << "Total address replays:  " << std::setw(10) << total_address_reply_ << "\n";
 		out << "\t" << "Total others:           " << std::setw(10) << total_others_ << std::endl;
 	}
 	if (level > 2) {
@@ -83,6 +87,10 @@ void ICMPProtocol::statistics(nlohmann::json &out, int level) {
 		out["ttl_exceededs"] = total_ttl_exceeded_;
 		out["timestamp_requests"] = total_timestamp_request_;
 		out["timestamp_replays"] = total_timestamp_replay_;
+		out["info_requests"] = total_info_request_;
+		out["info_replays"] = total_info_reply_;
+		out["masked_address_request"] = total_address_;
+		out["masked_address_replays"] = total_address_reply_;
 		out["others"] = total_others_;
         }
 }
@@ -111,6 +119,14 @@ bool ICMPProtocol::processPacket(Packet &packet) {
 		++total_timestamp_request_;
 	else if (type == ICMP_TSTAMPREPLY) 
 		++total_timestamp_replay_;
+	else if (type == ICMP_INFO_REQUEST)
+		++total_info_request_;
+	else if (type == ICMP_INFO_REPLY)
+		++total_info_reply_;
+	else if (type == ICMP_ADDRESS)
+		++total_address_;
+	else if (type == ICMP_ADDRESSREPLY)
+		++total_address_reply_;
 	else
 		++total_others_;
 
@@ -135,6 +151,10 @@ CounterMap ICMPProtocol::getCounters() const {
         cm.addKeyValue("time exceeded", total_ttl_exceeded_);
 	cm.addKeyValue("timestamp request", total_timestamp_request_);
 	cm.addKeyValue("timestamp replay", total_timestamp_replay_);
+	cm.addKeyValue("info request", total_info_request_);
+	cm.addKeyValue("info replay", total_info_reply_);
+	cm.addKeyValue("address request", total_address_);
+	cm.addKeyValue("address replay", total_address_reply_);
 
         return cm;
 }
diff --git a/src/protocols/icmp/ICMPProtocol.h b/src/protocols/icmp/ICMPProtocol.h
index 65e7a55f..a5bb42b5 100644
--- a/src/protocols/icmp/ICMPProtocol.h
+++ b/src/protocols/icmp/ICMPProtocol.h
@@ -34,6 +34,13 @@
 #include <netinet/in.h>
 #include <arpa/inet.h>
 
+#if defined(IS_DARWIN)
+#define ICMP_INFO_REQUEST ICMP_IREQ
+#define ICMP_INFO_REPLY ICMP_IREQREPLY
+#define ICMP_ADDRESS ICMP_MASKREQ
+#define ICMP_ADDRESSREPLY ICMP_MASKREPLY
+#endif
+
 namespace aiengine {
 
 class ICMPProtocol: public Protocol {
@@ -103,6 +110,10 @@ private:
 	int32_t total_ttl_exceeded_ = 0;
         int32_t total_timestamp_request_ = 0;
         int32_t total_timestamp_replay_ = 0;
+	int32_t total_info_request_ = 0;
+	int32_t total_info_reply_ = 0;
+	int32_t total_address_ = 0;
+	int32_t total_address_reply_ = 0;
         int32_t total_others_ = 0;
 };
 
diff --git a/src/protocols/icmp/Makefile.am b/src/protocols/icmp/Makefile.am
index 743e9074..95ddfb51 100644
--- a/src/protocols/icmp/Makefile.am
+++ b/src/protocols/icmp/Makefile.am
@@ -2,7 +2,7 @@ include $(top_srcdir)/src/common.mk
 
 AUTOMAKE_OPTIONS = gnu
 
-EXTRA_DIST =            packets/packet01.pcap \
+EXTRA_DIST =            packets/packet01.pcap packets/README.rst \
                         packets/packet02.pcap \
                         packets/packet03.pcap \
                         packets/packet04.pcap \
@@ -11,7 +11,10 @@ EXTRA_DIST =            packets/packet01.pcap \
                         packets/packet07.pcap \
                         packets/packet08.pcap \
                         packets/packet09.pcap \
-                        packets/packet10.pcap 
+                        packets/packet10.pcap \
+                        packets/packet11.pcap \
+                        packets/packet12.pcap \
+                        packets/packet13.pcap
 
 noinst_HEADERS =	ICMPRawSocket.h ICMPHeader.h test_icmp.h
 
@@ -34,7 +37,7 @@ test_icmp_SOURCES = 	../../Multiplexer.cc \
 
 test_icmp_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_icmp_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_icmp_LDADD   = $(BOOST_LDFLAGS) -lboost_system -lboost_log -lboost_thread -lpthread -lboost_unit_test_framework
+test_icmp_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lboost_system -lpthread -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/icmp/packets/README.rst b/src/protocols/icmp/packets/README.rst
new file mode 100644
index 00000000..1bea1c40
--- /dev/null
+++ b/src/protocols/icmp/packets/README.rst
@@ -0,0 +1,12 @@
+packet01.pcap
+packet02.pcap
+packet03.pcap
+packet04.pcap
+packet05.pcap
+packet06.pcap
+packet07.pcap
+packet08.pcap
+packet09.pcap
+packet10.pcap
+packet11.pcap -> Info request from DoS attack, not really a info request
+packet12.pcap -> info reply from DoS attack, not really a info response
diff --git a/src/protocols/icmp/packets/packet11.pcap b/src/protocols/icmp/packets/packet11.pcap
new file mode 100644
index 00000000..60409f27
Binary files /dev/null and b/src/protocols/icmp/packets/packet11.pcap differ
diff --git a/src/protocols/icmp/packets/packet12.pcap b/src/protocols/icmp/packets/packet12.pcap
new file mode 100644
index 00000000..303fa16d
Binary files /dev/null and b/src/protocols/icmp/packets/packet12.pcap differ
diff --git a/src/protocols/icmp/packets/packet13.pcap b/src/protocols/icmp/packets/packet13.pcap
new file mode 100644
index 00000000..c7bfe65f
Binary files /dev/null and b/src/protocols/icmp/packets/packet13.pcap differ
diff --git a/src/protocols/icmp/test_icmp.cc b/src/protocols/icmp/test_icmp.cc
index ced74ed6..5b7cf43b 100644
--- a/src/protocols/icmp/test_icmp.cc
+++ b/src/protocols/icmp/test_icmp.cc
@@ -206,5 +206,63 @@ BOOST_AUTO_TEST_CASE (test10) // icmp router advertisement
 	icmp->statistics(j, 5);
 }
 
+BOOST_AUTO_TEST_CASE (test11) // icmp info request
+{
+        Packet packet("../icmp/packets/packet11.pcap");
+
+        mux_icmp->addPacketFunction(std::bind(&ICMPProtocol::processPacket, icmp, std::placeholders::_1));
+
+        inject(packet);
+
+        BOOST_CHECK(icmp->getTotalPackets() == 1);
+        BOOST_CHECK(ip->getProtocol() == IPPROTO_ICMP);
+        BOOST_CHECK(icmp->getType() == ICMP_INFO_REQUEST);
+        BOOST_CHECK(icmp->getCode() == 33); // What the fu...
+
+        nlohmann::json j;
+
+        icmp->statistics(j, 5);
+
+	// Check some values;
+#if defined(IS_DARWIN)
+	BOOST_CHECK(j["allocated_bytes"] == 240);
+#else
+	BOOST_CHECK(j["allocated_bytes"] == 256);
+#endif
+	BOOST_CHECK(j["dynamic_memory"] == false);
+	BOOST_CHECK(j["echo_requests"] == 0);
+	BOOST_CHECK(j["echo_replays"] == 0);
+	BOOST_CHECK(j["info_requests"] == 1);
+	BOOST_CHECK(j["info_replays"] == 0);
+}
+
+BOOST_AUTO_TEST_CASE (test12) // icmp info reply
+{
+        Packet packet("../icmp/packets/packet12.pcap");
+
+        mux_icmp->addPacketFunction(std::bind(&ICMPProtocol::processPacket, icmp, std::placeholders::_1));
+
+        inject(packet);
+
+        BOOST_CHECK(icmp->getTotalPackets() == 1);
+        BOOST_CHECK(ip->getProtocol() == IPPROTO_ICMP);
+        BOOST_CHECK(icmp->getType() == ICMP_INFO_REPLY);
+        BOOST_CHECK(icmp->getCode() == 118);
+}
+
+BOOST_AUTO_TEST_CASE (test13) // icmp masked address requesti
+{
+        Packet packet("../icmp/packets/packet13.pcap");
+
+        mux_icmp->addPacketFunction(std::bind(&ICMPProtocol::processPacket, icmp, std::placeholders::_1));
+
+        inject(packet);
+
+        BOOST_CHECK(icmp->getTotalPackets() == 1);
+        BOOST_CHECK(ip->getProtocol() == IPPROTO_ICMP);
+        BOOST_CHECK(icmp->getType() == ICMP_ADDRESS);
+        BOOST_CHECK(icmp->getCode() == 0);
+}
+
 BOOST_AUTO_TEST_SUITE_END( )
 
diff --git a/src/protocols/icmp6/Makefile.am b/src/protocols/icmp6/Makefile.am
index 1d0fa8a3..352705d4 100644
--- a/src/protocols/icmp6/Makefile.am
+++ b/src/protocols/icmp6/Makefile.am
@@ -31,7 +31,7 @@ test_icmp6_SOURCES = 	../../Multiplexer.cc \
 
 test_icmp6_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_icmp6_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_icmp6_LDADD   = $(BOOST_LDFLAGS) -lboost_thread -lboost_system -lboost_log -lpthread -lboost_unit_test_framework
+test_icmp6_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lboost_system -lpthread -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/imap/IMAPInfo.cc b/src/protocols/imap/IMAPInfo.cc
index c052143f..26132e98 100644
--- a/src/protocols/imap/IMAPInfo.cc
+++ b/src/protocols/imap/IMAPInfo.cc
@@ -37,7 +37,7 @@ void IMAPInfo::reset() {
 std::ostream& operator<< (std::ostream &out, const IMAPInfo &info) {
 
 	if (info.isBanned()) 
-		out << "Banned";
+		out << " Banned";
 
 	if (info.user_name) 
 		out << " User:" << info.user_name->getName();
diff --git a/src/protocols/imap/IMAPProtocol.cc b/src/protocols/imap/IMAPProtocol.cc
index ce2f64af..da8719a4 100644
--- a/src/protocols/imap/IMAPProtocol.cc
+++ b/src/protocols/imap/IMAPProtocol.cc
@@ -451,18 +451,25 @@ CounterMap IMAPProtocol::getCounters() const {
 
 #if defined(PYTHON_BINDING) || defined(RUBY_BINDING) 
 #if defined(PYTHON_BINDING)
-boost::python::dict IMAPProtocol::getCache() const {
+boost::python::dict IMAPProtocol::getCacheData(const std::string &name) const {
 #elif defined(RUBY_BINDING)
-VALUE IMAPProtocol::getCache() const {
+VALUE IMAPProtocol::getCacheData(const std::string &name) const {
 #endif
-        return addMapToHash(user_map_);
+        if (boost::iequals(name, "user"))
+		return addMapToHash(user_map_);
+
+        return addMapToHash({});
 }
 
 #if defined(PYTHON_BINDING)
-void IMAPProtocol::showCache(std::basic_ostream<char> &out) const {
+SharedPointer<Cache<StringCache>> IMAPProtocol::getCache(const std::string &name) {
+
+        if (boost::iequals(name, "user"))
+                return user_cache_;
 
-	showCacheMap(out, "", user_map_,"IMAP Users","User");
+        return nullptr;
 }
+
 #endif
 
 #endif
diff --git a/src/protocols/imap/IMAPProtocol.h b/src/protocols/imap/IMAPProtocol.h
index 9009664e..6ac108d1 100644
--- a/src/protocols/imap/IMAPProtocol.h
+++ b/src/protocols/imap/IMAPProtocol.h
@@ -123,10 +123,10 @@ public:
 	CounterMap getCounters() const override; 
 
 #if defined(PYTHON_BINDING)
-	boost::python::dict getCache() const override;
-	void showCache(std::basic_ostream<char> &out) const override;
+	boost::python::dict getCacheData(const std::string &name) const override;
+        SharedPointer<Cache<StringCache>> getCache(const std::string &name) override;
 #elif defined(RUBY_BINDING)
-	VALUE getCache() const;
+	VALUE getCacheData(const std::string &name) const;
 #endif
 
 	void setAnomalyManager(SharedPointer<AnomalyManager> amng) override { anomaly_ = amng; }
diff --git a/src/protocols/imap/Makefile.am b/src/protocols/imap/Makefile.am
index f526cbf8..ade4f75d 100644
--- a/src/protocols/imap/Makefile.am
+++ b/src/protocols/imap/Makefile.am
@@ -36,7 +36,7 @@ test_imap_SOURCES = 	../../Multiplexer.cc \
 
 test_imap_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_imap_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_imap_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_system -lboost_log -lboost_thread -lboost_unit_test_framework
+test_imap_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so *.log
 
diff --git a/src/protocols/ip/IPProtocol.cc b/src/protocols/ip/IPProtocol.cc
index e1180a6c..889cb1d4 100644
--- a/src/protocols/ip/IPProtocol.cc
+++ b/src/protocols/ip/IPProtocol.cc
@@ -79,6 +79,8 @@ bool IPProtocol::processPacket(Packet &packet) {
 	mux->setNextProtocolIdentifier(getProtocol());
 	packet.setPrevHeaderSize(header_size);
 
+	packet.setTTL(getTTL());
+
 #ifdef DEBUG
 	std::cout << __FILE__ << ":" << __func__ << ": ip.src(" << getSrcAddrDotNotation() << ")ip.dst(" << getDstAddrDotNotation() << ")ip.id(" << getID() << ")" ;
 	std::cout << "ip.hdrlen(" << getIPHeaderLength() << ")ip.len(" << getPacketLength() << ")ip.ttl(" << (int)getTTL() << ")" << std::endl;
diff --git a/src/protocols/ip/Makefile.am b/src/protocols/ip/Makefile.am
index ba0c2be6..22476590 100644
--- a/src/protocols/ip/Makefile.am
+++ b/src/protocols/ip/Makefile.am
@@ -28,7 +28,7 @@ test_ip_SOURCES = 	../../Multiplexer.cc \
 
 test_ip_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../../ $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_ip_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_ip_LDADD   = $(BOOST_LDFLAGS) -lboost_system -lboost_log -lboost_thread -lpthread -lboost_unit_test_framework
+test_ip_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lboost_system -lpthread -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/ip6/IPv6Protocol.cc b/src/protocols/ip6/IPv6Protocol.cc
index 93ae17ff..52bf2600 100644
--- a/src/protocols/ip6/IPv6Protocol.cc
+++ b/src/protocols/ip6/IPv6Protocol.cc
@@ -136,6 +136,8 @@ bool IPv6Protocol::processPacket(Packet &packet) {
 
 				l7_next_protocol_ = next_proto;
 
+				packet.setTTL(getTTL());
+
         			mux->setHeaderSize(header_size + extension_length);
        				mux->setNextProtocolIdentifier(next_proto);
        				packet.setPrevHeaderSize(header_size + extension_length);
diff --git a/src/protocols/ip6/IPv6Protocol.h b/src/protocols/ip6/IPv6Protocol.h
index e5aa580a..c2f6ba35 100644
--- a/src/protocols/ip6/IPv6Protocol.h
+++ b/src/protocols/ip6/IPv6Protocol.h
@@ -65,6 +65,7 @@ public:
 
 	bool isIPver6() const { return (header_->ip6_vfc >> 4) == 6 ; }
 	uint8_t getProtocol() const { return header_->ip6_nxt; }
+	uint8_t getTTL() const { return header_->ip6_hops; }
 	uint8_t getL7Protocol() const { return l7_next_protocol_; }
     	uint16_t getPayloadLength() const { return ntohs(header_->ip6_plen); }
     	char* getSrcAddrDotNotation() const ; 
diff --git a/src/protocols/ip6/Makefile.am b/src/protocols/ip6/Makefile.am
index 6c6037de..2574ef01 100644
--- a/src/protocols/ip6/Makefile.am
+++ b/src/protocols/ip6/Makefile.am
@@ -32,7 +32,7 @@ test_ip6_SOURCES = 	../../Multiplexer.cc \
 
 test_ip6_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -I../../test -DSTAND_ALONE_TEST
 test_ip6_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_ip6_LDADD   = $(BOOST_LDFLAGS) -lboost_system -lboost_log -lboost_thread -lpthread -lboost_unit_test_framework
+test_ip6_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lboost_system -lpthread -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/ip6/test_ip6.cc b/src/protocols/ip6/test_ip6.cc
index 8abba3ac..c22db5bb 100644
--- a/src/protocols/ip6/test_ip6.cc
+++ b/src/protocols/ip6/test_ip6.cc
@@ -61,6 +61,7 @@ BOOST_AUTO_TEST_CASE (test02)
 
         BOOST_CHECK(eth->getEthernetType() == ETHERTYPE_IPV6);
         BOOST_CHECK(ip6->isIPver6() == true);
+        BOOST_CHECK(ip6->getTTL() == 1);
 	BOOST_CHECK(ip6->getPayloadLength() == 41);
 	BOOST_CHECK(srcip.compare(ip6->getSrcAddrDotNotation()) == 0);
 	BOOST_CHECK(dstip.compare(ip6->getDstAddrDotNotation()) == 0);
@@ -84,6 +85,7 @@ BOOST_AUTO_TEST_CASE (test03)
 	BOOST_CHECK(srcip.compare(ip6->getSrcAddrDotNotation()) == 0);
 	BOOST_CHECK(dstip.compare(ip6->getDstAddrDotNotation()) == 0);
 	BOOST_CHECK(ip6->getProtocol() == IPPROTO_ICMPV6);
+        BOOST_CHECK(ip6->getTTL() == 64);
 	BOOST_CHECK(ip6->getTotalEvents() == 0);
         
 	BOOST_CHECK(ip6->getTotalFragPackets() == 0); 
@@ -136,6 +138,7 @@ BOOST_AUTO_TEST_CASE (test05) // ethernet -> ip6 -> dsthdropts -> tcp -> http
 
         BOOST_CHECK(mux_eth->getCurrentPacket()->getLength() == packet.getLength());
 
+        BOOST_CHECK(ip6->getTTL() == 64);
         BOOST_CHECK(ip6->getTotalPackets() == 1);
         BOOST_CHECK(ip6->getTotalValidPackets() == 1);
         BOOST_CHECK(ip6->getTotalInvalidPackets() == 0);
@@ -170,6 +173,7 @@ BOOST_AUTO_TEST_CASE (test06) // ethernet -> ip6 -> fragmented
         mux_eth->forwardPacket(packet);
 
         BOOST_CHECK(ip6->isIPver6() == true);
+        BOOST_CHECK(ip6->getTTL() == 0);
 
         BOOST_CHECK(ip6->getTotalPackets() == 1);
         BOOST_CHECK(ip6->getTotalValidPackets() == 1);
@@ -201,6 +205,7 @@ BOOST_AUTO_TEST_CASE (test07) // ethernet -> ip6 -> hophop -> dsthdropts -> tcp
         mux_eth->forwardPacket(packet);
 
         BOOST_CHECK(ip6->isIPver6() == true);
+        BOOST_CHECK(ip6->getTTL() == 64);
         BOOST_CHECK(mux_eth->getCurrentPacket()->getLength() == packet.getLength());
 
         BOOST_CHECK(ip6->getTotalPackets() == 1);
diff --git a/src/protocols/modbus/Makefile.am b/src/protocols/modbus/Makefile.am
index 9858c24b..d0a63254 100644
--- a/src/protocols/modbus/Makefile.am
+++ b/src/protocols/modbus/Makefile.am
@@ -35,7 +35,7 @@ test_modbus_SOURCES = 	../../Multiplexer.cc \
 
 test_modbus_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_modbus_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_modbus_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_system -lboost_unit_test_framework -lboost_log -lboost_thread
+test_modbus_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/mpls/Makefile.am b/src/protocols/mpls/Makefile.am
index a77e96a0..d8ad24a4 100644
--- a/src/protocols/mpls/Makefile.am
+++ b/src/protocols/mpls/Makefile.am
@@ -27,7 +27,7 @@ test_mpls_SOURCES = 	../../Multiplexer.cc \
 
 test_mpls_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_mpls_LDFLAGS = $(EXTRA_TEST_LDFLAGS) 
-test_mpls_LDADD   = $(BOOST_LDFLAGS) -lboost_unit_test_framework -lboost_system -lpthread -lboost_log -lboost_thread
+test_mpls_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lboost_unit_test_framework -lboost_system -lpthread
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/mqtt/MQTTProtocol.cc b/src/protocols/mqtt/MQTTProtocol.cc
index 1ef8e105..fd705183 100644
--- a/src/protocols/mqtt/MQTTProtocol.cc
+++ b/src/protocols/mqtt/MQTTProtocol.cc
@@ -375,18 +375,25 @@ CounterMap MQTTProtocol::getCounters() const {
 
 #if defined(PYTHON_BINDING) || defined(RUBY_BINDING) 
 #if defined(PYTHON_BINDING)
-boost::python::dict MQTTProtocol::getCache() const {
+boost::python::dict MQTTProtocol::getCacheData(const std::string &name) const {
 #elif defined(RUBY_BINDING)
-VALUE MQTTProtocol::getCache() const {
+VALUE MQTTProtocol::getCacheData(const std::string &name) const {
 #endif
-        return addMapToHash(topic_map_);
+        if (boost::iequals(name, "topic"))
+		return addMapToHash(topic_map_);
+
+        return addMapToHash({});
 }
 
 #if defined(PYTHON_BINDING)
-void MQTTProtocol::showCache(std::basic_ostream<char> &out) const {
+SharedPointer<Cache<StringCache>> MQTTProtocol::getCache(const std::string &name) {
+
+        if (boost::iequals(name, "topic"))
+                return topic_cache_;
 
-        showCacheMap(out, "", topic_map_, "MQTT Topics", "Topic");
+        return nullptr;
 }
+
 #endif
 
 #endif
diff --git a/src/protocols/mqtt/MQTTProtocol.h b/src/protocols/mqtt/MQTTProtocol.h
index 1cf5e3e0..41180093 100644
--- a/src/protocols/mqtt/MQTTProtocol.h
+++ b/src/protocols/mqtt/MQTTProtocol.h
@@ -133,10 +133,10 @@ public:
 	CounterMap getCounters() const override; 
 
 #if defined(PYTHON_BINDING)
-        boost::python::dict getCache() const override;
-	void showCache(std::basic_ostream<char> &out) const override;
+        boost::python::dict getCacheData(const std::string &name) const override;
+	SharedPointer<Cache<StringCache>> getCache(const std::string &name) override;
 #elif defined(RUBY_BINDING)
-        VALUE getCache() const;
+        VALUE getCacheData(const std::string &name) const;
 #endif
 	void setAnomalyManager(SharedPointer<AnomalyManager> amng) override { anomaly_ = amng; }
 
diff --git a/src/protocols/mqtt/Makefile.am b/src/protocols/mqtt/Makefile.am
index f186120c..16f05b32 100644
--- a/src/protocols/mqtt/Makefile.am
+++ b/src/protocols/mqtt/Makefile.am
@@ -46,7 +46,7 @@ test_mqtt_SOURCES = 	../../Multiplexer.cc \
 
 test_mqtt_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_mqtt_LDFLAGS = $(EXTRA_TEST_LDFLAGS) 
-test_mqtt_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_system -lboost_log -lboost_thread -lboost_unit_test_framework
+test_mqtt_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/mqtt/test_mqtt.cc b/src/protocols/mqtt/test_mqtt.cc
index 2d770800..8e9261d2 100644
--- a/src/protocols/mqtt/test_mqtt.cc
+++ b/src/protocols/mqtt/test_mqtt.cc
@@ -314,7 +314,7 @@ BOOST_AUTO_TEST_CASE (test09)
 	{
 		RedirectOutput r;
 
-        	flow->showFlowInfo(r.cout);
+        	flow->show(r.cout);
         	r.cout << *(info.get());
 	}
 
diff --git a/src/protocols/netbios/Makefile.am b/src/protocols/netbios/Makefile.am
index 41852b2f..96589a34 100644
--- a/src/protocols/netbios/Makefile.am
+++ b/src/protocols/netbios/Makefile.am
@@ -36,7 +36,7 @@ test_netbios_SOURCES = 	../../Multiplexer.cc \
 
 test_netbios_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_netbios_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_netbios_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_system -lboost_log -lboost_thread -lboost_unit_test_framework
+test_netbios_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/netbios/NetbiosProtocol.cc b/src/protocols/netbios/NetbiosProtocol.cc
index 9494e282..5e785e5f 100644
--- a/src/protocols/netbios/NetbiosProtocol.cc
+++ b/src/protocols/netbios/NetbiosProtocol.cc
@@ -284,18 +284,25 @@ CounterMap NetbiosProtocol::getCounters() const {
 
 #if defined(PYTHON_BINDING) || defined(RUBY_BINDING) 
 #if defined(PYTHON_BINDING)
-boost::python::dict NetbiosProtocol::getCache() const {
+boost::python::dict NetbiosProtocol::getCacheData(const std::string &name) const {
 #elif defined(RUBY_BINDING)
-VALUE NetbiosProtocol::getCache() const {
+VALUE NetbiosProtocol::getCacheData(const std::string &name) const {
 #endif
-        return addMapToHash(name_map_);
+        if (boost::iequals(name, "name"))
+		return addMapToHash(name_map_);
+
+        return addMapToHash({});
 }
 
 #if defined(PYTHON_BINDING)
-void NetbiosProtocol::showCache(std::basic_ostream<char> &out) const {
+SharedPointer<Cache<StringCache>> NetbiosProtocol::getCache(const std::string &name) {
+
+        if (boost::iequals(name, "name"))
+                return name_cache_;
 
-        showCacheMap(out, "", name_map_, "Netbios names", "Name");
+        return nullptr;
 }
+
 #endif
 
 #endif
diff --git a/src/protocols/netbios/NetbiosProtocol.h b/src/protocols/netbios/NetbiosProtocol.h
index 3ea78b17..5924416f 100644
--- a/src/protocols/netbios/NetbiosProtocol.h
+++ b/src/protocols/netbios/NetbiosProtocol.h
@@ -91,10 +91,10 @@ public:
 	CounterMap getCounters() const override; 
 
 #if defined(PYTHON_BINDING)
-        boost::python::dict getCache() const override;
-	void showCache(std::basic_ostream<char> &out) const override;
+        boost::python::dict getCacheData(const std::string &name) const override;
+        SharedPointer<Cache<StringCache>> getCache(const std::string &name) override;
 #elif defined(RUBY_BINDING)
-        VALUE getCache() const;
+        VALUE getCacheData(const std::string &name) const;
 #endif
         void setAnomalyManager(SharedPointer<AnomalyManager> amng) override { anomaly_ = amng; }
 
diff --git a/src/protocols/ntp/Makefile.am b/src/protocols/ntp/Makefile.am
index 79b0e9c0..056b5a28 100644
--- a/src/protocols/ntp/Makefile.am
+++ b/src/protocols/ntp/Makefile.am
@@ -39,7 +39,7 @@ test_ntp_SOURCES = 	../../Multiplexer.cc \
 
 test_ntp_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_ntp_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_ntp_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_system -lboost_unit_test_framework -lboost_log -lboost_thread
+test_ntp_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/openflow/Makefile.am b/src/protocols/openflow/Makefile.am
index 5910fd34..504aee26 100644
--- a/src/protocols/openflow/Makefile.am
+++ b/src/protocols/openflow/Makefile.am
@@ -54,7 +54,7 @@ test_openflow_SOURCES =	../../Multiplexer.cc \
 
 test_openflow_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_openflow_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_openflow_LDADD   = $(BOOST_LDFLAGS) $(PCRE_LIB) -lboost_log -lboost_thread -lpthread -lboost_system -lboost_unit_test_framework
+test_openflow_LDADD   = $(BOOST_LDFLAGS) $(PCRE_LIB) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/openflow/test_openflow.cc b/src/protocols/openflow/test_openflow.cc
index b767fcf1..174f4ef3 100644
--- a/src/protocols/openflow/test_openflow.cc
+++ b/src/protocols/openflow/test_openflow.cc
@@ -64,6 +64,7 @@ BOOST_AUTO_TEST_CASE (test02)
         BOOST_CHECK(ip->getTotalPackets() == 1);
         BOOST_CHECK(ip->getTotalValidPackets() == 1);
         BOOST_CHECK(ip->getTotalBytes() == 60);
+        BOOST_CHECK(ip->getTTL() == 64);
 
         BOOST_CHECK(of->getTotalPackets() == 1);
         BOOST_CHECK(of->getTotalValidPackets() == 1);
@@ -81,6 +82,9 @@ BOOST_AUTO_TEST_CASE (test02)
 
 	inject(packet2);
 
+        BOOST_CHECK(ip->getTotalPackets() == 2);
+        BOOST_CHECK(ip->getTTL() == 64);
+
         BOOST_CHECK(of->getTotalPackets() == 2);
         BOOST_CHECK(of->getTotalValidPackets() == 1);
         BOOST_CHECK(of->getTotalInvalidPackets() == 0);
@@ -96,6 +100,9 @@ BOOST_AUTO_TEST_CASE (test02)
         BOOST_CHECK(of->getTotalPacketsOut() == 0);
 
 	inject(packet3);
+        
+        BOOST_CHECK(ip->getTotalPackets() == 3);
+	BOOST_CHECK(ip->getTTL() == 64);
 
         BOOST_CHECK(of->getTotalPackets() == 3);
         BOOST_CHECK(of->getTotalValidPackets() == 1);
@@ -149,6 +156,8 @@ BOOST_AUTO_TEST_CASE (test04)
 
 	inject(packet);
 
+	BOOST_CHECK(ip->getTTL() == 64);
+
         BOOST_CHECK(of->getTotalPackets() == 1);
         BOOST_CHECK(of->getTotalValidPackets() == 1);
         BOOST_CHECK(of->getTotalInvalidPackets() == 0);
@@ -156,6 +165,11 @@ BOOST_AUTO_TEST_CASE (test04)
         BOOST_CHECK(of->getType() == OFP_PACKET_IN);
         BOOST_CHECK(of->getLength() == 146);
 
+	Flow *flow = tcp->getCurrentFlow();
+	BOOST_CHECK(flow != nullptr);
+	BOOST_CHECK(flow->upstream_ttl == 64);
+	BOOST_CHECK(flow->downstream_ttl == 0);
+
 	BOOST_CHECK(eth_vir->getTotalPackets() == 1);
 	BOOST_CHECK(eth_vir->getTotalBytes() == 128);
 	BOOST_CHECK(eth_vir->getTotalValidPackets() == 1);
@@ -163,6 +177,7 @@ BOOST_AUTO_TEST_CASE (test04)
 
 	BOOST_CHECK(ip_vir->getTotalPackets() == 1);
 	BOOST_CHECK(ip_vir->getTotalBytes() == 114);
+	BOOST_CHECK(ip_vir->getTTL() == 1);
 	
 	BOOST_CHECK(udp_vir->getTotalPackets() == 1);
 	BOOST_CHECK(udp_vir->getTotalBytes() == 94);
@@ -172,6 +187,11 @@ BOOST_AUTO_TEST_CASE (test04)
 	BOOST_CHECK(udpg_vir->getTotalPackets() == 1);
 	BOOST_CHECK(udpg_vir->getTotalBytes() == 86);
 
+	flow = udp_vir->getCurrentFlow();
+	BOOST_CHECK(flow != nullptr);
+	BOOST_CHECK(flow->upstream_ttl == 1);
+	BOOST_CHECK(flow->downstream_ttl == 0);
+
 	BOOST_CHECK(rm->getTotalRegexs()  == 1);
         BOOST_CHECK(rm->getTotalMatchingRegexs() == 1);
         BOOST_CHECK(rm->getMatchedRegex() != nullptr);
diff --git a/src/protocols/pop/Makefile.am b/src/protocols/pop/Makefile.am
index e7d81f8d..eada0301 100644
--- a/src/protocols/pop/Makefile.am
+++ b/src/protocols/pop/Makefile.am
@@ -37,7 +37,7 @@ test_pop_SOURCES = 	../../Multiplexer.cc \
 
 test_pop_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_pop_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_pop_LDADD   = $(BOOST_LDFLAGS) -lboost_log -lboost_thread -lpthread -lboost_system -lboost_unit_test_framework
+test_pop_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/pop/POPInfo.cc b/src/protocols/pop/POPInfo.cc
index 7d4f8c96..3cc22eec 100644
--- a/src/protocols/pop/POPInfo.cc
+++ b/src/protocols/pop/POPInfo.cc
@@ -36,7 +36,7 @@ void POPInfo::reset() {
 std::ostream& operator<< (std::ostream &out, const POPInfo &info) {
 
 	if (info.isBanned()) 
-		out << "Banned";
+		out << " Banned";
 
 	if (info.user_name) 
 		out << " User:" << info.user_name->getName();
diff --git a/src/protocols/pop/POPProtocol.cc b/src/protocols/pop/POPProtocol.cc
index e0c070e7..54f9f4da 100644
--- a/src/protocols/pop/POPProtocol.cc
+++ b/src/protocols/pop/POPProtocol.cc
@@ -419,18 +419,25 @@ CounterMap POPProtocol::getCounters() const {
 
 #if defined(PYTHON_BINDING) || defined(RUBY_BINDING) 
 #if defined(PYTHON_BINDING)
-boost::python::dict POPProtocol::getCache() const {
+boost::python::dict POPProtocol::getCacheData(const std::string &name) const {
 #elif defined(RUBY_BINDING)
-VALUE POPProtocol::getCache() const {
+VALUE POPProtocol::getCacheDate(const std::string &name) const {
 #endif
-        return addMapToHash(user_map_);
+        if (boost::iequals(name, "user"))
+		return addMapToHash(user_map_);
+
+        return addMapToHash({});
 }
 
 #if defined(PYTHON_BINDING)
-void POPProtocol::showCache(std::basic_ostream<char> &out) const {
+SharedPointer<Cache<StringCache>> POPProtocol::getCache(const std::string &name) {
+
+        if (boost::iequals(name, "user"))
+                return user_cache_;
 
-	showCacheMap(out, "", user_map_, "POP users", "Users");
+        return nullptr;
 }
+
 #endif
 
 #endif
diff --git a/src/protocols/pop/POPProtocol.h b/src/protocols/pop/POPProtocol.h
index 9b79cd2a..a3730728 100644
--- a/src/protocols/pop/POPProtocol.h
+++ b/src/protocols/pop/POPProtocol.h
@@ -109,10 +109,10 @@ public:
 	CounterMap getCounters() const override; 
 
 #if defined(PYTHON_BINDING)
-        boost::python::dict getCache() const override;
-	void showCache(std::basic_ostream<char> &out) const override;
+        boost::python::dict getCacheData(const std::string &name) const override;
+	SharedPointer<Cache<StringCache>> getCache(const std::string &name) override;
 #elif defined(RUBY_BINDING)
-        VALUE getCache() const;
+        VALUE getCacheData(const std::string &name) const;
 #endif
 
 	void setAnomalyManager(SharedPointer<AnomalyManager> amng) override { anomaly_ = amng; }
diff --git a/src/protocols/pppoe/Makefile.am b/src/protocols/pppoe/Makefile.am
index 24773773..582d94a9 100644
--- a/src/protocols/pppoe/Makefile.am
+++ b/src/protocols/pppoe/Makefile.am
@@ -28,7 +28,7 @@ test_pppoe_SOURCES = 	../../Multiplexer.cc \
 
 test_pppoe_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_pppoe_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_pppoe_LDADD   = $(BOOST_LDFLAGS) -lboost_system -lboost_log -lboost_thread -lpthread -lboost_unit_test_framework
+test_pppoe_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lboost_system -lpthread -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/quic/Makefile.am b/src/protocols/quic/Makefile.am
index a6d60c3b..c7494d5b 100644
--- a/src/protocols/quic/Makefile.am
+++ b/src/protocols/quic/Makefile.am
@@ -38,7 +38,7 @@ test_quic_SOURCES = 	../../Multiplexer.cc \
 
 test_quic_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_quic_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_quic_LDADD   = $(BOOST_LDFLAGS) -lboost_thread -lboost_log -lpthread -lboost_system -lboost_unit_test_framework
+test_quic_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/quic/test_quic.cc b/src/protocols/quic/test_quic.cc
index 41b8538e..11e50496 100644
--- a/src/protocols/quic/test_quic.cc
+++ b/src/protocols/quic/test_quic.cc
@@ -134,7 +134,7 @@ BOOST_AUTO_TEST_CASE (test04)
 
         nlohmann::json j;
 
-	flow->showFlowInfo(j);
+	flow->show(j);
 
 	BOOST_CHECK(host.compare(j["quic"]["host"]) == 0);
 	BOOST_CHECK(j["proto"] == IPPROTO_UDP);
@@ -173,7 +173,7 @@ BOOST_AUTO_TEST_CASE (test05)
 
         nlohmann::json j;
 
-	flow->showFlowInfo(j);
+	flow->show(j);
 
 	BOOST_CHECK(host.compare(j["quic"]["host"]) == 0);
 	BOOST_CHECK(j["proto"] == IPPROTO_UDP);
@@ -225,7 +225,7 @@ BOOST_AUTO_TEST_CASE (test06)
 
         nlohmann::json j;
 
-        flow->showFlowInfo(j);
+        flow->show(j);
 
         BOOST_CHECK(host.compare(j["quic"]["host"]) == 0);
         BOOST_CHECK(j["proto"] == IPPROTO_UDP);
@@ -235,7 +235,7 @@ BOOST_AUTO_TEST_CASE (test06)
         fb.open ("/dev/null",std::ios::out);
         std::ostream outp(&fb);
         outp << *info.get();
-        flow->showFlowInfo(outp);
+        flow->show(outp);
         fb.close();
  
 	quic->decreaseAllocatedMemory(1);
diff --git a/src/protocols/rtp/Makefile.am b/src/protocols/rtp/Makefile.am
index d3540c46..5a75c78a 100644
--- a/src/protocols/rtp/Makefile.am
+++ b/src/protocols/rtp/Makefile.am
@@ -38,7 +38,7 @@ test_rtp_SOURCES = 	../../Multiplexer.cc \
 
 test_rtp_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_rtp_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_rtp_LDADD   = $(BOOST_LDFLAGS) -lboost_log -lboost_thread -lpthread -lboost_system -lboost_unit_test_framework
+test_rtp_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/sip/Makefile.am b/src/protocols/sip/Makefile.am
index 8b2a3df7..14abdb83 100644
--- a/src/protocols/sip/Makefile.am
+++ b/src/protocols/sip/Makefile.am
@@ -35,7 +35,7 @@ test_sip_SOURCES = 	../../Multiplexer.cc \
 
 test_sip_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_sip_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_sip_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_system -lboost_log -lboost_thread -lboost_unit_test_framework $(PCRE_LIB)
+test_sip_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) $(PCRE_LIB) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/sip/SIPProtocol.cc b/src/protocols/sip/SIPProtocol.cc
index 6d926fe1..bed9f42e 100644
--- a/src/protocols/sip/SIPProtocol.cc
+++ b/src/protocols/sip/SIPProtocol.cc
@@ -639,18 +639,38 @@ CounterMap SIPProtocol::getCounters() const {
 
 #if defined(PYTHON_BINDING) || defined(RUBY_BINDING) 
 #if defined(PYTHON_BINDING)
-boost::python::dict SIPProtocol::getCache() const {
+boost::python::dict SIPProtocol::getCacheData(const std::string &name) const {
 #elif defined(RUBY_BINDING)
-VALUE SIPProtocol::getCache() const {
+VALUE SIPProtocol::getCacheData(const std::string &name) const {
 #endif
-        return addMapToHash(uri_map_);
+
+        if (boost::iequals(name, "uri"))
+		return addMapToHash(uri_map_);
+        else if (boost::iequals(name, "via"))
+		return addMapToHash(via_map_);
+        else if (boost::iequals(name, "from"))
+		return addMapToHash(from_map_);
+        else if (boost::iequals(name, "to"))
+		return addMapToHash(to_map_);
+
+        return addMapToHash({});
 }
 
 #if defined(PYTHON_BINDING)
-void SIPProtocol::showCache(std::basic_ostream<char> &out) const {
+SharedPointer<Cache<StringCache>> SIPProtocol::getCache(const std::string &name) {
 
-	showCacheMap(out, "", uri_map_, "SIP Uris", "Uri");
+        if (boost::iequals(name, "uri"))
+                return uri_cache_;
+        else if (boost::iequals(name, "via"))
+                return via_cache_;
+        else if (boost::iequals(name, "from"))
+                return from_cache_;
+        else if (boost::iequals(name, "to"))
+                return to_cache_;
+
+        return nullptr;
 }
+
 #endif
 
 #endif
diff --git a/src/protocols/sip/SIPProtocol.h b/src/protocols/sip/SIPProtocol.h
index 4fbf53a8..a567421d 100644
--- a/src/protocols/sip/SIPProtocol.h
+++ b/src/protocols/sip/SIPProtocol.h
@@ -99,10 +99,10 @@ public:
 	void releaseFlowInfo(Flow *flow) override;
 
 #if defined(PYTHON_BINDING)
-        boost::python::dict getCache() const override;
-        void showCache(std::basic_ostream<char> &out) const override;
+        boost::python::dict getCacheData(const std::string &name) const override;
+        SharedPointer<Cache<StringCache>> getCache(const std::string &name) override;
 #elif defined(RUBY_BINDING)
-        VALUE getCache() const;
+        VALUE getCacheData(const std::string &name) const;
 #endif
 
 #if defined(STAND_ALONE_TEST) || defined(TESTING)
diff --git a/src/protocols/smb/Makefile.am b/src/protocols/smb/Makefile.am
index c97eaac5..b2d1a9d4 100644
--- a/src/protocols/smb/Makefile.am
+++ b/src/protocols/smb/Makefile.am
@@ -67,7 +67,7 @@ test_smb_SOURCES = 	../../Multiplexer.cc \
 
 test_smb_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST 
 test_smb_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_smb_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_system -lboost_log -lboost_thread -lboost_unit_test_framework
+test_smb_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/smb/SMBProtocol.cc b/src/protocols/smb/SMBProtocol.cc
index 72b1e9ea..ebfddd88 100644
--- a/src/protocols/smb/SMBProtocol.cc
+++ b/src/protocols/smb/SMBProtocol.cc
@@ -514,18 +514,25 @@ CounterMap SMBProtocol::getCounters() const {
 
 #if defined(PYTHON_BINDING) || defined(RUBY_BINDING) 
 #if defined(PYTHON_BINDING)
-boost::python::dict SMBProtocol::getCache() const {
+boost::python::dict SMBProtocol::getCacheData(const std::string &name) const {
 #elif defined(RUBY_BINDING)
-VALUE SMBProtocol::getCache() const {
+VALUE SMBProtocol::getCacheData(const std::string &name) const {
 #endif
-        return addMapToHash(filename_map_);
+        if (boost::iequals(name, "filename"))
+		return addMapToHash(filename_map_);
+
+        return addMapToHash({});
 }
 
 #if defined(PYTHON_BINDING)
-void SMBProtocol::showCache(std::basic_ostream<char> &out) const {
+SharedPointer<Cache<StringCache>> SMBProtocol::getCache(const std::string &name) {
+
+        if (boost::iequals(name, "filename"))
+                return filename_cache_;
 
-	showCacheMap(out, "", filename_map_, "Filenames", "Name");
+        return nullptr;
 }
+
 #endif
 
 #endif
diff --git a/src/protocols/smb/SMBProtocol.h b/src/protocols/smb/SMBProtocol.h
index a3a6d0bf..8a1424a5 100644
--- a/src/protocols/smb/SMBProtocol.h
+++ b/src/protocols/smb/SMBProtocol.h
@@ -210,10 +210,10 @@ public:
 	Flow *getCurrentFlow() const { return current_flow_; }
 
 #if defined(PYTHON_BINDING)
-        boost::python::dict getCache() const override;
-        void showCache(std::basic_ostream<char> &out) const override;
+        boost::python::dict getCacheData(const std::string &name) const override;
+        SharedPointer<Cache<StringCache>> getCache(const std::string &name) override;
 #elif defined(RUBY_BINDING)
-        VALUE getCache() const;
+        VALUE getCacheData(const std::string &name) const;
 #endif
 
 private:
diff --git a/src/protocols/smb/test_smb.cc b/src/protocols/smb/test_smb.cc
index 68dc7f7b..f96455a6 100644
--- a/src/protocols/smb/test_smb.cc
+++ b/src/protocols/smb/test_smb.cc
@@ -230,7 +230,7 @@ BOOST_AUTO_TEST_CASE (test10)
         {
                 RedirectOutput r;
 
-                flow->showFlowInfo(r.cout);
+                flow->show(r.cout);
                 r.cout << *(info.get());
         }
 
@@ -376,7 +376,7 @@ BOOST_AUTO_TEST_CASE (test15)
 
 	nlohmann::json jf;
 
-	flow->showFlowInfo(jf);
+	flow->show(jf);
 }
 
 BOOST_AUTO_TEST_CASE (test16) // malformed packet
diff --git a/src/protocols/smtp/Makefile.am b/src/protocols/smtp/Makefile.am
index 39f08c4e..3e009b82 100644
--- a/src/protocols/smtp/Makefile.am
+++ b/src/protocols/smtp/Makefile.am
@@ -42,7 +42,7 @@ test_smtp_SOURCES = 	../../Multiplexer.cc \
 
 test_smtp_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_smtp_LDFLAGS = $(EXTRA_TEST_LDFLAGS) 
-test_smtp_LDADD   = $(BOOST_LDFLAGS) $(PCRE_LIB) -lpthread -lboost_log -lboost_thread -lboost_system -lboost_unit_test_framework
+test_smtp_LDADD   = $(BOOST_LDFLAGS) $(PCRE_LIB) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/smtp/SMTPInfo.cc b/src/protocols/smtp/SMTPInfo.cc
index 345ce6d1..7a1e5645 100644
--- a/src/protocols/smtp/SMTPInfo.cc
+++ b/src/protocols/smtp/SMTPInfo.cc
@@ -45,7 +45,7 @@ void SMTPInfo::resetStrings() {
 std::ostream& operator<< (std::ostream &out, const SMTPInfo &info) {
 
 	if (info.isBanned()) 
-		out << "Banned";
+		out << " Banned";
 
 	if (info.from)  
 		out << " From:" << info.from->getName();
diff --git a/src/protocols/smtp/SMTPProtocol.cc b/src/protocols/smtp/SMTPProtocol.cc
index 89f6c143..df464a00 100644
--- a/src/protocols/smtp/SMTPProtocol.cc
+++ b/src/protocols/smtp/SMTPProtocol.cc
@@ -547,18 +547,29 @@ CounterMap SMTPProtocol::getCounters() const {
 
 #if defined(PYTHON_BINDING) || defined(RUBY_BINDING)
 #if defined(PYTHON_BINDING)
-boost::python::dict SMTPProtocol::getCache() const {
+boost::python::dict SMTPProtocol::getCacheData(const std::string &name) const {
 #elif defined(RUBY_BINDING)
-VALUE SMTPProtocol::getCache() const {
+VALUE SMTPProtocol::getCacheData(const std::string &name) const {
 #endif
-        return addMapToHash(from_map_);
+        if (boost::iequals(name, "from"))
+		return addMapToHash(from_map_);
+        else if (boost::iequals(name, "to"))
+		return addMapToHash(to_map_);
+
+        return addMapToHash({});
 }
 
 #if defined(PYTHON_BINDING)
-void SMTPProtocol::showCache(std::basic_ostream<char> &out) const {
-	
-	showCacheMap(out, "", from_map_, "SMTP Froms", "From");
+SharedPointer<Cache<StringCache>> SMTPProtocol::getCache(const std::string &name) {
+
+        if (boost::iequals(name, "from"))
+                return from_cache_;
+        else if (boost::iequals(name, "to"))
+                return to_cache_;
+
+        return nullptr;
 }
+
 #endif
 
 #endif
diff --git a/src/protocols/smtp/SMTPProtocol.h b/src/protocols/smtp/SMTPProtocol.h
index 4f2524f6..911a5e83 100644
--- a/src/protocols/smtp/SMTPProtocol.h
+++ b/src/protocols/smtp/SMTPProtocol.h
@@ -112,10 +112,10 @@ public:
 	CounterMap getCounters() const override; 
 
 #if defined(PYTHON_BINDING)
-        boost::python::dict getCache() const override;
-	void showCache(std::basic_ostream<char> &out) const override;
+        boost::python::dict getCacheData(const std::string &name) const override;
+        SharedPointer<Cache<StringCache>> getCache(const std::string &name) override;
 #elif defined(RUBY_BINDING)
-        VALUE getCache() const;
+        VALUE getCacheData(const std::string &name) const;
 #endif
 
 	void setAnomalyManager(SharedPointer<AnomalyManager> amng) override { anomaly_ = amng; }
diff --git a/src/protocols/snmp/Makefile.am b/src/protocols/snmp/Makefile.am
index ac9a8777..63233a30 100644
--- a/src/protocols/snmp/Makefile.am
+++ b/src/protocols/snmp/Makefile.am
@@ -35,7 +35,7 @@ test_snmp_SOURCES = 	../../Multiplexer.cc \
 
 test_snmp_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_snmp_LDFLAGS = $(EXTRA_TEST_LDFLAGS) 
-test_snmp_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_system -lboost_unit_test_framework -lboost_log -lboost_thread
+test_snmp_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/ssdp/Makefile.am b/src/protocols/ssdp/Makefile.am
index 1e129afb..82f91ebf 100644
--- a/src/protocols/ssdp/Makefile.am
+++ b/src/protocols/ssdp/Makefile.am
@@ -33,7 +33,7 @@ test_ssdp_SOURCES = 	../../Multiplexer.cc \
 
 test_ssdp_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_ssdp_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_ssdp_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_system -lboost_log -lboost_thread -lboost_unit_test_framework
+test_ssdp_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/ssdp/SSDPInfo.cc b/src/protocols/ssdp/SSDPInfo.cc
index 839e74d8..f4571bb5 100644
--- a/src/protocols/ssdp/SSDPInfo.cc
+++ b/src/protocols/ssdp/SSDPInfo.cc
@@ -45,7 +45,7 @@ void SSDPInfo::resetStrings() {
 std::ostream& operator<< (std::ostream &out, const SSDPInfo &info) {
 
 	if (info.isBanned()) 
-		out << "Banned";
+		out << " Banned";
 
 	if (info.host_name) 
 		out << " Host:" << info.host_name->getName();
diff --git a/src/protocols/ssdp/SSDPProtocol.cc b/src/protocols/ssdp/SSDPProtocol.cc
index 23750586..cf5921d4 100644
--- a/src/protocols/ssdp/SSDPProtocol.cc
+++ b/src/protocols/ssdp/SSDPProtocol.cc
@@ -630,18 +630,29 @@ CounterMap SSDPProtocol::getCounters() const {
 
 #if defined(PYTHON_BINDING) || defined(RUBY_BINDING)
 #if defined(PYTHON_BINDING)
-boost::python::dict SSDPProtocol::getCache() const {
+boost::python::dict SSDPProtocol::getCacheData(const std::string &name) const {
 #elif defined(RUBY_BINDING)
-VALUE SSDPProtocol::getCache() const {
+VALUE SSDPProtocol::getCacheData(const std::string &name) const {
 #endif
-	return addMapToHash(host_map_);
+        if (boost::iequals(name, "host"))
+		return addMapToHash(host_map_);
+        else if (boost::iequals(name, "uri"))
+		return addMapToHash(uri_map_);
+
+	return addMapToHash({});
 }
 
 #if defined(PYTHON_BINDING)
-void SSDPProtocol::showCache(std::basic_ostream<char> &out) const {
+SharedPointer<Cache<StringCache>> SSDPProtocol::getCache(const std::string &name) {
+
+        if (boost::iequals(name, "host"))
+                return host_cache_;
+        else if (boost::iequals(name, "uri"))
+                return uri_cache_;
 
-	showCacheMap(out, "", host_map_, "SSDP Hosts", "Host");
+        return nullptr;
 }
+
 #endif
 
 #endif
diff --git a/src/protocols/ssdp/SSDPProtocol.h b/src/protocols/ssdp/SSDPProtocol.h
index ffcd1d61..3b15b530 100644
--- a/src/protocols/ssdp/SSDPProtocol.h
+++ b/src/protocols/ssdp/SSDPProtocol.h
@@ -102,10 +102,10 @@ public:
 	CounterMap getCounters() const override; 
 
 #if defined(PYTHON_BINDING)
-	boost::python::dict getCache() const override;
-	void showCache(std::basic_ostream<char> &out) const override;
+	boost::python::dict getCacheData(const std::string &name) const override;
+        SharedPointer<Cache<StringCache>> getCache(const std::string &name) override;
 #elif defined(RUBY_BINDING)
-	VALUE getCache() const;
+	VALUE getCacheData(const std::string &name) const;
 #endif
 
 	void releaseFlowInfo(Flow *flow) override;
@@ -134,7 +134,7 @@ private:
 
 	const uint8_t *header_ = nullptr;
 	int16_t ssdp_header_size_ = 0;
-        int64_t total_events_ = 0;
+        int32_t total_events_ = 0;
         int32_t total_ban_hosts_ = 0;
 	int32_t total_allow_hosts_ = 0;
 	int32_t total_requests_ = 0;
diff --git a/src/protocols/ssdp/test_ssdp.cc b/src/protocols/ssdp/test_ssdp.cc
index 68eba2a8..5353199b 100644
--- a/src/protocols/ssdp/test_ssdp.cc
+++ b/src/protocols/ssdp/test_ssdp.cc
@@ -272,7 +272,7 @@ BOOST_AUTO_TEST_CASE (test06)
         fb.open ("/dev/null",std::ios::out);
         std::ostream outp(&fb);
         outp << *info1.get();
-        flow1->showFlowInfo(outp);
+        flow1->show(outp);
         fb.close();
 }
 
@@ -376,7 +376,7 @@ BOOST_AUTO_TEST_CASE (test09) // match a given domain
         fb.open ("/dev/null",std::ios::out);
         std::ostream outp(&fb);
         outp << *info.get();
-        flow->showFlowInfo(outp);
+        flow->show(outp);
         fb.close();
 }
 
diff --git a/src/protocols/ssh/Makefile.am b/src/protocols/ssh/Makefile.am
index 6d3bc35b..29d191b4 100644
--- a/src/protocols/ssh/Makefile.am
+++ b/src/protocols/ssh/Makefile.am
@@ -47,7 +47,7 @@ test_ssh_SOURCES = 	../../Multiplexer.cc \
 
 test_ssh_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST 
 test_ssh_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_ssh_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_system -lboost_log -lboost_thread -lboost_unit_test_framework
+test_ssh_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/ssh/SSHProtocol.cc b/src/protocols/ssh/SSHProtocol.cc
index 1ef25c5e..9b08a1c9 100644
--- a/src/protocols/ssh/SSHProtocol.cc
+++ b/src/protocols/ssh/SSHProtocol.cc
@@ -322,18 +322,25 @@ CounterMap SSHProtocol::getCounters() const {
 
 #if defined(PYTHON_BINDING) || defined(RUBY_BINDING) 
 #if defined(PYTHON_BINDING)
-boost::python::dict SSHProtocol::getCache() const {
+boost::python::dict SSHProtocol::getCacheData(const std::string &name) const {
 #elif defined(RUBY_BINDING)
-VALUE SSHProtocol::getCache() const {
+VALUE SSHProtocol::getCacheData(const std::string &name) const {
 #endif
-        return addMapToHash(name_map_);
+        if (boost::iequals(name, "name"))
+        	return addMapToHash(name_map_);
+
+        return addMapToHash({});
 }
 
 #if defined(PYTHON_BINDING)
-void SSHProtocol::showCache(std::basic_ostream<char> &out) const {
+SharedPointer<Cache<StringCache>> SSHProtocol::getCache(const std::string &name) {
+
+        if (boost::iequals(name, "name"))
+                return name_cache_;
 
-        showCacheMap(out, "", name_map_, "Names", "Name");
+        return nullptr;
 }
+
 #endif
 
 #endif
diff --git a/src/protocols/ssh/SSHProtocol.h b/src/protocols/ssh/SSHProtocol.h
index ef3e76fc..a0273b21 100644
--- a/src/protocols/ssh/SSHProtocol.h
+++ b/src/protocols/ssh/SSHProtocol.h
@@ -94,10 +94,10 @@ public:
 	void releaseFlowInfo(Flow *flow) override;
 
 #if defined(PYTHON_BINDING)
-        boost::python::dict getCache() const override;
-        void showCache(std::basic_ostream<char> &out) const override;
+        boost::python::dict getCacheData(const std::string &name) const override;
+	SharedPointer<Cache<StringCache>> getCache(const std::string &name) override;
 #elif defined(RUBY_BINDING)
-        VALUE getCache() const;
+        VALUE getCacheData(const std::string &name) const;
 #endif
 
 #if defined(STAND_ALONE_TEST) || defined(TESTING)
diff --git a/src/protocols/ssh/test_ssh.cc b/src/protocols/ssh/test_ssh.cc
index 00ff4d04..a804f80c 100644
--- a/src/protocols/ssh/test_ssh.cc
+++ b/src/protocols/ssh/test_ssh.cc
@@ -295,7 +295,7 @@ BOOST_AUTO_TEST_CASE (test08)
 	{
 		RedirectOutput r;
 
-        	flow->showFlowInfo(r.cout);
+        	flow->show(r.cout);
         	r.cout << *(info.get());
 		ssh->statistics(r.cout, 5);
      	} 
@@ -456,7 +456,7 @@ BOOST_AUTO_TEST_CASE (test01)
 	{
 		RedirectOutput r;
 
-        	flow->showFlowInfo(r.cout);
+        	flow->show(r.cout);
         	r.cout << *(info.get());
         	ssh->statistics(r.cout, 5);
 	}
diff --git a/src/protocols/ssl/Makefile.am b/src/protocols/ssl/Makefile.am
index 5e7de3c5..3040f96c 100644
--- a/src/protocols/ssl/Makefile.am
+++ b/src/protocols/ssl/Makefile.am
@@ -75,7 +75,7 @@ test_ssl_SOURCES = 	../../Multiplexer.cc \
 
 test_ssl_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST 
 test_ssl_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_ssl_LDADD   = $(BOOST_LDFLAGS) $(JA3_FLAGS) -lboost_system -lpthread -lboost_log -lboost_thread -lboost_unit_test_framework
+test_ssl_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) $(JA3_FLAGS) -lboost_system -lpthread -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/ssl/SSLInfo.cc b/src/protocols/ssl/SSLInfo.cc
index cf48575e..ca1ea389 100644
--- a/src/protocols/ssl/SSLInfo.cc
+++ b/src/protocols/ssl/SSLInfo.cc
@@ -50,7 +50,7 @@ std::ostream& operator<< (std::ostream &out, const SSLInfo &info) {
 	out << " Ver:0x" << std::hex << info.version_ << std::dec;
 	
 	if (info.isBanned()) 
-		out << "Banned";
+		out << " Banned";
 
 	if (info.host_name) 
 		out << " Host:" << info.host_name->getName();
diff --git a/src/protocols/ssl/SSLProtocol.cc b/src/protocols/ssl/SSLProtocol.cc
index 8e6643a0..7fcadd37 100644
--- a/src/protocols/ssl/SSLProtocol.cc
+++ b/src/protocols/ssl/SSLProtocol.cc
@@ -835,18 +835,39 @@ CounterMap SSLProtocol::getCounters() const {
 
 #if defined(PYTHON_BINDING) || defined(RUBY_BINDING) 
 #if defined(PYTHON_BINDING)
-boost::python::dict SSLProtocol::getCache() const {
+boost::python::dict SSLProtocol::getCacheData(const std::string &name) const {
 #elif defined(RUBY_BINDING)
-VALUE SSLProtocol::getCache() const {
+VALUE SSLProtocol::getCacheData(const std::string &name) const {
 #endif
-        return addMapToHash(host_map_);
+        if (boost::iequals(name, "host"))
+		return addMapToHash(host_map_);
+        else if (boost::iequals(name, "issuer"))
+		return addMapToHash(issuer_map_);
+        else if (boost::iequals(name, "session"))
+		return addMapToHash(session_map_);
+#if defined(HAVE_JA3)
+        else if (boost::iequals(name, "ja3"))
+		return addMapToHash(ja3_map_);
+#endif
+        return addMapToHash({});
 }
 
 #if defined(PYTHON_BINDING)
-void SSLProtocol::showCache(std::basic_ostream<char> &out) const {
-
-	showCacheMap(out, "", host_map_, "SSL Hosts", "Host");
+SharedPointer<Cache<StringCache>> SSLProtocol::getCache(const std::string &name) {
+
+        if (boost::iequals(name, "host"))
+                return host_cache_;
+        else if (boost::iequals(name, "issuer"))
+                return issuer_cache_;
+        else if (boost::iequals(name, "session"))
+                return session_cache_;
+#if defined(HAVE_JA3)
+        else if (boost::iequals(name, "ja3"))
+                return ja3_cache_;
+#endif
+        return nullptr;
 }
+
 #endif
 
 #endif
diff --git a/src/protocols/ssl/SSLProtocol.h b/src/protocols/ssl/SSLProtocol.h
index 427cb0ce..aa612e2b 100644
--- a/src/protocols/ssl/SSLProtocol.h
+++ b/src/protocols/ssl/SSLProtocol.h
@@ -166,10 +166,10 @@ public:
 	CounterMap getCounters() const override;
 
 #if defined(PYTHON_BINDING)
-	boost::python::dict getCache() const override;
-	void showCache(std::basic_ostream<char> &out) const override; 
+	boost::python::dict getCacheData(const std::string &name) const override;
+	SharedPointer<Cache<StringCache>> getCache(const std::string &name) override;
 #elif defined(RUBY_BINDING)
-        VALUE getCache() const;
+        VALUE getCacheData(const std::string &name) const;
 #endif
 
 #if defined(STAND_ALONE_TEST) || defined(TESTING)
diff --git a/src/protocols/ssl/test_ssl.cc b/src/protocols/ssl/test_ssl.cc
index 512c082e..6bc90902 100644
--- a/src/protocols/ssl/test_ssl.cc
+++ b/src/protocols/ssl/test_ssl.cc
@@ -307,7 +307,7 @@ BOOST_AUTO_TEST_CASE (test08)
 	{
 		RedirectOutput r;
 
-        	flow->showFlowInfo(r.cout);
+        	flow->show(r.cout);
         	r.cout << *(info.get());
      	}
  
@@ -522,7 +522,7 @@ BOOST_AUTO_TEST_CASE (test14) // Corrupt hello length to verify anomaly
 	{
 		RedirectOutput r;
         
-        	flow->showFlowInfo(r.cout);
+        	flow->show(r.cout);
         	r.cout << *(info.get());
 	}
 }
@@ -994,7 +994,7 @@ BOOST_AUTO_TEST_CASE (test15) // Return the issuer from the cert from google
 	{
 		RedirectOutput r;
 
-        	flow->showFlowInfo(r.cout);
+        	flow->show(r.cout);
         	r.cout << *(info.get());
 	}
 }
diff --git a/src/protocols/tcp/Makefile.am b/src/protocols/tcp/Makefile.am
index 325f60df..d1f32227 100644
--- a/src/protocols/tcp/Makefile.am
+++ b/src/protocols/tcp/Makefile.am
@@ -47,7 +47,7 @@ test_tcp_SOURCES = 	../../Multiplexer.cc  \
 
 test_tcp_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../../  $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_tcp_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_tcp_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_system -lboost_unit_test_framework -lboost_thread -lboost_log
+test_tcp_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/tcp/TCPHeader.h b/src/protocols/tcp/TCPHeader.h
index 799921ed..bf2d41f7 100644
--- a/src/protocols/tcp/TCPHeader.h
+++ b/src/protocols/tcp/TCPHeader.h
@@ -113,27 +113,25 @@ public:
         uint16_t getDestinationPort() const { return ntohs(tcphdr_.th_dport); }
         uint32_t getSequence() const  { return ntohl(tcphdr_.th_seq); }
         uint32_t getAckSequence() const  { return ntohl(tcphdr_.th_ack); }
+	uint16_t getWindowSize() const { return ntohs(tcphdr_.th_win); }
 
 	void setSrcPort(uint16_t port) { tcphdr_.th_sport = htons(port); }
-	
 	void setSequenceNumber(uint32_t seq) { tcphdr_.th_seq = htonl(seq); }
 	void setAcknoledgementNumber(uint32_t ack) { tcphdr_.th_ack = htonl(ack); }
 	void setWindowSize(uint16_t window) { tcphdr_.th_win = htons(window); }
 	void setFlagRst(bool rst) { tcphdr_.th_flags = (rst) ? TH_RST : 0; }
-
 	void setChecksum(uint16_t check) { tcphdr_.th_sum = check; }
 #else
         uint32_t getSequence() const  { return ntohl(tcphdr_.seq); }
         uint32_t getAckSequence() const  { return ntohl(tcphdr_.ack_seq); }
         uint16_t getSourcePort() const { return ntohs(tcphdr_.source); }
         uint16_t getDestinationPort() const { return ntohs(tcphdr_.dest); }
+	uint16_t getWindowSize() const { return ntohs(tcphdr_.window); }
 	
 	void setSrcPort(uint16_t port) { tcphdr_.source = htons(port); }
 	void setFlagRst(bool rst) { tcphdr_.rst = (rst) ? 1 : 0; }
-	
 	void setSequenceNumber(uint32_t seq) { tcphdr_.seq = htonl(seq); }
 	void setAcknoledgementNumber(uint32_t ack) { tcphdr_.ack_seq = htonl(ack); }
-	
 	void setWindowSize(uint16_t window) { tcphdr_.window = htons(window); }
 	void setDoff(uint16_t doff) { tcphdr_.doff = doff; }
 	void setChecksum(uint16_t check) { tcphdr_.check = check; }
diff --git a/src/protocols/tcp/TCPInfo.cc b/src/protocols/tcp/TCPInfo.cc
index 467b0247..746c68a3 100644
--- a/src/protocols/tcp/TCPInfo.cc
+++ b/src/protocols/tcp/TCPInfo.cc
@@ -40,12 +40,15 @@ void TCPInfo::reset() {
 	server_reset_rate = 0;
 	application_response_time = 0;
 #endif	
+	upstream_window_size = 0;
+	downstream_window_size = 0;
 }
 
 std::ostream& operator<< (std::ostream &out, const TCPInfo &info) {
 
 	out << "Flg[S(" << info.syn << ")SA(" << info.syn_ack << ")A(" << info.ack;
-	out << ")F(" << info.fin << ")R(" << info.rst << ")P(" << info.push << ")Seq(" << info.seq_num[0] << "," << info.seq_num[1] << ")]";
+	out << ")F(" << info.fin << ")R(" << info.rst << ")P(" << info.push << ")Seq(" << info.seq_num[0] << "," << info.seq_num[1] << ")";
+	out << "WS(" << info.upstream_window_size << "," << info.downstream_window_size << ")]";
 #if defined(HAVE_TCP_QOS_METRICS)
 	out << "QoS[ST(" << info.connection_setup_time << ")RR(" << info.server_reset_rate << ")";
 	out << "RT(" << info.application_response_time << ")]";
diff --git a/src/protocols/tcp/TCPInfo.h b/src/protocols/tcp/TCPInfo.h
index c7844fcc..2084b8c5 100644
--- a/src/protocols/tcp/TCPInfo.h
+++ b/src/protocols/tcp/TCPInfo.h
@@ -54,6 +54,9 @@ public:
 	int16_t rst;
 	int16_t push;
 
+        uint16_t upstream_window_size;
+        uint16_t downstream_window_size;
+
 	bool handshake;
 #if defined(HAVE_TCP_QOS_METRICS)
 	// http://www.thevisiblenetwork.com/2015/04/12/5-key-tcp-metrics-for-performance-monitoring/
@@ -66,6 +69,16 @@ public:
 	// TCP Sequence numbers 0 for upstream and 1 for downstream FlowDirection
 	uint32_t seq_num[2];
 
+#if defined(BINDING)
+	int getTotalSyns() const { return syn; }
+	int getTotalSynAcks() const { return syn_ack; }
+	int getTotalAcks() const { return ack; }
+	int getTotalFins() const { return fin; }
+	int getTotalRsts() const { return rst; }
+	int getTotalPushs() const { return push; }
+
+	const char *getState() const { return ((tcp_states[state_curr]).state)->name; }
+#endif
         friend std::ostream& operator<< (std::ostream &out, const TCPInfo &info); 
 	friend nlohmann::json& operator<< (nlohmann::json& out, const TCPInfo& info);
 };
diff --git a/src/protocols/tcp/TCPProtocol.cc b/src/protocols/tcp/TCPProtocol.cc
index b72c7804..3e2112fd 100644
--- a/src/protocols/tcp/TCPProtocol.cc
+++ b/src/protocols/tcp/TCPProtocol.cc
@@ -177,14 +177,16 @@ SharedPointer<Flow> TCPProtocol::getFlow(const Packet &packet) {
                 	if (flow = flow_cache_->acquireFlow(); flow) {
 				flow->setId(h1);
 				flow->regex_mng = rm_; // Sets the default regex set
-				if (packet.haveTag() == true) {
+				if (packet.haveTag() == true)
 					flow->setTag(packet.getTag());
-				}
 
 				// The time of the flow must be insert on the FlowManager table
 				// in order to keep the index updated
 				flow->setArriveTime(packet_time_);
 				flow->setLastPacketTime(packet_time_);
+				
+				// The first packet is considered as upstream	
+				flow->upstream_ttl = packet.getTTL();
 
 				if (ipmux->address.getType() == IPPROTO_IP) {
 					flow->setFiveTuple(ipmux->address.getSourceAddress(),
@@ -215,10 +217,13 @@ SharedPointer<Flow> TCPProtocol::getFlow(const Packet &packet) {
                 } else {
 			/* In order to identificate the flow direction we use the port */
 			/* May be there is another way to do it, but this way consume low CPU */
-			if (getSourcePort() == flow->getSourcePort())
+			if (getSourcePort() == flow->getSourcePort()) {
 				flow->setFlowDirection(FlowDirection::FORWARD);
-			else
+				flow->upstream_ttl = packet.getTTL();
+			} else {
 				flow->setFlowDirection(FlowDirection::BACKWARD);
+				flow->downstream_ttl = packet.getTTL();
+			}
 		}
         }
         return flow;
@@ -247,10 +252,17 @@ bool TCPProtocol::processPacket(Packet &packet) {
 				flow->setPacketAnomaly(packet.getPacketAnomaly());
 
 			compute_tcp_state(tcp_info.get(), bytes);
+
+			if (flow->getFlowDirection() == FlowDirection::FORWARD)
+				tcp_info->upstream_window_size = getWindowSize();
+			else
+				tcp_info->downstream_window_size = getWindowSize();
+
 #ifdef DEBUG
                 	std::cout << __FILE__ << ":" << __func__ << ":flow(" << current_flow_ << ") pkts:" << flow->total_packets;
 			std::cout << " bytes:" << bytes << " " << *tcp_info.get() ;
-			std::cout << "ip.size:" << ipmux->getHeaderSize() << " tcp.size:" << getTcpHdrLength() << std::endl;
+			std::cout << "ip.size:" << ipmux->getHeaderSize() << " tcp.size:" << getTcpHdrLength();
+			std::cout << " ttl:" << packet.getTTL() << std::endl;
 #endif
 
                         if ((flow->total_packets == 1)and(ipset_mng_)) { // Just need to check once per flow
@@ -324,9 +336,8 @@ bool TCPProtocol::processPacket(Packet &packet) {
                         packet.setAccept(flow->isAccept());
 #endif
 			// Verify if the flow have been label for forensic analysis
-			if (flow->haveEvidence()) {
+			if (flow->haveEvidence())
                         	packet.setEvidence(flow->haveEvidence());
-                        }
 
 #if defined(HAVE_REJECT_FLOW)
 			// Check if the flow have been rejected by the external login in python/ruby
diff --git a/src/protocols/tcp/TCPProtocol.h b/src/protocols/tcp/TCPProtocol.h
index b5298ab9..dededda3 100644
--- a/src/protocols/tcp/TCPProtocol.h
+++ b/src/protocols/tcp/TCPProtocol.h
@@ -82,6 +82,7 @@ public:
     	bool isRst() const { return (header_->th_flags & TH_RST) == TH_RST; }
     	bool isPushSet() const { return (header_->th_flags & TH_PUSH) == TH_PUSH; }
     	uint16_t getTcpHdrLength() const { return header_->th_off * 4; }
+	uint16_t getWindowSize() const { return ntohs(header_->th_win); }
 #else
     	bool isSyn() const { return header_->syn == 1; }
     	bool isFin() const { return header_->fin == 1; }
@@ -93,6 +94,7 @@ public:
     	uint16_t getSourcePort() const { return ntohs(header_->source); }
     	uint16_t getDestinationPort() const { return ntohs(header_->dest); }
     	uint16_t getTcpHdrLength() const { return header_->doff * 4; }
+	uint16_t getWindowSize() const { return ntohs(header_->window); }
 #endif
     	uint8_t *getPayload() const { return (uint8_t*)header_ + getTcpHdrLength(); }
 
diff --git a/src/protocols/tcp/test_tcp.cc b/src/protocols/tcp/test_tcp.cc
index b65d8ab9..dbbf2638 100644
--- a/src/protocols/tcp/test_tcp.cc
+++ b/src/protocols/tcp/test_tcp.cc
@@ -52,6 +52,7 @@ BOOST_AUTO_TEST_CASE (test02)
         // Check the TCP integrity
         BOOST_CHECK(tcp->getSourcePort() == 53637);
         BOOST_CHECK(tcp->getDestinationPort() == 80);
+        BOOST_CHECK(tcp->getWindowSize() == 5840);
 	BOOST_CHECK(tcp->getTotalBytes() == 809);
 	BOOST_CHECK(tcp->getTotalPackets() == 1);
 	BOOST_CHECK(tcp->getTotalValidPackets() == 1);
@@ -69,6 +70,7 @@ BOOST_AUTO_TEST_CASE (test03)
         BOOST_CHECK(tcp->getSourcePort() == 44265);
         BOOST_CHECK(tcp->getDestinationPort() == 443);
         BOOST_CHECK(tcp->getTotalBytes() == 225);
+        BOOST_CHECK(tcp->getWindowSize() == 229);
 }
 
 // Test case for verify tcp flags
@@ -92,6 +94,8 @@ BOOST_AUTO_TEST_CASE (test04)
 	BOOST_CHECK(info->ack == 1);
 	BOOST_CHECK(info->push == 1);
 	BOOST_CHECK(tcp->getTotalEvents() == 0);
+	BOOST_CHECK(flow->upstream_ttl == 64);
+	BOOST_CHECK(flow->downstream_ttl == 0);
 }
 
 BOOST_AUTO_TEST_CASE (test05)
@@ -177,6 +181,8 @@ BOOST_AUTO_TEST_CASE (test07)
         BOOST_CHECK(info->syn_ack == 1);
         BOOST_CHECK(info->ack == 0);
         BOOST_CHECK(info->push == 0);
+        BOOST_CHECK(info->upstream_window_size == 14600);
+        BOOST_CHECK(info->downstream_window_size == 14480);
 }
 
 // Test case for verify tcp bad flags
diff --git a/src/protocols/tcpgeneric/Makefile.am b/src/protocols/tcpgeneric/Makefile.am
index 30d6ff39..15cf4c1b 100644
--- a/src/protocols/tcpgeneric/Makefile.am
+++ b/src/protocols/tcpgeneric/Makefile.am
@@ -38,7 +38,7 @@ test_tcpgeneric_SOURCES = 	../../Multiplexer.cc \
 
 test_tcpgeneric_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_tcpgeneric_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_tcpgeneric_LDADD   = $(BOOST_LDFLAGS) $(PCRE_LIB) -lboost_thread -lboost_log -lpthread -lboost_system -lboost_unit_test_framework 
+test_tcpgeneric_LDADD   = $(BOOST_LDFLAGS) $(PCRE_LIB) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework 
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/tcpgeneric/test_tcpgeneric.cc b/src/protocols/tcpgeneric/test_tcpgeneric.cc
index e65d67cb..8b66fc31 100644
--- a/src/protocols/tcpgeneric/test_tcpgeneric.cc
+++ b/src/protocols/tcpgeneric/test_tcpgeneric.cc
@@ -409,7 +409,7 @@ BOOST_AUTO_TEST_CASE (test10) // IPv6 with auth header
 	{
 		RedirectOutput r;
         
-        	flow->showFlowInfo(r.cout);
+        	flow->show(r.cout);
 	}
 
 	BOOST_CHECK( flow->regex.lock() == r);
diff --git a/src/protocols/udp/Makefile.am b/src/protocols/udp/Makefile.am
index b796f97e..a9121504 100644
--- a/src/protocols/udp/Makefile.am
+++ b/src/protocols/udp/Makefile.am
@@ -34,7 +34,7 @@ test_udp_SOURCES = 	../../Multiplexer.cc \
 
 test_udp_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_udp_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_udp_LDADD   = $(BOOST_LDFLAGS) -lpthread -lboost_system -lboost_unit_test_framework -lboost_thread -lboost_log
+test_udp_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/udp/UDPProtocol.cc b/src/protocols/udp/UDPProtocol.cc
index 185d71ce..7848c828 100644
--- a/src/protocols/udp/UDPProtocol.cc
+++ b/src/protocols/udp/UDPProtocol.cc
@@ -150,6 +150,9 @@ SharedPointer<Flow> UDPProtocol::getFlow(const Packet &packet) {
 				flow->setArriveTime(packet_time_);
 				flow->setLastPacketTime(packet_time_);
 
+                                // The first packet is considered as upstream
+                                flow->upstream_ttl = packet.getTTL();
+
 				if (ipmux->address.getType() == IPPROTO_IP) {
 					flow->setFiveTuple(ipmux->address.getSourceAddress(),
 						getSourcePort(),
@@ -172,10 +175,13 @@ SharedPointer<Flow> UDPProtocol::getFlow(const Packet &packet) {
                 } else {
                         /* In order to identificate the flow direction we use the port */
                         /* May be there is another way to do it, but this way consume low CPU */
-                        if (getSourcePort() == flow->getSourcePort())
+                        if (getSourcePort() == flow->getSourcePort()) {
                                 flow->setFlowDirection(FlowDirection::FORWARD);
-                        else
+                                flow->upstream_ttl = packet.getTTL();
+                        } else {
                                 flow->setFlowDirection(FlowDirection::BACKWARD);
+                                flow->downstream_ttl = packet.getTTL();
+                        }
                 }
 	}
 	return flow; 
diff --git a/src/protocols/udp/test_udp.cc b/src/protocols/udp/test_udp.cc
index 9955805d..e410879b 100644
--- a/src/protocols/udp/test_udp.cc
+++ b/src/protocols/udp/test_udp.cc
@@ -182,11 +182,17 @@ BOOST_AUTO_TEST_CASE(test07) // Test small packet udp , one byte packet
 	BOOST_CHECK(ip->getTotalBytes() == 29);
 	BOOST_CHECK(ip->getTotalValidPackets() == 1);
 	BOOST_CHECK(ip->getTotalInvalidPackets() == 0);
+	BOOST_CHECK(ip->getTTL() == 236);
 
 	BOOST_CHECK(udp->getTotalPackets() == 1);
 	BOOST_CHECK(udp->getTotalBytes() == 9);
 	BOOST_CHECK(udp->getTotalValidPackets() == 1);
 	BOOST_CHECK(udp->getTotalInvalidPackets() == 0);
+
+	Flow *flow = udp->getCurrentFlow();
+	BOOST_CHECK(flow != nullptr);
+	BOOST_CHECK(flow->upstream_ttl == 236);
+	BOOST_CHECK(flow->downstream_ttl == 0);
 }
 
 BOOST_AUTO_TEST_CASE(test08) // Test timeout on UDP traffic with no release flows 
diff --git a/src/protocols/udpgeneric/Makefile.am b/src/protocols/udpgeneric/Makefile.am
index 4ecd5762..8458e228 100644
--- a/src/protocols/udpgeneric/Makefile.am
+++ b/src/protocols/udpgeneric/Makefile.am
@@ -35,7 +35,7 @@ test_udpgeneric_SOURCES = 	../../Multiplexer.cc \
 
 test_udpgeneric_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_udpgeneric_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_udpgeneric_LDADD   = $(BOOST_LDFLAGS) $(PCRE_LIB) -lboost_log -lboost_thread -lpthread -lboost_system -lboost_unit_test_framework 
+test_udpgeneric_LDADD   = $(BOOST_LDFLAGS) $(PCRE_LIB) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework 
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/vlan/Makefile.am b/src/protocols/vlan/Makefile.am
index c3261804..e46b10d4 100644
--- a/src/protocols/vlan/Makefile.am
+++ b/src/protocols/vlan/Makefile.am
@@ -24,7 +24,7 @@ test_vlan_SOURCES = 	../../Multiplexer.cc \
 
 test_vlan_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_vlan_LDFLAGS = $(EXTRA_TEST_LDFLAGS)
-test_vlan_LDADD   = $(BOOST_LDFLAGS) -lboost_system -lboost_log -lboost_thread -lpthread -lboost_unit_test_framework
+test_vlan_LDADD   = $(BOOST_LDFLAGS) $(LOGGING_FLAGS) -lboost_system -lpthread -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/protocols/vxlan/Makefile.am b/src/protocols/vxlan/Makefile.am
index 74e71967..693dd69c 100644
--- a/src/protocols/vxlan/Makefile.am
+++ b/src/protocols/vxlan/Makefile.am
@@ -48,7 +48,7 @@ test_vxlan_SOURCES = 	../../Multiplexer.cc \
 
 test_vxlan_CPPFLAGS = $(EXTRA_TEST_CPPFLAGS) -I../.. -g $(BOOST_CPPFLAGS) -DSTAND_ALONE_TEST
 test_vxlan_LDFLAGS = $(EXTRA_TEST_LDFLAGS) 
-test_vxlan_LDADD   = $(BOOST_LDFLAGS) $(PCRE_LIB) -lpthread -lboost_system -lboost_log -lboost_thread -lboost_unit_test_framework
+test_vxlan_LDADD   = $(BOOST_LDFLAGS) $(PCRE_LIB) $(LOGGING_FLAGS) -lpthread -lboost_system -lboost_unit_test_framework
 
 CLEANFILES = *.o *.lo *.so
 
diff --git a/src/python_help.h b/src/python_help.h
index 45b01230..60c8cfdf 100644
--- a/src/python_help.h
+++ b/src/python_help.h
@@ -50,12 +50,12 @@ const char *help_set_udp_database_adaptor = 	"Sets a databaseAdattor for UDP tra
 const char *help_release_cache = 		"Release the cache of a specific protocol.";
 const char *help_releases_caches = 		"Release all the caches.";
 const char *help_get_counters = 		"Gets the counters of a specific protocol on a python dict.";
-const char *help_get_cache = 			"Gets the main cache of a protocol on a python dict.";
+const char *help_get_cache = 			"Gets the internal Cache objet by protocol nad name.";
+const char *help_stack_get_cache_data = 	"Gets the data of a cache and protocol on a dict object.";
 const char *help_anomaly_callback = 		"Sets a callback for specific anomalies on the given protocol.";
 const char *help_show_statistics_proto =	"Shows the statistics of a given protocol.";
 const char *help_show_statistics =		"Shows the statistics of the stack.";
 const char *help_show_flows = 			"Shows the active flows on memory.";
-const char *help_show_cache = 			"Shows the main cache of the protocol selected.";
 	
 const char *help_regex_expression = 		"Gets the regular expression.";
 const char *help_regex_name = 			"Gets the name of the regular expression.";
@@ -79,7 +79,8 @@ const char *help_pdis_open =			"Opens a network device or a pcap file for analys
 const char *help_pdis_close =			"Closes a network device or a pcap file.";
 const char *help_pdis_run =			"Start to process packets.";
 const char *help_pdis_forward_packet =		"Forwards the received packet to a external packet engine(Netfilter).";
-const char *help_set_scheduler =		"Sets a timer for manage periodically tasks (DDoS checks, abuse, etc...).";
+const char *help_pdis_add_timer =		"Sets a timer for manage periodically tasks (DDoS checks, abuse, etc...).";
+const char *help_pdis_remove_timer =		"Removes a timer.";
 const char *help_pdis_is_packet_accepted =	"Returns if the packet should be accepted or not (for integration with Netfilter).";
 const char *help_pdis_show_packet =		"Shows the current packet that is been processed.";
 const char *help_pdis_show =			"Shows the current statistics.";
@@ -148,6 +149,9 @@ const char *help_flow_payload = 		"Gets a list of the bytes of the payload of th
 const char *help_flow_anomaly =			"Gets the attached anomaly of the Flow."; 		 	
 const char *help_flow_l7_protocol_name =	"Gets the name of the Protocol of L7 of the Flow.";
 const char *help_flow_quic_info = 		"Gets the QuicInfo object if the Flow is Google Quic.";
+const char *help_flow_upstream_ttl = 		"Returns the IP.TTL last packet of upstream.";
+const char *help_flow_downstream_ttl = 		"Returns the IP.TTL last packet of downstream.";
+const char *help_flow_tcp_info = 		"Gets a TCPInfo object if the Flow is TCP.";
 
 const char *help_quic_host_name =		"Gets the server name from the QuicInfo object.";
 const char *help_quic_user_agent = 		"Gets the User Agent from the QuicInfo object.";
@@ -221,6 +225,14 @@ const char *help_imap_info_user_name =		"Gets the user name of the IMAP session
 const char *help_ssdp_info_uri = 		"Gets the SSDP URI if the Flow is SSDP."; 
 const char *help_ssdp_info_host_name = 		"Gets the SSDP Host if the Flow is SSDP.";
 
+const char *help_tcp_info_syns = 		"Return the total number of TCP syn packets of the Flow.";
+const char *help_tcp_info_synacks = 		"Return the total number of TCP syn/ack packets of the Flow.";
+const char *help_tcp_info_acks = 		"Return the total number of TCP ack packets of the Flow.";
+const char *help_tcp_info_rsts = 		"Return the total number of TCP rst packets of the Flow.";
+const char *help_tcp_info_fins = 		"Return the total number of TCP fin packets of the Flow.";
+const char *help_tcp_info_pushs = 		"Return the total number of TCP push packets of the Flow.";
+const char *help_tcp_info_state = 		"Return the state of the TCP Flow.";
+
 const char *help_frequencies_dispersion =	"Returns the dispersion value of the Flow."; 
 const char *help_frequencies_enthropy =		"Returns the enthopy value of the Flow.";  
 const char *help_frequencies_get_freq_string =	""; 
@@ -312,4 +324,13 @@ const char *help_learn_agregate_flows = 	"Adds a list of Flows to be process.";
 const char *help_learn_compute = 		"Runs the engine."; 
 const char *help_learn_reset = 			"Reset the engine."; 
 
+const char *help_cache_total_items = 		"Returns the total number of items on the Cache object.";
+const char *help_cache_total_acquires =		"Returns the total of number of acquires on the Cache.";
+const char *help_cache_total_releases = 	"Returns the total number of releases objects on the Cache.";
+const char *help_cache_total_fails =		"Returns the total number of fails on the Cache.";
+const char *help_cache_dynamic_memory = 	"Gets/Sets if the memory is allocated dynamic or not.";
+const char *help_cache_show = 			"Shows the Cache object.";
+const char *help_cache_create = 		"Allocate items inside the Cache.";
+const char *help_cache_destroy = 		"Free items inside the Cache.";
+
 #endif  // SRC_PYTHON_HELP_H_
diff --git a/src/python_wrapper.cc b/src/python_wrapper.cc
index 325774ab..c4484c1a 100644
--- a/src/python_wrapper.cc
+++ b/src/python_wrapper.cc
@@ -34,6 +34,8 @@
 #include "StackMobileIPv6.h"
 #include "PacketDispatcher.h"
 #include "NetworkStack.h"
+#include "StringCache.h"
+#include "Cache.h"
 #include "protocols/frequency/FrequencyGroup.h"
 #include "regex/Regex.h"
 #include "learner/LearnerEngine.h"
@@ -57,9 +59,9 @@ using namespace aiengine;
 struct DatabaseAdaptorWrap: DatabaseAdaptor, wrapper<DatabaseAdaptor>
 {
         void connect(std::string &connection_str) { this->get_override("connection")(connection_str); }
-        void insert(std::string &key) { this->get_override("insert")(key); }
-        void update(std::string &key, std::string& data) { this->get_override("update")(key, data); }
-        void remove(std::string &key) { this->get_override("remove")(key); }
+        void insert(const std::string &key) { this->get_override("insert")(key); }
+        void update(const std::string &key, const std::string& data) { this->get_override("update")(key, data); }
+        void remove(const std::string &key) { this->get_override("remove")(key); }
 };
 
 BOOST_PYTHON_MODULE(pyaiengine)
@@ -94,7 +96,8 @@ BOOST_PYTHON_MODULE(pyaiengine)
 	void (NetworkStack::*increaseAllocatedMemory)(const std::string&, int) =	&NetworkStack::increaseAllocatedMemory;
 	void (NetworkStack::*decreaseAllocatedMemory)(const std::string&, int) =	&NetworkStack::decreaseAllocatedMemory;
 	boost::python::dict (NetworkStack::*getCounters)(const std::string&) =		&NetworkStack::getCounters;
-	boost::python::dict (NetworkStack::*getCache)(const std::string&) =		&NetworkStack::getCache;
+	boost::python::dict (NetworkStack::*getCacheData)(const std::string&, const std::string&) =		&NetworkStack::getCacheData;
+	SharedPointer<Cache<StringCache>> (NetworkStack::*getCacheByName)(const std::string&, const std::string&) =		&NetworkStack::getCache;
         void (NetworkStack::*setAnomalyCallback)(PyObject*, const std::string&) =	&NetworkStack::setAnomalyCallback;
 	void (NetworkStack::*showProtocolSummaryReport)() const =			&NetworkStack::showProtocolSummary;
 	void (NetworkStack::*setDynamicAllocatedMemoryOne)(bool) =			&NetworkStack::setDynamicAllocatedMemory;
@@ -107,10 +110,10 @@ BOOST_PYTHON_MODULE(pyaiengine)
         boost::python::class_<NetworkStack, boost::noncopyable>("NetworkStack", no_init)
                 .def("set_domain_name_manager", pure_virtual(setDomainNameManager1))
                 .def("set_domain_name_manager", pure_virtual(setDomainNameManager2))
-		.def("show_statistics", statisticsByProtocol1)
-		.def("show_statistics", statisticsByProtocol2)
-		.def("show_statistics", statisticsByProtocol3)
-		.def("show_statistics", statistics)
+		.def("show", statisticsByProtocol1)
+		.def("show", statisticsByProtocol2)
+		.def("show", statisticsByProtocol3)
+		.def("show", statistics)
 		.def("increase_allocated_memory", pure_virtual(increaseAllocatedMemory))
 		.def("decrease_allocated_memory", pure_virtual(decreaseAllocatedMemory))
 		.def("set_tcp_database_adaptor", pure_virtual(setTCPDatabaseAdaptor1))
@@ -120,7 +123,8 @@ BOOST_PYTHON_MODULE(pyaiengine)
                 .def("release_cache", pure_virtual(releaseCache))
                 .def("release_caches", pure_virtual(releaseCaches))
                 .def("get_counters", pure_virtual(getCounters))
-                .def("get_cache", pure_virtual(getCache))
+                .def("get_cache_data", pure_virtual(getCacheData))
+                .def("get_cache", pure_virtual(getCacheByName))
                 .def("set_anomaly_callback", pure_virtual(setAnomalyCallback))
 		.def("show_protocol_statistics", showProtocolSummaryReport)
 		.def("set_dynamic_allocated_memory", setDynamicAllocatedMemoryOne)
@@ -136,8 +140,6 @@ BOOST_PYTHON_MODULE(pyaiengine)
 			help_show_flows)
 		.def("show_flows", showNetFlowsLimit2,
 			help_show_flows)
-		.def("show_cache", &NetworkStack::showCache,
-			help_show_cache)
 	;
 
 	// Definitions for the StackLan class
@@ -152,7 +154,8 @@ BOOST_PYTHON_MODULE(pyaiengine)
 	void (StackLan::*releaseCacheLan)(const std::string&) =				&StackLan::releaseCache;
 	void (StackLan::*releaseCachesLan)() =						&StackLan::releaseCaches;
 	boost::python::dict (StackLan::*getCountersLan)(const std::string&) =		&StackLan::getCounters;
-	boost::python::dict (StackLan::*getCacheLan)(const std::string&) =		&StackLan::getCache;
+	boost::python::dict (StackLan::*getCacheDataLan)(const std::string&, const std::string&) =		&StackLan::getCacheData;
+	SharedPointer<Cache<StringCache>> (StackLan::*getCacheByNameLan)(const std::string&, const std::string&) =		&StackLan::getCache;
         void (StackLan::*setAnomalyCallbackLan)(PyObject*, const std::string&) =	&StackLan::setAnomalyCallback;
 
 	boost::python::class_<StackLan, bases<NetworkStack> >("StackLan",
@@ -207,7 +210,9 @@ BOOST_PYTHON_MODULE(pyaiengine)
 			help_releases_caches)
 		.def("get_counters", getCountersLan, 
 			help_get_counters)
-		.def("get_cache", getCacheLan, 
+		.def("get_cache_data", getCacheDataLan, 
+			help_stack_get_cache_data)
+		.def("get_cache", getCacheByNameLan, 
 			help_get_cache)
                 .def("set_anomaly_callback", setAnomalyCallbackLan,
 			help_anomaly_callback)
@@ -225,7 +230,8 @@ BOOST_PYTHON_MODULE(pyaiengine)
 	void (StackMobile::*releaseCacheMobile)(const std::string&) =				&StackMobile::releaseCache;
 	void (StackMobile::*releaseCachesMobile)() =						&StackMobile::releaseCaches;
 	boost::python::dict (StackMobile::*getCountersMobile)(const std::string&) =		&StackMobile::getCounters;
-	boost::python::dict (StackMobile::*getCacheMobile)(const std::string&) =		&StackMobile::getCache;
+	boost::python::dict (StackMobile::*getCacheDataMobile)(const std::string&, const std::string&) =		&StackMobile::getCacheData;
+	SharedPointer<Cache<StringCache>> (StackMobile::*getCacheByNameMobile)(const std::string&, const std::string&) =		&StackMobile::getCache;
         void (StackMobile::*setAnomalyCallbackMobile)(PyObject*, const std::string&) =		&StackMobile::setAnomalyCallback;
 
         boost::python::class_<StackMobile, bases<NetworkStack> >("StackMobile",
@@ -280,7 +286,9 @@ BOOST_PYTHON_MODULE(pyaiengine)
 			help_releases_caches)
 		.def("get_counters", getCountersMobile,
 			help_get_counters)
-		.def("get_cache", getCacheMobile,
+		.def("get_cache_data", getCacheDataMobile,
+			help_stack_get_cache_data)
+		.def("get_cache", getCacheByNameMobile,
 			help_get_cache)
                 .def("set_anomaly_callback", setAnomalyCallbackMobile,
 			help_anomaly_callback)
@@ -298,7 +306,8 @@ BOOST_PYTHON_MODULE(pyaiengine)
 	void (StackLanIPv6::*releaseCacheLanIPv6)(const std::string&) =				&StackLanIPv6::releaseCache;
 	void (StackLanIPv6::*releaseCachesLanIPv6)() =						&StackLanIPv6::releaseCaches;
 	boost::python::dict (StackLanIPv6::*getCountersLanIPv6)(const std::string&) =		&StackLanIPv6::getCounters;
-	boost::python::dict (StackLanIPv6::*getCacheLanIPv6)(const std::string&) =		&StackLanIPv6::getCache;
+	boost::python::dict (StackLanIPv6::*getCacheDataLanIPv6)(const std::string&, const std::string&) =		&StackLanIPv6::getCacheData;
+	SharedPointer<Cache<StringCache>> (StackLanIPv6::*getCacheByNameLanIPv6)(const std::string&, const std::string&) =		&StackLanIPv6::getCache;
         void (StackLanIPv6::*setAnomalyCallbackLanIPv6)(PyObject*, const std::string&) =	&StackLanIPv6::setAnomalyCallback;
 
         boost::python::class_<StackLanIPv6, bases<NetworkStack> >("StackLanIPv6",
@@ -353,7 +362,9 @@ BOOST_PYTHON_MODULE(pyaiengine)
 			help_releases_caches)
 		.def("get_counters", getCountersLanIPv6,
 			help_get_counters)
-		.def("get_cache", getCacheLanIPv6,
+		.def("get_cache_data", getCacheDataLanIPv6,
+			help_stack_get_cache_data)
+		.def("get_cache", getCacheByNameLanIPv6,
 			help_get_cache)
                 .def("set_anomaly_callback", setAnomalyCallbackLanIPv6,
 			help_anomaly_callback)
@@ -371,7 +382,8 @@ BOOST_PYTHON_MODULE(pyaiengine)
 	void (StackVirtual::*releaseCacheVirtual)(const std::string&) =				&StackVirtual::releaseCache;
 	void (StackVirtual::*releaseCachesVirtual)() =						&StackVirtual::releaseCaches;
 	boost::python::dict (StackVirtual::*getCountersVirtual)(const std::string&) =		&StackVirtual::getCounters;
-	boost::python::dict (StackVirtual::*getCacheVirtual)(const std::string&) =		&StackVirtual::getCache;
+	boost::python::dict (StackVirtual::*getCacheDataVirtual)(const std::string&, const std::string&) =		&StackVirtual::getCacheData;
+	SharedPointer<Cache<StringCache>> (StackVirtual::*getCacheByNameVirtual)(const std::string&, const std::string&) =		&StackVirtual::getCache;
         void (StackVirtual::*setAnomalyCallbackVirtual)(PyObject*, const std::string&) =	&StackVirtual::setAnomalyCallback;
 
         boost::python::class_<StackVirtual, bases<NetworkStack> >("StackVirtual",
@@ -426,7 +438,9 @@ BOOST_PYTHON_MODULE(pyaiengine)
 			help_releases_caches)
 		.def("get_counters", getCountersVirtual,
 			help_get_counters)
-		.def("get_cache", getCacheVirtual,
+		.def("get_cache_data", getCacheDataVirtual,
+			help_stack_get_cache_data)
+		.def("get_cache", getCacheByNameVirtual,
 			help_get_cache)
                 .def("set_anomaly_callback", setAnomalyCallbackVirtual,
 			help_anomaly_callback)
@@ -444,7 +458,8 @@ BOOST_PYTHON_MODULE(pyaiengine)
         void (StackOpenFlow::*releaseCacheOpenFlow)(const std::string&) =                  	&StackOpenFlow::releaseCache;
         void (StackOpenFlow::*releaseCachesOpenFlow)() =                          		&StackOpenFlow::releaseCaches;
 	boost::python::dict (StackOpenFlow::*getCountersOpenFlow)(const std::string&) =		&StackOpenFlow::getCounters;
-	boost::python::dict (StackOpenFlow::*getCacheOpenFlow)(const std::string&) =		&StackOpenFlow::getCache;
+	boost::python::dict (StackOpenFlow::*getCacheDataOpenFlow)(const std::string&, const std::string&) =		&StackOpenFlow::getCacheData;
+	SharedPointer<Cache<StringCache>> (StackOpenFlow::*getCacheByNameOF)(const std::string&, const std::string&) =		&StackOpenFlow::getCache;
         void (StackOpenFlow::*setAnomalyCallbackOpenFlow)(PyObject*, const std::string&) =	&StackOpenFlow::setAnomalyCallback;
 
         boost::python::class_<StackOpenFlow, bases<NetworkStack> >("StackOpenFlow",
@@ -499,7 +514,9 @@ BOOST_PYTHON_MODULE(pyaiengine)
 			help_releases_caches)
                 .def("get_counters", getCountersOpenFlow,
 			help_get_counters)
-                .def("get_cache", getCacheOpenFlow,
+                .def("get_cache_data", getCacheDataOpenFlow,
+			help_stack_get_cache_data)
+                .def("get_cache", getCacheByNameOF,
 			help_get_cache)
                 .def("set_anomaly_callback", setAnomalyCallbackOpenFlow,
 			help_anomaly_callback)
@@ -517,7 +534,8 @@ BOOST_PYTHON_MODULE(pyaiengine)
         void (StackMobileIPv6::*releaseCacheMobile6)(const std::string&) =                          &StackMobileIPv6::releaseCache;
         void (StackMobileIPv6::*releaseCachesMobile6)() =                                           &StackMobileIPv6::releaseCaches;
         boost::python::dict (StackMobileIPv6::*getCountersMobile6)(const std::string&) =            &StackMobileIPv6::getCounters;
-        boost::python::dict (StackMobileIPv6::*getCacheMobile6)(const std::string&) =               &StackMobileIPv6::getCache;
+        boost::python::dict (StackMobileIPv6::*getCacheDataMobile6)(const std::string&, const std::string&) =               &StackMobileIPv6::getCacheData;
+	SharedPointer<Cache<StringCache>> (StackMobileIPv6::*getCacheByNameMobile6)(const std::string&, const std::string&) =		&StackMobileIPv6::getCache;
         void (StackMobileIPv6::*setAnomalyCallbackMobile6)(PyObject*, const std::string&) =         &StackMobileIPv6::setAnomalyCallback;
 
         boost::python::class_<StackMobileIPv6, bases<NetworkStack> >("StackMobileIPv6",
@@ -572,13 +590,17 @@ BOOST_PYTHON_MODULE(pyaiengine)
                         help_releases_caches)
                 .def("get_counters", getCountersMobile6,
                         help_get_counters)
-                .def("get_cache", getCacheMobile6,
+                .def("get_cache_data", getCacheDataMobile6,
+                        help_stack_get_cache_data)
+                .def("get_cache", getCacheByNameMobile6,
                         help_get_cache)
                 .def("set_anomaly_callback", setAnomalyCallbackMobile6,
                         help_anomaly_callback)
         ;
 	
-	boost::python::class_<Regex, SharedPointer<Regex>, boost::noncopyable>("Regex", init<const std::string&, const std::string&>())
+	boost::python::class_<Regex, SharedPointer<Regex>, boost::noncopyable>("Regex",
+                "This class contains the functionality for manage regular expressions as well as how to connect the object with others.",
+		init<const std::string&, const std::string&>())
 		.def(init<const std::string&, const std::string&, boost::python::object>())
 		.def(init<const std::string&, const std::string&, boost::python::object, const SharedPointer<Regex>&>())
 		.add_property("expression", &Regex::getExpression,
@@ -640,7 +662,9 @@ BOOST_PYTHON_MODULE(pyaiengine)
 		.def("forward_packet", &PacketDispatcher::forwardPacket,
 			help_pdis_forward_packet)
 		.def("add_timer", &PacketDispatcher::addTimer,
-			help_set_scheduler)
+			help_pdis_add_timer)
+		.def("remove_timer", &PacketDispatcher::removeTimer,
+			help_pdis_remove_timer)
 		.def("show_current_packet", showCurrentPayloadPacketPdis,
 			help_pdis_show_packet)
 		.def("show", showPdisStatistics,
@@ -658,7 +682,8 @@ BOOST_PYTHON_MODULE(pyaiengine)
         void (RegexManager::*showRegexByName)(const std::string&) const	= &RegexManager::statistics;
         void (RegexManager::*showMatchedRegexs)() const			= &RegexManager::showMatchedRegexs;
 
-	boost::python::class_<RegexManager, SharedPointer<RegexManager>, boost::noncopyable >("RegexManager")
+	boost::python::class_<RegexManager, SharedPointer<RegexManager>, boost::noncopyable >("RegexManager",
+		"This class contains Regex objects and how are they manage.")
 		.def(init<>())
 		.def(init<const std::string&>())
 		.def(init<boost::python::list&>())
@@ -751,8 +776,14 @@ BOOST_PYTHON_MODULE(pyaiengine)
 			help_flow_label)
 		.add_property("duration", &Flow::getDuration,
 			help_flow_duration)
+		.add_property("upstream_ttl", &Flow::getUpstreamTTL,
+			help_flow_upstream_ttl)
+		.add_property("downstream_ttl", &Flow::getDownstreamTTL,
+			help_flow_downstream_ttl)
 		.add_property("ip_set", make_function(&Flow::getIPSetInfo, return_internal_reference<>()),
 			help_flow_ip_set)
+		.add_property("tcp_info", make_function(&Flow::getTCPInfoObject, return_internal_reference<>()),
+			help_flow_tcp_info)
 		.add_property("http_info", make_function(&Flow::getHTTPInfoObject, return_internal_reference<>()),
 			help_flow_http_info)
 		.add_property("sip_info", make_function(&Flow::getSIPInfoObject, return_internal_reference<>()),
@@ -992,6 +1023,24 @@ BOOST_PYTHON_MODULE(pyaiengine)
                 .def(self_ns::str(self_ns::self))
         ;
 
+        boost::python::class_<TCPInfo, SharedPointer<TCPInfo>, boost::noncopyable>("TCPInfo")
+                .add_property("syns", &TCPInfo::getTotalSyns,
+                        help_tcp_info_syns)
+                .add_property("synacks", &TCPInfo::getTotalSynAcks,
+                        help_tcp_info_synacks)
+                .add_property("acks", &TCPInfo::getTotalAcks,
+                        help_tcp_info_acks)
+                .add_property("fins", &TCPInfo::getTotalFins,
+                        help_tcp_info_fins)
+                .add_property("rsts", &TCPInfo::getTotalRsts,
+                        help_tcp_info_rsts)
+                .add_property("pushs", &TCPInfo::getTotalPushs,
+                        help_tcp_info_pushs)
+                .add_property("state", &TCPInfo::getState,
+                        help_tcp_info_state)
+                .def(self_ns::str(self_ns::self))
+        ;
+
 	boost::python::class_<Frequencies, SharedPointer<Frequencies>, boost::noncopyable>("Frequencies")
 		.add_property("dispersion", &Frequencies::getDispersion,
 			help_frequencies_dispersion)
@@ -1227,5 +1276,26 @@ BOOST_PYTHON_MODULE(pyaiengine)
                 .def(self_ns::str(self_ns::self))
         ;
 
+	void (Cache<StringCache>::*show)() const = 		&Cache<StringCache>::statistics;
+
+	boost::python::class_<Cache<StringCache>, SharedPointer<Cache<StringCache>>>("Cache",
+                "This class manages the internal allocated memory of different object types manage by a protocol.")
+                .add_property("total_items", &Cache<StringCache>::getTotal,
+			help_cache_total_items)
+                .add_property("total_acquires", &Cache<StringCache>::getTotalAcquires,
+			help_cache_total_acquires)
+                .add_property("total_releases", &Cache<StringCache>::getTotalReleases,
+			help_cache_total_releases)
+                .add_property("total_fails", &Cache<StringCache>::getTotalFails,
+			help_cache_total_fails)
+		.add_property("dynamic_allocated_memory", &Cache<StringCache>::isDynamicAllocatedMemory, &Cache<StringCache>::setDynamicAllocatedMemory,
+			help_cache_dynamic_memory)
+                .def("show", show,
+			help_cache_show)
+                .def("create", &Cache<StringCache>::create,
+			help_cache_create)
+                .def("destroy", &Cache<StringCache>::destroy,
+			help_cache_destroy)
+        ;
 }
 
diff --git a/src/regex/RegexManager.h b/src/regex/RegexManager.h
index 829e0201..532467bb 100644
--- a/src/regex/RegexManager.h
+++ b/src/regex/RegexManager.h
@@ -52,7 +52,7 @@ public:
 	void setPluggedToName(const std::string &name) { plugged_to_name_ = name; }
 	const char *getPluggedToName() const { return plugged_to_name_.c_str(); }
 
-	int32_t getTotalRegexs() { return regexs_.size(); }
+	int32_t getTotalRegexs() { return (int32_t)regexs_.size(); }
 	int32_t getTotalMatchingRegexs() { return total_matched_regexs_; }
 
 	void evaluate(const boost::string_ref &data, bool *result); 
diff --git a/src/setup.py b/src/setup.py
index 5f3992a8..4b78a8d9 100644
--- a/src/setup.py
+++ b/src/setup.py
@@ -203,20 +203,22 @@ def setup_compiler ():
         os.environ["CC"] = "eg++"
     elif (sys.platform == 'darwin'):
         macros.append(('__DARWIN__','1'))
-        os.environ["CC"] = "g++"
+        # os.environ["CC"] = "clang++"
+        # os.environ["CXX"] = "g++"
     else:
         os.environ["CC"] = "g++"
         os.environ["CXX"] = "g++"
 
     ccache = which("ccache")
-    if (ccache):
-        os.environ["CC"] = ccache + " " + os.environ["CC"]
+    if ccache:
+        if os.environ.get("CC"):
+            os.environ["CC"] = ccache + " " + os.environ["CC"]
 
     return includes,macros
 
 aiengine_module = Extension("pyaiengine",
     sources = src_files,
-    libraries = ["boost_system","pcap","pcre","boost_iostreams", "boost_log", "stdc++fs"],
+    libraries = ["boost_system","pcap","pcre","boost_iostreams"],
     define_macros = [],
     extra_compile_args = ["-O3","-Wreorder","-std=c++17", "-lpthread","-lstdc++"],
     )
@@ -260,12 +262,18 @@ if __name__ == "__main__":
             aiengine_module.include_dirs = includes
             aiengine_module.define_macros = macros
             aiengine_module.libraries.append(boost_python_lib)
+    
+            if (sys.platform != 'darwin'):
+                aiengine_module.libraries.append("stdc++fs")
+                aiengine_module.libraries.append("boost_log")
+            else:
+                aiengine_module.libraries.append("boost_log-mt")
 
     if (defined("HAVE_JA3") == True):
         aiengine_module.libraries.append("crypto")
 
     setup(name="aiengine",
-        version = "1.9.1",
+        version = "1.9.2",
         author = "Luis Campo Giralte",
         author_email = "luis.camp0.2009@gmail.com",
         url = "https://bitbucket.org/camp0/aiengine",
diff --git a/src/tests.cc b/src/tests.cc
index 1e28a558..d7ab5db5 100644
--- a/src/tests.cc
+++ b/src/tests.cc
@@ -853,9 +853,9 @@ BOOST_FIXTURE_TEST_CASE(test20, StackLanTest) // Tests for release the caches
 
 	releaseCaches();
 
-	for (auto &f: flow_table_tcp->getFlowTable()) {
+	for (auto &f: flow_table_tcp->getFlowTable())
 		BOOST_CHECK(f->getSSLInfo() == nullptr);
-	}
+
 	flow_table_tcp->flush();
 
 	tcp->decreaseAllocatedMemory(1000);
@@ -942,7 +942,7 @@ BOOST_FIXTURE_TEST_CASE(test22, StackLanTest) // Tests for release the caches on
 	{
 		RedirectOutput r;
 	
-		flow->showFlowInfo(r.cout);
+		flow->show(r.cout);
 		r.cout << *(info.get());
 		flow_table_tcp->showFlows(10);
 		flow_table_tcp->showFlows(-1);
@@ -1017,7 +1017,7 @@ BOOST_FIXTURE_TEST_CASE(test23, StackLanTest) // Tests for release the caches an
 #else
 	BOOST_CHECK (cnname.compare(j["host"]) == 0);
 #endif
-	flow->showFlowInfo(j);
+	flow->show(j);
 
         releaseCaches();
 
@@ -1054,9 +1054,9 @@ BOOST_FIXTURE_TEST_CASE(test23, StackLanTest) // Tests for release the caches an
         
 	releaseCaches();
 	
-	for (auto &ff: flow_table_tcp->getFlowTable()) {
+	for (auto &ff: flow_table_tcp->getFlowTable())
 		BOOST_CHECK(ff->getSSLInfo() == nullptr);
-	}
+
 	BOOST_CHECK(str->getNameSize() == 0);
        
 	// Inject the last flow 
@@ -1240,7 +1240,7 @@ BOOST_FIXTURE_TEST_CASE(test26, StackLanTest)
 
 	nlohmann::json j;
 
-	flow->showFlowInfo(j);
+	flow->show(j);
 	j << *info;
 
 	// Inject the rest of the trace
@@ -1322,7 +1322,7 @@ BOOST_FIXTURE_TEST_CASE(test27, StackLanTest)
 
 	nlohmann::json j;
 
-	flow->showFlowInfo(j);
+	flow->show(j);
 	j << *info;
 
         // Inject just before finish the network flow
@@ -1501,7 +1501,7 @@ BOOST_AUTO_TEST_CASE (test01)
 
 		nlohmann::json j;
 
-		flow->showFlowInfo(j);
+		flow->show(j);
 	} 
 	fm->flush();
 	stack->releaseCaches();
@@ -1796,6 +1796,14 @@ BOOST_AUTO_TEST_CASE (test07)
 	BOOST_CHECK(flow != nullptr);
         BOOST_CHECK(flow->getProtocol() == IPPROTO_TCP);
 
+        // Verify the window size of the flow
+	// Bear in mind that this are the last values of window
+	// that appear on the pcap file
+        auto tcp_info = flow->getTCPInfo();
+	BOOST_CHECK(tcp_info != nullptr);
+	BOOST_CHECK(tcp_info->upstream_window_size == 64284);
+	BOOST_CHECK(tcp_info->downstream_window_size == 5840);
+
 	uint32_t ipsrc = flow->getSourceAddress();
 	uint32_t ipdst = flow->getDestinationAddress();
 
@@ -2040,7 +2048,7 @@ BOOST_AUTO_TEST_CASE (test14)
 
 	nlohmann::json j;
 
-	flow->showFlowInfo(j);
+	flow->show(j);
       
 	{ 
 		RedirectOutput r;
@@ -2054,7 +2062,7 @@ BOOST_AUTO_TEST_CASE (test14)
         BOOST_CHECK(flow->getDNSInfo() != nullptr);
 
 	// For retrieve the DNSInfo on json
-	flow->showFlowInfo(j);
+	flow->show(j);
 
 	flows_tcp->flush();
 	flows_udp->flush();
@@ -2165,7 +2173,7 @@ BOOST_AUTO_TEST_CASE (test16)
 
 	nlohmann::json j;
 
-	flow->showFlowInfo(j);
+	flow->show(j);
 
 	{ 
 		RedirectOutput r;
@@ -2204,12 +2212,12 @@ BOOST_AUTO_TEST_CASE (test17)
 	{ 
 		RedirectOutput r;
 		r.cout << *(info.get());
-       		flow->showFlowInfo(r.cout);
+       		flow->show(r.cout);
 	}
 
 	nlohmann::json j;
 
-	flow->showFlowInfo(j);
+	flow->show(j);
 
 	stack->releaseCaches();
         
@@ -2274,7 +2282,7 @@ BOOST_AUTO_TEST_CASE (test18)
 		RedirectOutput r;
 
 		r.cout << *info.get();
-		flow->showFlowInfo(r.cout);
+		flow->show(r.cout);
 		dom->statistics("domain1");
 		dom_old->statistics("domain1");
 		r.cout << *us.get();
@@ -2282,7 +2290,7 @@ BOOST_AUTO_TEST_CASE (test18)
 
 	nlohmann::json j;
 
-	flow->showFlowInfo(j);
+	flow->show(j);
 
 	j << *info;
 
@@ -2374,7 +2382,7 @@ BOOST_AUTO_TEST_CASE (test20)
 			RedirectOutput r;
 
 			r.cout << *(info.get());
-			flow->showFlowInfo(r.cout);
+			flow->show(r.cout);
 		}
 		// Check some of the values ?
 		called = true;
@@ -2423,8 +2431,8 @@ BOOST_AUTO_TEST_CASE (test21)
 		RedirectOutput r;
 		nlohmann::json j;
 	
-		flow->showFlowInfo(r.cout);
-		flow->showFlowInfo(j);
+		flow->show(r.cout);
+		flow->show(j);
 	}
 
         stack->releaseCaches();
@@ -2471,8 +2479,8 @@ BOOST_AUTO_TEST_CASE (test22) // Test the bitcoin elements
 		nlohmann::json js;
 
 		r.cout << *info.get();
-		flow->showFlowInfo(r.cout);
-		flow->showFlowInfo(js);
+		flow->show(r.cout);
+		flow->show(js);
 
 		stack->setStatisticsLevel(5);	
 		stack->statistics(r.cout);
@@ -2529,8 +2537,8 @@ BOOST_AUTO_TEST_CASE (test23) // Test the mqtt components
 		nlohmann::json js;
 
 		r.cout << *info.get();
-		flow->showFlowInfo(r.cout);
-		flow->showFlowInfo(js);
+		flow->show(r.cout);
+		flow->show(js);
 	}
 
 	nlohmann::json j;
@@ -2604,7 +2612,7 @@ BOOST_AUTO_TEST_CASE (test24) // Test the HTTP components
 
 		stack->showProtocolSummary(r.cout);
 		r.cout << *info.get();
-		flow->showFlowInfo(r.cout);
+		flow->show(r.cout);
 	}
 
 	nlohmann::json j;
@@ -3083,7 +3091,7 @@ BOOST_AUTO_TEST_CASE (test40) // Tests the SSHProtocol
         pd->setStack(stack);
         pd->open("../pcapfiles/ssh_flow.pcap");
         pd->run();
-        // pd->close();
+        pd->close();
 
         auto fm = stack->getTCPFlowManager().lock();
         BOOST_CHECK(fm->getTotalFlows() == 1);
@@ -3095,13 +3103,13 @@ BOOST_AUTO_TEST_CASE (test40) // Tests the SSHProtocol
 
 	nlohmann::json j;
 
-	flow->showFlowInfo(j);
+	flow->show(j);
 
         {
                 RedirectOutput r;
 
                 stack->showProtocolSummary(r.cout);
-                flow->showFlowInfo(r.cout);
+                flow->show(r.cout);
                 r.cout << *(info.get());
         }
 
@@ -3195,13 +3203,13 @@ BOOST_AUTO_TEST_CASE (test01)
 	SharedPointer<SIPInfo> info = flow->getSIPInfo();
 	BOOST_CHECK(info != nullptr);
 
-	flow->showFlowInfo(j);
+	flow->show(j);
 
 	{
 		RedirectOutput r;
 	
 		stack->showProtocolSummary(r.cout);
-		flow->showFlowInfo(r.cout);	
+		flow->show(r.cout);	
 		r.cout << *(info.get());
 	}
 
@@ -3276,7 +3284,7 @@ BOOST_AUTO_TEST_CASE (test02)
 		// Exercise the print methods
 		r.cout << *(fq.get()); 
 		r.cout << *(pf.get());
-       		flow->showFlowInfo(r.cout);
+       		flow->show(r.cout);
 	}
 
 	stack->enableFrequencyEngine(false);
@@ -3385,7 +3393,7 @@ BOOST_AUTO_TEST_CASE (test04) // Test regex and ipsets with TCP traffic
 
 	nlohmann::json j;
 	
-	low_flow->showFlowInfo(j);
+	low_flow->show(j);
 
         std::string l7proto_name_low("gprs");
         std::string l7proto_name_high("tcpgeneric");
@@ -3446,17 +3454,36 @@ BOOST_AUTO_TEST_CASE (test07) // Test for retrieve the flow on mobile
 
         f = stack->getFlow("10.1.2.11", 2152, IPPROTO_UDP, "10.1.1.12", 2152);
         BOOST_CHECK(f != nullptr);
+	
+	// TTL checks 
+	BOOST_CHECK(f->upstream_ttl == 64);
+	BOOST_CHECK(f->downstream_ttl == 0);
 
         f = stack->getFlow("10.255.1.1", 5090, IPPROTO_UDP, "10.0.0.100", 5060);
         BOOST_CHECK(f != nullptr);
 
+	// TTL checks 
+	BOOST_CHECK(f->upstream_ttl == 64);
+	BOOST_CHECK(f->downstream_ttl == 64);
+
 	pd->close();
         pd->open("../pcapfiles/gprs_ftp.pcap");
         pd->run();
         
+	f = stack->getFlow("10.152.10.89", 64515, IPPROTO_UDP, "10.152.12.101", 2152);
+        BOOST_CHECK(f != nullptr);
+
+	// TTL checks 
+	BOOST_CHECK(f->upstream_ttl == 254);
+	BOOST_CHECK(f->downstream_ttl == 0);
+
 	f = stack->getFlow("10.145.254.1", 36216, IPPROTO_TCP, "102.0.5.0", 49186);
         BOOST_CHECK(f != nullptr);
 
+	// TTL checks 
+	BOOST_CHECK(f->upstream_ttl == 61);
+	BOOST_CHECK(f->downstream_ttl == 128);
+
         pd->close();
 }
 
@@ -3574,7 +3601,7 @@ BOOST_AUTO_TEST_CASE (test02) // Test the DomainNames with DNS traffic
 		SharedPointer<DNSInfo> info = flow->getDNSInfo();
 		BOOST_CHECK(info != nullptr); 
 		// Execute the code for serialize the flows
-		flow->showFlowInfo(r.cout);
+		flow->show(r.cout);
                 called = true;
         }
 	BOOST_CHECK(called == true);
@@ -3755,6 +3782,13 @@ BOOST_AUTO_TEST_CASE (test06)
         pd->run();
         pd->close();
 
+        auto fm = stack->getTCPFlowManager().lock();
+        auto flow = *fm->getFlowTable().begin();
+
+	BOOST_CHECK(flow != nullptr);
+	BOOST_CHECK(flow->upstream_ttl == 255);
+	BOOST_CHECK(flow->downstream_ttl == 44);
+
 	BOOST_CHECK(d->getMatchs() == 1);
 	BOOST_CHECK(r->getMatchs() == 1);
 }
@@ -3856,7 +3890,7 @@ BOOST_AUTO_TEST_CASE (test08) // Test the IPSets on DNS traffic
 
 	nlohmann::json j;
 
-	flow->showFlowInfo(j);
+	flow->show(j);
 
         pd->close();
 }
@@ -3984,6 +4018,12 @@ BOOST_AUTO_TEST_CASE (test02)
         BOOST_CHECK(low_flow != nullptr); // is vxlan encapsulation
         BOOST_CHECK(high_flow != nullptr);
 
+	// Check the TTLs
+	BOOST_CHECK(low_flow->upstream_ttl == 64);
+	BOOST_CHECK(low_flow->downstream_ttl == 64);
+	BOOST_CHECK(high_flow->upstream_ttl == 64);
+	BOOST_CHECK(high_flow->downstream_ttl == 64);
+
         std::string l7proto_name_low("vxlan");
         std::string l7proto_name_high("tcpgeneric");
 
@@ -4097,8 +4137,8 @@ BOOST_AUTO_TEST_CASE (test04)
 
 	nlohmann::json j;
 
-	flow->showFlowInfo(j);
-	flow->showFlowInfo(r.cout);	
+	flow->show(j);
+	flow->show(r.cout);	
 	r.cout << *info.get();
 	system->statistics(r.cout);
       	stack->showFlows(); 
@@ -4492,8 +4532,8 @@ BOOST_AUTO_TEST_CASE (test01)
 
 	nlohmann::json j1, j2;
 
-	low_flow->showFlowInfo(j1);
-	high_flow->showFlowInfo(j2);
+	low_flow->show(j1);
+	high_flow->show(j2);
 
         BOOST_CHECK(l7proto_name_high.compare(high_flow->getL7ShortProtocolName()) == 0);
         BOOST_CHECK(l7proto_name_low.compare(low_flow->getL7ShortProtocolName()) == 0);
@@ -4591,8 +4631,8 @@ BOOST_AUTO_TEST_CASE (test03) // Test the regex component on TCP
 
         nlohmann::json j1, j2;
 
-        low_flow->showFlowInfo(j1);
-        high_flow->showFlowInfo(j2);
+        low_flow->show(j1);
+        high_flow->show(j2);
 
         std::string l7proto_name_high("tcpgeneric");
         std::string l7proto_name_low("gprs");
@@ -4718,7 +4758,11 @@ BOOST_AUTO_TEST_CASE (test06) // Test for retrieve the flows
        
        	f = stack->getFlow("fd00:183:1:1:1886:9040:8605:32b8", 50372, IPPROTO_TCP, "fd01::183", 5060);
        	BOOST_CHECK(f != nullptr);
-       
+	
+	// Some TTL checks
+	BOOST_CHECK(f->upstream_ttl == 255);
+	BOOST_CHECK(f->downstream_ttl == 64);
+ 
        	f = stack->getFlow("fd01::183", 5060, IPPROTO_TCP, "fd00:183:1:1:1886:9040:8605:32b8", 50372);
        	BOOST_CHECK(f != nullptr);
         
diff --git a/src/tests.py b/src/tests.py
index 97c04ada..aec8a84e 100644
--- a/src/tests.py
+++ b/src/tests.py
@@ -21,6 +21,10 @@
 #
 # Written by Luis Campo Giralte <luis.camp0.2009@gmail.com>
 #
+# pylint: extension-pkg-whitelist=pyaiengine
+# pylint: disable=no-member
+# pylint: disable=not-an-iterable
+#
 """Unit tests for the pyaiengine python wrapper."""
 import os
 import socket
@@ -45,6 +49,8 @@ except NameError:
     xrange = range
 
 def get_new_port(from_port, to_port):
+    """Retrieve a port that is not in use for the tests."""
+
     port = 0
     sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
     for value in xrange(from_port, to_port):
@@ -66,34 +72,22 @@ class DatabaseTestAdaptor(pyaiengine.DatabaseAdaptor, object):
     """
 
     def __init__(self):
-        self.__total_inserts = 0
-        self.__total_updates = 0
-        self.__total_removes = 0
+        self.total_inserts = 0
+        self.total_updates = 0
+        self.total_removes = 0
         self.lastdata = dict()
         self.all_data = dict()
 
     def update(self, _, data):
-        self.__total_updates = self.__total_updates + 1
-        self.all_data[self.__total_updates] = data
+        self.total_updates = self.total_updates + 1
+        self.all_data[self.total_updates] = data
         self.lastdata = data
 
     def insert(self, key):
-        self.__total_inserts = self.__total_inserts + 1
+        self.total_inserts = self.total_inserts + 1
 
     def remove(self, key):
-        self.__total_removes = self.__total_removes + 1
-
-    @property
-    def total_inserts(self):
-        return self.__total_inserts
-
-    @property
-    def total_updates(self):
-        return self.__total_updates
-
-    @property
-    def total_removes(self):
-        return self.__total_removes
+        self.total_removes = self.total_removes + 1
 
 def defined(value):
     """Easy function to verify what has been enable or disable
@@ -110,10 +104,12 @@ def fileno(file_or_fd):
     descriptor = getattr(file_or_fd, 'fileno', lambda: file_or_fd)()
     if not isinstance(descriptor, int):
         raise ValueError("Expected a file (`.fileno()`) or a file descriptor")
-    return descriptor 
+    return descriptor
 
 @contextmanager
 def stdout_redirected(to=os.devnull, stdout=None):
+    """A context manager decorator for test output redirections."""
+
     if stdout is None:
         stdout = sys.stdout
 
@@ -153,6 +149,8 @@ class StackLanTests(unittest.TestCase):
         pass
 
     def inject(self, pcapfile, pcapfilter=""):
+        """Generic method for inject the pcapfiles."""
+
         with pyaiengine.PacketDispatcher(pcapfile) as pdis:
             if pcapfilter:
                 pdis.pcap_filter = pcapfilter
@@ -160,7 +158,7 @@ class StackLanTests(unittest.TestCase):
             pdis.run()
 
     def test01(self):
-        """ Create a regex for netbios and detect """
+        """Create a regex for netbios and detect."""
         self.stack.link_layer_tag = "vlan"
 
         rman = pyaiengine.RegexManager()
@@ -196,7 +194,7 @@ class StackLanTests(unittest.TestCase):
             self.assertEqual(total_lines, 8)
 
     def test02(self):
-        """ Verify that None is working on the udpregexmanager """
+        """Verify that None is working on the udpregexmanager."""
         self.stack.link_layer_tag = "vlan"
 
         rman = pyaiengine.RegexManager()
@@ -225,7 +223,8 @@ class StackLanTests(unittest.TestCase):
             self.assertEqual(total_lines, 7)
 
     def test03(self):
-        """ Create a regex for netbios with callback """
+        """Create a regex for netbios with callback. """
+
         def callback(flow):
             self.called_callback += 1
             self.assertEqual(flow.regex.matchs, 1)
@@ -279,51 +278,43 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(reg2.matchs, 0)
 
     def test04(self):
-        """ Verify DNS and HTTP traffic """
+        """Verify DNS and HTTP traffic."""
 
         self.inject("../pcapfiles/accessgoogle.pcap")
 
-        ft = self.stack.tcp_flow_manager
-        fu = self.stack.udp_flow_manager
+        tcp_flows = self.stack.tcp_flow_manager
+        udp_flows = self.stack.udp_flow_manager
 
-        self.assertEqual(len(ft), 1)
-        self.assertEqual(len(fu), 1)
+        self.assertEqual(len(tcp_flows), 1)
+        self.assertEqual(len(udp_flows), 1)
 
-        for flow in self.stack.udp_flow_manager:
-            udp_flow = flow
-            break
+        flow = [flow for flow in udp_flows][0]
 
-        self.assertEqual(str(udp_flow.dns_info.domain_name), "www.google.com")
+        self.assertEqual(str(flow.dns_info.domain_name), "www.google.com")
 
         # Verify the properties of the flows
-        self.assertEqual(str(udp_flow.src_ip), "192.168.1.13")
-        self.assertEqual(str(udp_flow.dst_ip), "89.101.160.5")
-        self.assertEqual(int(udp_flow.src_port), 54737)
-        self.assertEqual(int(udp_flow.dst_port), 53)
+        self.assertEqual(str(flow.src_ip), "192.168.1.13")
+        self.assertEqual(str(flow.dst_ip), "89.101.160.5")
+        self.assertEqual(int(flow.src_port), 54737)
+        self.assertEqual(int(flow.dst_port), 53)
 
-        for flow in ft:
-            http_flow = flow
-            break
+        flow = [flow for flow in tcp_flows][0]
 
         # Read only attributes
-        self.assertEqual(http_flow.packets_layer7, 4)
-        self.assertEqual(http_flow.packets, 10)
-        self.assertEqual(http_flow.bytes, 1826)
-        self.assertEqual(http_flow.have_tag, False)
+        self.assertEqual(flow.packets_layer7, 4)
+        self.assertEqual(flow.packets, 10)
+        self.assertEqual(flow.bytes, 1826)
+        self.assertEqual(flow.have_tag, False)
 
-        self.assertEqual(str(http_flow.http_info.host_name), "www.google.com")
-        self.assertEqual(http_flow.http_info.content_type, "text/html")
+        self.assertEqual(str(flow.http_info.host_name), "www.google.com")
+        self.assertEqual(flow.http_info.content_type, "text/html")
 
         # All the flows can not have ip_set assigned
         for flow in self.stack.tcp_flow_manager:
             self.assertIsNone(flow.ip_set)
 
-        # Shows the DNS cache
-        with tempfile.TemporaryFile() as file, stdout_redirected(file):
-            self.stack.show_cache("DNS")
-            file.seek(0)
-            total_lines = len(file.readlines())
-            self.assertEqual(total_lines, 2)
+        data = self.stack.get_cache_data("DNS", "name")
+        self.assertEqual(len(data), 1)
 
         with tempfile.TemporaryFile() as file, stdout_redirected(file):
             self.stack.show_flows("http")
@@ -331,23 +322,24 @@ class StackLanTests(unittest.TestCase):
             total_lines = len(file.readlines())
             self.assertEqual(total_lines, 8)
 
+        total = [flow for flow in self.stack.tcp_flow_manager if flow.http_info]
+        self.assertEqual(len(total), 1)
+
     def test05(self):
-        """ Verify SSL traffic """
+        """Verify SSL traffic."""
 
         self.inject("../pcapfiles/sslflow.pcap")
 
         self.assertEqual(len(self.stack.tcp_flow_manager), 1)
 
-        for flow in self.stack.tcp_flow_manager:
-            f = flow
-            break
+        flow = [flow for flow in self.stack.tcp_flow_manager][0]
 
-        self.assertEqual(str(f.ssl_info.server_name), "0.drive.google.com")
-        self.assertEqual(str(f.ssl_info.issuer_name), "Google Internet Authority")
-        self.assertEqual(format(f.ssl_info.cipher, "#04x"), '0xc011')
+        self.assertEqual(str(flow.ssl_info.server_name), "0.drive.google.com")
+        self.assertEqual(str(flow.ssl_info.issuer_name), "Google Internet Authority")
+        self.assertEqual(format(flow.ssl_info.cipher, "#04x"), '0xc011')
 
-        if defined("HAVE_JA3") == True:
-            self.assertEqual(str(f.ssl_info.fingerprint), "89d37026246d4888e78e69af4f8d1147")
+        if defined("HAVE_JA3"):
+            self.assertEqual(str(flow.ssl_info.fingerprint), "89d37026246d4888e78e69af4f8d1147")
 
         # Test the output and the existance of the function
         with tempfile.TemporaryFile() as file, stdout_redirected(file):
@@ -356,17 +348,13 @@ class StackLanTests(unittest.TestCase):
             total_lines = len(file.readlines())
             self.assertEqual(total_lines, 8)
 
-        # Test the output of the show_cache in SSL
-        with tempfile.TemporaryFile() as file, stdout_redirected(file):
-            self.stack.show_cache("ssl")
-            file.seek(0)
-            total_lines = len(file.readlines())
-            self.assertEqual(total_lines, 2)
+        data_cache = self.stack.get_cache_data("ssl", "host")
+        self.assertEqual(len(data_cache), 1)
 
     def test06(self):
-        """ Verify SSL traffic with domain callback"""
+        """Verify SSL traffic with domain callback."""
 
-        def domain_callback(flow):
+        def domain_callback(_):
             self.called_callback += 1
 
         dom1 = pyaiengine.DomainName("Google Drive Cert", ".drive.google.com")
@@ -397,7 +385,7 @@ class StackLanTests(unittest.TestCase):
 
         # check also the integrity of the ssl cache and counters
         ca1 = {'0.drive.google.com': 1}
-        cache = self.stack.get_cache("SSLProtocol")
+        cache = self.stack.get_cache_data("SSLProtocol", "host")
         self.assertDictEqual(cache, ca1)
 
         counters = self.stack.get_counters("SSLProtocol")
@@ -432,7 +420,7 @@ class StackLanTests(unittest.TestCase):
     def test07(self):
         """Verify SSL traffic with domain callback and IPset."""
 
-        def ipset_callback(flow):
+        def ipset_callback(_):
             self.ip_called_callback += 1
 
         def domain_callback(flow):
@@ -489,7 +477,7 @@ class StackLanTests(unittest.TestCase):
         ip.remove_ip_address("74.125.24.189")
 
     def test08(self):
-        """ Attach a database to the engine """
+        """Attach a database to the engine."""
 
         adaptor = DatabaseTestAdaptor()
 
@@ -510,7 +498,7 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(sys.getrefcount(adaptor), 2)
 
     def test09(self):
-        """ Attach two databases to the engine """
+        """Attach two databases to the engine."""
 
         self.stack.flows_timeout = 1
 
@@ -540,7 +528,7 @@ class StackLanTests(unittest.TestCase):
         if "info" in data:
             self.assertEqual(data["info"]["netbiosname"], "BLUMGROUP")
 
-        cache = self.stack.get_cache("netbios")
+        cache = self.stack.get_cache_data("netbios", "name")
         self.assertIsNotNone(cache["BLUMGROUP"])
 
         # reset the flows
@@ -565,32 +553,24 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(sys.getrefcount(adaptor1), 2)
         self.assertEqual(sys.getrefcount(adaptor2), 2)
 
-        # Shows the netbios cache
-        with tempfile.TemporaryFile() as file, stdout_redirected(file):
-            # The regex should be shown
-            self.stack.show_cache("netbios")
-            file.seek(0)
-            total_lines = len(file.readlines())
-            self.assertEqual(total_lines, 2)
-
     def test10(self):
-        """ Attach a database to the engine and domain name"""
+        """Attach a database to the engine and domain name."""
 
         def domain_callback(flow):
             self.called_callback += 1
             self.assertEqual(str(flow.ssl_info.server_name), "0.drive.google.com")
             self.assertEqual(flow.l7_protocol_name, "SSLProtocol")
-            self.assertEqual(d, flow.ssl_info.matched_domain_name)
+            self.assertEqual(dom, flow.ssl_info.matched_domain_name)
 
-        d = pyaiengine.DomainName("Google All", ".google.com")
+        dom = pyaiengine.DomainName("Google All", ".google.com")
 
         self.assertEqual(sys.getrefcount(domain_callback), 2)
-        dm = pyaiengine.DomainNameManager()
-        d.callback = domain_callback
+        dman = pyaiengine.DomainNameManager()
+        dom.callback = domain_callback
         self.assertEqual(sys.getrefcount(domain_callback), 3)
-        dm.add_domain_name(d)
+        dman.add_domain_name(dom)
 
-        self.stack.set_domain_name_manager(dm, "SSLProtocol")
+        self.stack.set_domain_name_manager(dman, "SSLProtocol")
 
         adaptor = DatabaseTestAdaptor()
 
@@ -601,48 +581,48 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(adaptor.total_inserts, 1)
         self.assertEqual(adaptor.total_updates, 5)
         self.assertEqual(adaptor.total_removes, 0)
-        self.assertEqual(d.matchs, 1)
+        self.assertEqual(dom.matchs, 1)
         self.assertEqual(self.called_callback, 1)
 
-        d.callback = None
+        dom.callback = None
         self.assertEqual(sys.getrefcount(domain_callback), 2)
 
     def test11(self):
-        """ Verify iterators of the RegexManager """
+        """Verify iterators of the RegexManager."""
 
-        rl = [pyaiengine.Regex("expression %d" % x, "some regex %d" % x) for x in xrange(0, 5)]
+        regl = [pyaiengine.Regex("expression %d" % x, "some regex %d" % x) for x in xrange(0, 5)]
 
         # Add a list with regexs to the RegexManager
-        rm = pyaiengine.RegexManager(rl)
+        rman = pyaiengine.RegexManager(regl)
 
         # For verify that we can iterate over the regexs
-        for r in rm:
-            _ = r
+        for reg in rman:
+            _ = reg
 
-        self.assertIsNone(rm.callback)
+        self.assertIsNone(rman.callback)
         self.assertIsNone(self.stack.tcp_regex_manager)
 
-        self.stack.tcp_regex_manager = rm
+        self.stack.tcp_regex_manager = rman
         self.stack.enable_nids_engine = True
 
         # The rm is plugged to the TCPGenericProtocol
-        self.assertNotEqual(str(rm).find("TCPGenericProtocol"), -1)
+        self.assertNotEqual(str(rman).find("TCPGenericProtocol"), -1)
 
         self.inject("../pcapfiles/sslflow.pcap")
 
-        self.assertEqual(len(rm), 5)
+        self.assertEqual(len(rman), 5)
 
-        self.assertEqual(rm, self.stack.tcp_regex_manager)
-        for r in rl:
-            self.assertEqual(r.matchs, 0)
+        self.assertEqual(rman, self.stack.tcp_regex_manager)
+        for reg in rman:
+            self.assertEqual(reg.matchs, 0)
 
         self.stack.tcp_regex_manager = None
         # the rm is not plugged to the TCPGenericProtocol
-        self.assertEqual(str(rm).find("TCPGenericProtocol"), -1)
+        self.assertEqual(str(rman).find("TCPGenericProtocol"), -1)
 
     @unittest.skipIf(not defined("HAVE_BLOOMFILTER"), "Test not supported")
     def test12(self):
-        """ Verify the IPBloomSet class """
+        """Verify the IPBloomSet class."""
 
         have_bloom = False
         try:
@@ -655,23 +635,22 @@ class StackLanTests(unittest.TestCase):
             def ipset_callback(flow):
                 self.ip_called_callback += 1
 
-            ip = pyaiengine.IPBloomSet("Specific IP address")
-            ip = IPBloomSet("Specific IP address")
-            ip.add_ip_address("74.125.24.189")
-            ip.callback = ipset_callback
+            ipset = IPBloomSet("Specific IP address")
+            ipset.add_ip_address("74.125.24.189")
+            ipset.callback = ipset_callback
 
-            ipm = pyaiengine.IPSetManager()
-            ipm.add_ip_set(ip)
+            ipman = pyaiengine.IPSetManager()
+            ipman.add_ip_set(ipset)
 
-            self.stack.tcp_ip_set_manager = ipm
+            self.stack.tcp_ip_set_manager = ipman
 
             self.inject("../pcapfiles/sslflow.pcap")
 
             self.assertEqual(self.ip_called_callback, 1)
-            ipm.reset()
+            ipman.reset()
 
     def test13(self):
-        """ Verify all the URIs of an HTTP flow """
+        """Verify all the URIs of an HTTP flow."""
 
         def domain_callback(flow):
             urls = ("/css/global.css?v=20121120a", "/js/jquery.hoverIntent.js",
@@ -716,23 +695,18 @@ class StackLanTests(unittest.TestCase):
                     )
             self.called_callback += 1
 
-            sw = False
-
-            if str(flow.http_info.uri) in urls:
-                sw = True
-
-            self.assertEqual(sw, True)
+            self.assertEqual(str(flow.http_info.uri) in urls, True)
             self.assertEqual(str(flow.http_info.host_name), "www.wired.com")
             self.assertEqual(flow.l7_protocol_name, "HTTPProtocol")
-            self.assertEqual(flow.http_info.matched_domain_name, d1)
+            self.assertEqual(flow.http_info.matched_domain_name, dom1)
 
-        d1 = pyaiengine.DomainName("Wired domain", ".wired.com")
-        d2 = pyaiengine.DomainName("Other domain", ".serving-sys.com")
+        dom1 = pyaiengine.DomainName("Wired domain", ".wired.com")
+        dom2 = pyaiengine.DomainName("Other domain", ".serving-sys.com")
 
         dm = pyaiengine.DomainNameManager()
-        d1.callback = domain_callback
-        dm.add_domain_name(d1)
-        dm.add_domain_name(d2)
+        dom1.callback = domain_callback
+        dm.add_domain_name(dom1)
+        dm.add_domain_name(dom2)
 
         self.stack.set_domain_name_manager(dm, "HTTPProtocol")
 
@@ -740,12 +714,8 @@ class StackLanTests(unittest.TestCase):
 
         self.assertEqual(self.called_callback, 1)
 
-        # Verify the output of the HTTP cache
-        with tempfile.TemporaryFile() as file, stdout_redirected(file):
-            self.stack.show_cache("http")
-            file.seek(0)
-            total_lines = len(file.readlines())
-            self.assertEqual(total_lines, 3)
+        data_cache = self.stack.get_cache_data("http", "host")
+        self.assertEqual(len(data_cache), 2)
 
         # Shows the domain matched on HTTP.
         with tempfile.TemporaryFile() as file, stdout_redirected(file):
@@ -755,7 +725,7 @@ class StackLanTests(unittest.TestCase):
             self.assertEqual(total_lines, 3)
 
     def test14(self):
-        """ Verify cache release functionality """
+        """Verify cache release functionality."""
 
         self.stack.flows_timeout = 50000000 # No timeout :D
 
@@ -763,40 +733,40 @@ class StackLanTests(unittest.TestCase):
         self.pdis.run()
         self.pdis.close()
 
-        ft = self.stack.tcp_flow_manager
+        tcp_flows = self.stack.tcp_flow_manager
 
-        self.assertEqual(len(ft), 1)
+        self.assertEqual(len(tcp_flows), 1)
 
-        for flow in ft:
+        for flow in tcp_flows:
             self.assertNotEqual(flow.ssl_info, None)
 
         self.inject("../pcapfiles/accessgoogle.pcap")
 
-        fu = self.stack.udp_flow_manager
+        udp_flows = self.stack.udp_flow_manager
 
-        self.assertEqual(len(fu), 1)
+        self.assertEqual(len(udp_flows), 1)
 
-        for flow in fu:
+        for flow in udp_flows:
             self.assertNotEqual(flow.dns_info, None)
 
         # release some of the caches
         self.stack.release_cache("SSLProtocol")
 
-        for flow in ft:
+        for flow in tcp_flows:
             self.assertEqual(flow.ssl_info, None)
 
         # release all the caches
         self.stack.release_caches()
 
-        for flow in ft:
+        for flow in tcp_flows:
             self.assertEqual(flow.ssl_info, None)
             self.assertEqual(flow.http_info, None)
 
-        for flow in fu:
+        for flow in udp_flows:
             self.assertEqual(flow.dns_info, None)
 
     def test15(self):
-        """ Attach a database to the engine and test timeouts on udp flows """
+        """Attach a database to the engine and test timeouts on udp flows."""
 
         adaptor = DatabaseTestAdaptor()
 
@@ -815,7 +785,7 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(self.stack.flows_timeout, 1)
 
     def test16(self):
-        """ Verify that ban domains dont take memory """
+        """Verify that ban domains dont take memory."""
 
         dom = pyaiengine.DomainName("Wired domain", ".wired.com")
 
@@ -828,20 +798,20 @@ class StackLanTests(unittest.TestCase):
 
         self.assertEqual(dom.matchs, 1)
 
-        ft = self.stack.tcp_flow_manager
+        tcp_flows = self.stack.tcp_flow_manager
 
-        self.assertEqual(len(ft), 2)
+        self.assertEqual(len(tcp_flows), 2)
 
         # Only the first flow is the banned
-        for flow in ft:
-            info = flow.http_info
-            self.assertEqual(info.host_name, "")
-            self.assertEqual(info.user_agent, "")
-            self.assertEqual(info.uri, "")
-            break
+        flow = [flow for flow in tcp_flows][0]
+
+        info = flow.http_info
+        self.assertEqual(info.host_name, "")
+        self.assertEqual(info.user_agent, "")
+        self.assertEqual(info.uri, "")
 
     def test17(self):
-        """ Verify the ban functionality on the fly with a callback """
+        """Verify the ban functionality on the fly with a callback."""
 
         def domain_callback(flow):
             self.called_callback += 1
@@ -873,13 +843,13 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(len(ft), 2)
 
         # Only the first flow is the banned and released
-        for flow in self.stack.tcp_flow_manager:
-            inf = flow.http_info
-            self.assertNotEqual(inf, None)
-            self.assertEqual(inf.uri, "")
-            self.assertEqual(inf.user_agent, "")
-            self.assertEqual(inf.host_name, "")
-            break
+        flow = [flow for flow in self.stack.tcp_flow_manager][0]
+        
+        info = flow.http_info
+        self.assertNotEqual(info, None)
+        self.assertEqual(info.uri, "")
+        self.assertEqual(info.user_agent, "")
+        self.assertEqual(info.host_name, "")
 
         self.stack.release_caches()
 
@@ -889,7 +859,7 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(str(dman).find("HTTPProtocol"), -1)
 
     def test18(self):
-        """ Verify the getCounters functionality """
+        """Verify the getCounters functionality."""
 
         self.inject("../pcapfiles/two_http_flows_noending.pcap")
 
@@ -918,14 +888,15 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(len(counters), 0)
 
     def test19(self):
-        """ Verify SMTP traffic with domain callback """
+        """Verify SMTP traffic with domain callback."""
+
         self.from_correct = False
         def domain_callback(flow):
-            s = flow.smtp_info
-            if s:
-                if str(s.mail_from) == "gurpartap@patriots.in":
+            smtp = flow.smtp_info
+            if smtp:
+                if str(smtp.mail_from) == "gurpartap@patriots.in":
                     self.from_correct = True
-                _ = s.mail_to
+                _ = smtp.mail_to
             self.called_callback += 1
 
         dom = pyaiengine.DomainName("Some domain", ".patriots.in")
@@ -948,17 +919,10 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(dom.matchs, 1)
         self.assertEqual(self.called_callback, 1)
         self.assertEqual(self.from_correct, True)
-        self.assertEqual(len(self.stack.get_cache("smtp")), 1)
-
-        # Test the show_cache method on smtp
-        with tempfile.TemporaryFile() as file, stdout_redirected(file):
-            self.stack.show_cache("Smtp")
-            file.seek(0)
-            total_lines = len(file.readlines())
-            self.assertEqual(total_lines, 2)
+        self.assertEqual(len(self.stack.get_cache_data("smtp", "from")), 1)
 
     def test20(self):
-        """ Test the chains of regex with RegexManagers """
+        """Test the chains of regex with RegexManagers."""
 
         rlist = [pyaiengine.Regex("expression %d" % x, "some regex %d" % x) for x in xrange(0, 5)]
 
@@ -1004,7 +968,8 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(reg6.matchs, 1)
 
     def test21(self):
-        """ Tests the parameters of the callbacks """
+        """Tests the parameters of the callbacks."""
+
         def callback1(flow):
             # pylint: disable=unused-argument
             pass
@@ -1041,10 +1006,11 @@ class StackLanTests(unittest.TestCase):
 
         self.uset = pyaiengine.HTTPUriSet()
         def domain_callback(flow):
-            # pylint: disable=unused-argument
+            self.assertIsNotNone(flow)
             self.called_callback += 1
 
         def uri_callback(flow):
+            self.assertIsNotNone(flow)
             self.assertEqual(len(self.uset), 1)
             self.assertEqual(self.uset.lookups, 39)
             self.assertEqual(self.uset.lookups_in, 1)
@@ -1149,19 +1115,12 @@ class StackLanTests(unittest.TestCase):
 
         self.assertEqual(self.called_callback, 1)
 
-        # Verify the output of the show_cache
-        with tempfile.TemporaryFile() as file, stdout_redirected(file):
-            self.stack.show_cache("ssdp")
-            file.seek(0)
-            total_lines = len(file.readlines())
-            self.assertEqual(total_lines, 2)
-
-        cache = self.stack.get_cache("ssdp")
+        data_cache = self.stack.get_cache_data("ssdp", "host")
         cache1 = {'239.255.255.250:1900': 1}
-        self.assertDictEqual(cache, cache1)
+        self.assertDictEqual(data_cache, cache1)
 
     def test26(self):
-        """ Verify the functionality of the SSDP Protocol and remove the memory of that protocol """
+        """Verify the functionality of the SSDP Protocol and remove the memory of that protocol."""
 
         self.stack.decrease_allocated_memory("ssdp", 10000)
 
@@ -1169,14 +1128,13 @@ class StackLanTests(unittest.TestCase):
 
         fu = self.stack.udp_flow_manager
         for flow in fu:
-            s = flow.ssdp_info
-            self.assertEqual(s, None)
+            self.assertEqual(flow.ssdp_info, None)
 
     def test27(self):
-        """ Verify the functionality of the RegexManager on the HTTP Protocol for analise
-            inside the l7 payload of HTTP """
+        """Verify the functionality of the RegexManager on the HTTP Protocol for analise
+            inside the l7 payload of HTTP."""
 
-        def callback_domain(flow):
+        def callback_domain(_):
             self.called_callback += 1
             pass
 
@@ -1218,7 +1176,7 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(dom.matchs, 1)
 
     def test28(self):
-        """ Verify the correctness of the HTTP Protocol """
+        """Verify the correctness of the HTTP Protocol."""
 
         # The filter tcp and port 55354 will filter just one HTTP flow
         # that contains exactly 39 requests and 38 responses
@@ -1229,7 +1187,7 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(counters["responses"], 38)
 
     def test29(self):
-        """ Verify the correctness of the HTTP Protocol """
+        """Verify the correctness of the HTTP Protocol."""
 
         # The filter tcp and port 49503 will filter just one HTTP flow
         # that contains exactly 39 requests and 38 responses
@@ -1240,7 +1198,7 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(counters["responses"], 3)
 
     def test30(self):
-        """ Verify the functionality of the Evidence manager """
+        """Verify the functionality of the Evidence manager."""
 
         def domain_callback(flow):
             self.called_callback += 1
@@ -1267,7 +1225,7 @@ class StackLanTests(unittest.TestCase):
         os.remove(files[0])
 
     def test31(self):
-        """ Verify the functionality of the RegexManager on the IPSets """
+        """Verify the functionality of the RegexManager on the IPSets."""
 
         def regex_callback(flow):
             reg = flow.regex
@@ -1519,7 +1477,7 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(dom.matchs, 1)
 
     def test38(self):
-        """ Test the modbus protocol """
+        """Test the modbus protocol."""
 
         self.inject("../pcapfiles/modbus_five_flows.pcap")
 
@@ -1528,15 +1486,12 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(counters["read coils"], 6)
 
     def test39(self):
-        """ Verify the release cache with netbios object attached """
+        """Verify the release cache with netbios object attached."""
         self.stack.link_layer_tag = "vlan"
 
         self.inject("../pcapfiles/flow_vlan_netbios.pcap")
 
-        flows = self.stack.udp_flow_manager
-        flow = None
-        for f in flows:
-            flow = f
+        flow = [flow for flow in self.stack.udp_flow_manager][0]
 
         self.assertIsNotNone(flow)
         self.assertIsNotNone(flow.netbios_info)
@@ -1545,17 +1500,15 @@ class StackLanTests(unittest.TestCase):
 
         self.stack.release_cache("netbios")
 
-        flow = None
-        for f in flows:
-            flow = f
+        flow = [flow for flow in self.stack.udp_flow_manager][0]
 
         self.assertIsNotNone(flow)
         self.assertIsNone(flow.netbios_info)
 
     def test40(self):
-        """ Verify that callbacks with None do not break things """
+        """Verify that callbacks with None do not break things."""
 
-        def domain_callback(flow):
+        def domain_callback(_):
             self.called_callback += 1
 
         dom = pyaiengine.DomainName("Google Drive Cert", ".drive.google.com")
@@ -1600,7 +1553,7 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(self.called_callback, 1)
 
     def test41(self):
-        """ Create a regex for netbios and add and remove from a RegexManager """
+        """Create a regex for netbios and add and remove from a RegexManager."""
         self.stack.link_layer_tag = "vlan"
 
         rman = pyaiengine.RegexManager()
@@ -1628,7 +1581,7 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(reg.matchs, 1)
 
     def test42(self):
-        """ Create a regex for netbios with callback and a RegexManager with callback """
+        """Create a regex for netbios with callback and a RegexManager with callback."""
 
         def callback_rm(flow):
             self.called_callback += 1
@@ -1639,7 +1592,6 @@ class StackLanTests(unittest.TestCase):
             self.assertIsNotNone(flow)
             self.fail("shouldn't happen")
 
-
         self.stack.link_layer_tag = "vlan"
 
         rman = pyaiengine.RegexManager()
@@ -1661,7 +1613,7 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(self.called_callback, 1)
 
     def test43(self):
-        """" Create a complex detection on http traffic payload for exercise the code """
+        """"Create a complex detection on http traffic payload for exercise the code."""
 
         def callback_domain(flow):
             self.called_callback += 1
@@ -1725,18 +1677,18 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(sys.getrefcount(reg3), 2)
 
     def test44(self):
-        """ Test the chains of regex with callbacks and regex on constructors """
+        """Test the chains of regex with callbacks and regex on constructors."""
 
-        def callback_regex_auth(flow):
+        def callback_regex_auth(_):
             self.called_callback += 1
 
-        def callback_regex_from(flow):
+        def callback_regex_from(_):
             self.called_callback += 1
 
-        def callback_regex_data(flow):
+        def callback_regex_data(_):
             self.called_callback += 1
 
-        def callback_regex_quit(flow):
+        def callback_regex_quit(_):
             self.called_callback += 1
 
         # Example of link regexs with callbacks inside
@@ -1759,7 +1711,7 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(self.called_callback, 4)
 
     def test45(self):
-        """ Test use of regexs on the HTTP uri field """
+        """Test use of regexs on the HTTP uri field."""
 
         def callback_uri(flow):
             inf = flow.http_info
@@ -1768,40 +1720,38 @@ class StackLanTests(unittest.TestCase):
             self.assertEqual(inf.host_name, "www.google.com")
             self.called_callback += 1
 
-        dm = pyaiengine.DomainNameManager()
-        rm = pyaiengine.RegexManager()
-        r = pyaiengine.Regex("my uri regex", b"^.*tia.png$", callback_uri)
-        d = pyaiengine.DomainName("Gafas", "google.com")
+        dman = pyaiengine.DomainNameManager()
+        rman = pyaiengine.RegexManager()
+        reg = pyaiengine.Regex("my uri regex", b"^.*tia.png$", callback_uri)
+        dom = pyaiengine.DomainName("Gafas", "google.com")
 
         # Attach the RegexManager to process all the Uris from google
-        d.http_uri_regex_manager = rm
+        dom.http_uri_regex_manager = rman
 
-        self.assertEqual(d.http_uri_regex_manager, rm)
+        self.assertEqual(dom.http_uri_regex_manager, rman)
 
-        dm.add_domain_name(d)
-        rm.add_regex(r)
+        dman.add_domain_name(dom)
+        rman.add_regex(reg)
 
-        self.stack.set_domain_name_manager(dm, "http")
+        self.stack.set_domain_name_manager(dman, "http")
 
         self.inject("../pcapfiles/accessgoogle.pcap")
 
         self.assertEqual(self.called_callback, 1)
 
     def test46(self):
-        """ Verify the functionality of dynamic memory with the SSDP Protocol """
+        """Verify the functionality of dynamic memory with the SSDP Protocol."""
 
         self.stack.decrease_allocated_memory("ssdp", 10000)
         self.stack.set_dynamic_allocated_memory(True)
 
         self.inject("../pcapfiles/ssdp_flow.pcap")
 
-        fu = self.stack.udp_flow_manager
-        for flow in fu:
-            s = flow.ssdp_info
-            self.assertNotEqual(s, None)
+        for flow in self.stack.udp_flow_manager:
+            self.assertNotEqual(flow.ssdp_info, None)
 
     def test47(self):
-        """ Verify the functionality of dynamic memory with the HTTP Protocol """
+        """Verify the functionality of dynamic memory with the HTTP Protocol."""
 
         self.stack.decrease_allocated_memory("HTTP", 10000)
 
@@ -1810,15 +1760,14 @@ class StackLanTests(unittest.TestCase):
 
         self.inject("../pcapfiles/two_http_flows_noending.pcap")
 
-        ft = self.stack.tcp_flow_manager
-        for flow in ft:
+        for flow in self.stack.tcp_flow_manager:
             self.assertNotEqual(flow.http_info, None)
             self.assertNotEqual(flow.http_info.host_name, None)
             self.assertNotEqual(flow.http_info.uri, None)
             self.assertNotEqual(flow.http_info.user_agent, None)
 
     def test48(self):
-        """ Complex detection on the HTTP Protocol """
+        """Complex detection on the HTTP Protocol."""
 
         def callback_1(flow):
             self.assertEqual(flow.packets_layer7, 2)
@@ -1839,19 +1788,22 @@ class StackLanTests(unittest.TestCase):
         def callback_3(flow):
             self.assertEqual(flow.packets_layer7, 15)
             self.assertNotEqual(flow.http_info, None)
-            self.assertEqual(flow.http_info.uri, "/images_blogs/gadgetlab/2013/07/MG_9640edit-200x100.jpg")
+            self.assertEqual(flow.http_info.uri,
+                             "/images_blogs/gadgetlab/2013/07/MG_9640edit-200x100.jpg")
             self.called_callback += 1
 
         def callback_4(flow):
             self.assertEqual(flow.packets_layer7, 16)
             self.assertNotEqual(flow.http_info, None)
-            self.assertEqual(flow.http_info.uri, "/images_blogs/gadgetlab/2013/07/MG_9640edit-200x100.jpg")
+            self.assertEqual(flow.http_info.uri,
+                             "/images_blogs/gadgetlab/2013/07/MG_9640edit-200x100.jpg")
             self.called_callback += 1
 
         def callback_5(flow):
             self.assertEqual(flow.packets_layer7, 31)
             self.assertNotEqual(flow.http_info, None)
-            self.assertEqual(flow.http_info.uri, "/images_blogs/thisdayintech/2013/03/set.jpg")
+            self.assertEqual(flow.http_info.uri,
+                             "/images_blogs/thisdayintech/2013/03/set.jpg")
             self.called_callback += 1
 
         dman = pyaiengine.DomainNameManager()
@@ -1897,26 +1849,23 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(reg5.matchs, 1)
 
     def test49(self):
-        """ Verify the ban domains on SSL traffic """
+        """Verify the ban domains on SSL traffic."""
 
-        d = pyaiengine.DomainName("Google Drive Cert", ".drive.google.com")
-        d.callback = None
+        dom = pyaiengine.DomainName("Google Drive Cert", ".drive.google.com")
+        dom.callback = None
 
-        dm = pyaiengine.DomainNameManager()
-        dm.add_domain_name(d)
+        dman = pyaiengine.DomainNameManager()
+        dman.add_domain_name(dom)
 
-        self.stack.set_domain_name_manager(dm, "SSLProtocol", False)
+        self.stack.set_domain_name_manager(dman, "SSLProtocol", False)
 
         self.inject("../pcapfiles/sslflow.pcap")
 
-        self.assertEqual(d.matchs, 1)
+        self.assertEqual(dom.matchs, 1)
 
-        flow = None
-        for f in self.stack.tcp_flow_manager:
-            flow = f
-            break
+        flow = [flow for flow in self.stack.tcp_flow_manager][0]
 
-        cache = self.stack.get_cache("ssl")
+        cache = self.stack.get_cache_data("ssl", "issuer")
         self.assertNotEqual(flow, None)
         self.assertNotEqual(flow.ssl_info, None)
         self.assertEqual(flow.ssl_info.server_name, "")
@@ -1935,73 +1884,73 @@ class StackLanTests(unittest.TestCase):
 
         self.assertEqual(len(self.stack.tcp_flow_manager), 4)
 
-        for f in self.stack.tcp_flow_manager:
-            self.assertEqual(source_port, f.src_port)
+        for flow in self.stack.tcp_flow_manager:
+            self.assertEqual(source_port, flow.src_port)
             source_port = source_port + 1
 
     def test51(self):
-        """ Verify the functionality of the IPRadixTrees """
+        """Verify the functionality of the IPRadixTrees."""
 
         def regex_callback(flow):
-            r = flow.regex
-            i = flow.ip_set
+            reg = flow.regex
+            ipset = flow.ip_set
             if sys.version_info.major > 2:
                 self.assertRegex(flow.dst_ip, "(95.100.96.10|95.100.96.48)")
             else:
                 self.assertRegexpMatches(flow.dst_ip, "(95.100.96.10|95.100.96.48)")
-            self.assertEqual(r.name, "generic http")
-            self.assertEqual(i.name, "something")
+            self.assertEqual(reg.name, "generic http")
+            self.assertEqual(ipset.name, "something")
             self.called_callback += 1
 
         def ipset_callback(flow):
-            r = flow.regex
-            i = flow.ip_set
-            self.assertNotEqual(i, None)
-            self.assertEqual(i.name, "something")
-            self.assertEqual(r, None)
+            reg = flow.regex
+            ipset = flow.ip_set
+            self.assertNotEqual(ipset, None)
+            self.assertEqual(ipset.name, "something")
+            self.assertEqual(reg, None)
             self.called_callback += 1
 
-        rm = pyaiengine.RegexManager()
-        ix = pyaiengine.IPRadixTree(["95.100.96.10/24", "192.172.12.1"])
+        rman = pyaiengine.RegexManager()
+        rtree = pyaiengine.IPRadixTree(["95.100.96.10/24", "192.172.12.1"])
 
         # Change the name of the radix tree
-        self.assertEqual(ix.name, "Generic IPRadixTree")
-        ix.name = "something"
+        self.assertEqual(rtree.name, "Generic IPRadixTree")
+        rtree.name = "something"
 
-        ix.regex_manager = rm
-        ix.callback = ipset_callback
+        rtree.regex_manager = rman
+        rtree.callback = ipset_callback
         im = pyaiengine.IPSetManager()
 
-        self.assertEqual(ix.callback, ipset_callback)
+        self.assertEqual(rtree.callback, ipset_callback)
 
         self.assertEqual("Generic IPSetManager", im.name)
         im.name = "buuu"
         self.assertEqual("buuu", im.name)
 
-        im.add_ip_set(ix)
+        im.add_ip_set(rtree)
         self.stack.tcp_ip_set_manager = im
 
-        r = pyaiengine.Regex("generic http", "^GET.*HTTP")
-        r.callback = regex_callback
-        rm.add_regex(r)
+        reg = pyaiengine.Regex("generic http", "^GET.*HTTP")
+        reg.callback = regex_callback
+        rman.add_regex(reg)
 
         self.stack.enable_nids_engine = True
 
         self.inject("../pcapfiles/two_http_flows_noending.pcap")
 
         self.assertEqual(self.called_callback, 4)
-        self.assertEqual(ix.lookups_in, 2)
-        self.assertEqual(r.matchs, 2)
+        self.assertEqual(rtree.lookups_in, 2)
+        self.assertEqual(reg.matchs, 2)
 
         # Verify the output of the IPRadixTree
         with tempfile.TemporaryFile() as file, stdout_redirected(file):
-            ix.show()
+            rtree.show()
             file.seek(0)
             total_lines = len(file.readlines())
             self.assertEqual(total_lines, 3)
 
     def test52(self):
-        """ verify that we have two different records on the adaptors with smtp-starttls """
+        """Verify that we have two different records on the adaptors with smtp-starttls."""
 
         adaptor = DatabaseTestAdaptor()
 
@@ -2026,7 +1975,7 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(smtp_r["port"]["dst"], ssl_r["port"]["dst"])
 
     def test53(self):
-        """ verify that we have two different records on the adaptors with imap-starttls """
+        """Verify that we have two different records on the adaptors with imap-starttls."""
 
         adaptor = DatabaseTestAdaptor()
 
@@ -2076,35 +2025,35 @@ class StackLanTests(unittest.TestCase):
     def test55(self):
 
         def callback_domain(flow):
-            h = flow.http_info
+            info = flow.http_info
             self.assertEqual(flow.packets_layer7, 1)
-            self.assertEqual(h.uri, "/index.htm?v=5&eh=&ts=0&u2=lpdDC5KtfXqwOCkfKJ0O")
+            self.assertEqual(info.uri, "/index.htm?v=5&eh=&ts=0&u2=lpdDC5KtfXqwOCkfKJ0O")
             self.assertEqual(flow.regex, None)
             self.called_callback += 1
 
         def callback(flow):
-            h = flow.http_info
+            info = flow.http_info
             self.assertEqual(flow.packets_layer7, 2)
-            self.assertEqual(h.uri, "/index.htm?v=5&eh=&ts=0&u2=lpdDC5KtfXqwOCkfKJ0O")
-            self.assertEqual(flow.regex.name, r.name)
+            self.assertEqual(info.uri, "/index.htm?v=5&eh=&ts=0&u2=lpdDC5KtfXqwOCkfKJ0O")
+            self.assertEqual(flow.regex.name, reg.name)
             self.called_callback += 1
 
-        dm = pyaiengine.DomainNameManager()
-        rm = pyaiengine.RegexManager()
-        r = pyaiengine.Regex("matchs on 1 response", b"^.*PNG.*(?!.*IHDR).*$", callback)
-        d = pyaiengine.DomainName("No trusted domain", ".ru", callback_domain)
+        dman = pyaiengine.DomainNameManager()
+        rman = pyaiengine.RegexManager()
+        reg = pyaiengine.Regex("matchs on 1 response", b"^.*PNG.*(?!.*IHDR).*$", callback)
+        dom = pyaiengine.DomainName("No trusted domain", ".ru", callback_domain)
 
-        dm.add_domain_name(d)
+        dman.add_domain_name(dom)
 
-        rm.add_regex(r)
+        rman.add_regex(reg)
 
         # Attach the RegexManager to process all the payloads from wired
-        d.regex_manager = rm
+        dom.regex_manager = rman
 
         # enable the dynamic memory for just http
         self.stack.set_dynamic_allocated_memory("HTTP", True)
 
-        self.stack.set_domain_name_manager(dm, "http")
+        self.stack.set_domain_name_manager(dman, "http")
 
         self.inject("../pcapfiles/http_flow.pcap")
 
@@ -2124,10 +2073,10 @@ class StackLanTests(unittest.TestCase):
             self.assertGreater(len(flow.payload), 512)
             self.called_callback += 1
 
-        dm = pyaiengine.DomainNameManager()
-        d = pyaiengine.DomainName("No trusted domain", ".gov", callback_domain)
+        dman = pyaiengine.DomainNameManager()
+        dom = pyaiengine.DomainName("No trusted domain", ".gov", callback_domain)
 
-        dm.add_domain_name(d)
+        dman.add_domain_name(dom)
 
         self.stack.set_dynamic_allocated_memory("SMTP", True)
 
@@ -2136,7 +2085,7 @@ class StackLanTests(unittest.TestCase):
         self.stack.set_anomaly_callback(callback_anomaly, "SMTP")
         self.stack.set_anomaly_callback(callback_anomaly, "smtpprotocol")
 
-        self.stack.set_domain_name_manager(dm, "SMTP")
+        self.stack.set_domain_name_manager(dman, "SMTP")
 
         self.inject("../pcapfiles/smtp_flow.pcap")
 
@@ -2144,10 +2093,10 @@ class StackLanTests(unittest.TestCase):
 
         # Verify the output of the anomaly that have been set
         with tempfile.TemporaryFile() as file, stdout_redirected(file):
-            self.stack.show_statistics(5)
+            self.stack.show(5)
 
     def test57(self):
-        """ verify the counters and json output of the DCERPC component """
+        """Verify the counters and json output of the DCERPC component."""
 
         adaptor = DatabaseTestAdaptor()
 
@@ -2165,15 +2114,11 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(counters["binds"], 10)
         self.assertEqual(counters["bind acks"], 10)
 
-        for f in self.stack.tcp_flow_manager:
-            a = f.dcerpc_info.uuid
+        for flow in self.stack.tcp_flow_manager:
+            _ = flow.dcerpc_info.uuid
 
-        # print the output of the cache
-        with tempfile.TemporaryFile() as file, stdout_redirected(file):
-            self.stack.show_cache("dcerpc")
-            file.seek(0)
-            total_lines = len(file.readlines())
-            self.assertEqual(total_lines, 4)
+        data_cache = self.stack.get_cache_data("dcerpc", "uuid")
+        self.assertEqual(len(data_cache), 3)
 
     def test58(self):
         """ disable DCERPC protocol and check values """
@@ -2205,8 +2150,9 @@ class StackLanTests(unittest.TestCase):
 
         counters2 = {'type SRV': 0, 'type AAAA': 0, 'type SSHFP': 0, 'type LOC': 0, 'type PTR': 0,
                      'type NS': 0, 'type A': 0, 'type MX': 0, 'type ANY': 0, 'allow queries': 0,
-                     'type IXFR': 0, 'type DNSKEY': 0, 'type others': 0, 'queries': 0, 'type CNAME': 0,
-                     'responses': 0, 'type SOA': 0, 'banned queries': 0, 'type DS': 0, 'type TXT': 0}
+                     'type IXFR': 0, 'type DNSKEY': 0, 'type others': 0, 'queries': 0,
+                     'type CNAME': 0, 'responses': 0, 'type SOA': 0, 'banned queries': 0,
+                     'type DS': 0, 'type TXT': 0}
 
         counters = self.stack.get_counters("DNSProtocol")
 
@@ -2230,14 +2176,17 @@ class StackLanTests(unittest.TestCase):
 
         counters4 = {'L7 bytes': 218, 'heads': 0, 'responses': 2, 'puts': 0, 'packets': 4,
                      'bytes': 1826, 'connects': 0, 'options': 0, 'posts': 0, 'banned hosts': 0,
-                     'others': 0, 'requests': 2, 'gets': 2, 'traces': 0, 'allow hosts': 2, 'deletes': 0}
+                     'others': 0, 'requests': 2, 'gets': 2, 'traces': 0, 'allow hosts': 2,
+                     'deletes': 0}
 
         self.assertDictEqual(counters, counters4)
 
         counters5 = {'type MX': 0, 'type DS': 0, 'type SOA': 0, 'type CNAME': 0, 'responses': 2,
                      'type SRV': 0, 'type TXT': 0, 'type ANY': 0, 'type others': 0, 'type SSHFP': 0,
                      'type LOC': 0, 'type DNSKEY': 0, 'type IXFR': 0, 'type AAAA': 1, 'type NS': 0,
-                     'queries': 2, 'allow queries': 2, 'banned queries': 0, 'type PTR': 0, 'type A': 1}
+                     'queries': 2, 'allow queries': 2, 'banned queries': 0,
+                     'type PTR': 0, 'type A': 1}
+
         counters = self.stack.get_counters("DNS")
 
         self.assertDictEqual(counters, counters5)
@@ -2247,19 +2196,31 @@ class StackLanTests(unittest.TestCase):
         self.assertDictEqual(counters, counters3)
 
     def test60(self):
-        """ Operate with pop traffic """
+        """Operate with pop traffic."""
 
         def pop_callback(flow):
-            a = flow.pop_info
-            self.assertEqual(a.user_name, "plod")
+            self.assertEqual(flow.pop_info.user_name, "plod")
+
+            # Check some TCP Flags
+            tcp = flow.tcp_info
+            self.assertIsNotNone(tcp)
+            self.assertEqual(tcp.syns, 1)
+            self.assertEqual(tcp.synacks, 1)
+            self.assertEqual(tcp.synacks, 1)
+            self.assertEqual(tcp.acks, 3)
+            self.assertEqual(tcp.fins, 0)
+            self.assertEqual(tcp.rsts, 0)
+            self.assertEqual(tcp.pushs, 2)
+            self.assertEqual(tcp.state, "ESTABLISHED")
+
             self.called_callback += 1
 
-        dm = pyaiengine.DomainNameManager()
-        d = pyaiengine.DomainName("No trusted domain", "*", pop_callback)
+        dman = pyaiengine.DomainNameManager()
+        dom = pyaiengine.DomainName("No trusted domain", "*", pop_callback)
 
-        dm.add_domain_name(d)
+        dman.add_domain_name(dom)
 
-        self.stack.set_domain_name_manager(dm, "pop")
+        self.stack.set_domain_name_manager(dman, "pop")
         self.stack.set_dynamic_allocated_memory(True)
 
         self.inject("../pcapfiles/pop_flow.pcap")
@@ -2270,31 +2231,22 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(counters["responses"], 16)
         self.assertEqual(self.called_callback, 1)
 
-        cache = self.stack.get_cache("pop")
-
-        self.assertIn("plod", cache)
-
-        # print the output of the cache
-        with tempfile.TemporaryFile() as file, stdout_redirected(file):
-            self.stack.show_cache("pop")
-            file.seek(0)
-            total_lines = len(file.readlines())
-            self.assertEqual(total_lines, 2)
+        data_cache = self.stack.get_cache_data("pop", "user")
+        self.assertIn("plod", data_cache)
 
     def test61(self):
-        """ Test case for IMAP traffic """
+        """Test case for IMAP traffic."""
 
         def imap_callback(flow):
-            a = flow.imap_info
-            self.assertEqual(a.user_name, "samir")
+            self.assertEqual(flow.imap_info.user_name, "samir")
             self.called_callback += 1
 
-        dm = pyaiengine.DomainNameManager()
-        d = pyaiengine.DomainName("No trusted domain", "*", imap_callback)
+        dman = pyaiengine.DomainNameManager()
+        dom = pyaiengine.DomainName("No trusted domain", "*", imap_callback)
 
-        dm.add_domain_name(d)
+        dman.add_domain_name(dom)
 
-        self.stack.set_domain_name_manager(dm, "imap")
+        self.stack.set_domain_name_manager(dman, "imap")
         self.stack.set_dynamic_allocated_memory(True)
 
         self.inject("../pcapfiles/imap_flow.pcap")
@@ -2305,19 +2257,12 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(counters["responses"], 12)
         self.assertEqual(self.called_callback, 1)
 
-        cache = self.stack.get_cache("imap")
-
-        self.assertIn("samir", cache)
+        data_cache = self.stack.get_cache_data("imap", "user")
 
-        # print the output of the cache
-        with tempfile.TemporaryFile() as file, stdout_redirected(file):
-            self.stack.show_cache("imap")
-            file.seek(0)
-            total_lines = len(file.readlines())
-            self.assertEqual(total_lines, 2)
+        self.assertIn("samir", data_cache)
 
     def test62(self):
-        """ Test case for SMB traffic """
+        """Test case for SMB traffic."""
 
         self.stack.set_dynamic_allocated_memory(True)
 
@@ -2327,42 +2272,33 @@ class StackLanTests(unittest.TestCase):
 
         self.assertEqual(counters["create files"], 8)
 
-        cache = self.stack.get_cache("smb")
+        data_cache = self.stack.get_cache_data("smb", "name")
+        self.assertEqual(len(data_cache), 0)
 
-        # print the output of the cache
-        with tempfile.TemporaryFile() as file, stdout_redirected(file):
-            self.stack.show_cache("smb")
-            file.seek(0)
-            total_lines = len(file.readlines())
-            self.assertEqual(total_lines, 3)
+        data_cache = self.stack.get_cache_data("smb", "filename")
+        self.assertEqual(len(data_cache), 2)
 
-        for f in self.stack.tcp_flow_manager:
-            filename = f.smb_info.filename
+        for flow in self.stack.tcp_flow_manager:
+            filename = flow.smb_info.filename
 
         self.assertEqual(filename, "WP_SMBPlugin.pdf")
 
     def test63(self):
-        """ Test case for MQTT traffic """
+        """Test case for MQTT traffic."""
 
         self.stack.set_dynamic_allocated_memory(True)
 
         self.inject("../pcapfiles/ipv4_mqtt.pcap")
 
-        for f in self.stack.tcp_flow_manager:
-            a = f.mqtt_info.topic
+        for flow in self.stack.tcp_flow_manager:
+            _ = flow.mqtt_info.topic
 
         counters = self.stack.get_counters("mqtt")
 
         self.assertEqual(counters["commands"], 8)
 
-        cache = self.stack.get_cache("mqtt")
-
-        # print the output of the cache
-        with tempfile.TemporaryFile() as file, stdout_redirected(file):
-            self.stack.show_cache("mqtt")
-            file.seek(0)
-            total_lines = len(file.readlines())
-            self.assertEqual(total_lines, 2)
+        data_cache = self.stack.get_cache_data("mqtt", "topic")
+        self.assertEqual(len(data_cache), 1)
 
     def test64(self):
         """ Test case for matchs several Regexs on DCERPC """
@@ -2398,12 +2334,12 @@ class StackLanTests(unittest.TestCase):
             self.assertEqual(total_lines, 3)
 
     def test65(self):
-        """ Verify the coap protocol functionality with domains and uri sets """
+        """Verify the coap protocol functionality with domains and uri sets."""
 
-        def domain_callback(flow):
+        def domain_callback(_):
             self.called_callback += 1
 
-        def uri_callback(flow):
+        def uri_callback(_):
             self.assertEqual(len(uset), 1)
             self.assertEqual(uset.lookups, 1)
             self.assertEqual(uset.lookups_in, 1)
@@ -2428,16 +2364,9 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(self.called_callback, 2)
         self.assertEqual(dom.matchs, 1)
 
-        # Shows the coap cache
-        with tempfile.TemporaryFile() as file, stdout_redirected(file):
-            self.stack.show_cache("coap")
-            file.seek(0)
-            total_lines = len(file.readlines())
-            self.assertEqual(total_lines, 2)
-
-        cache = self.stack.get_cache("coap")
+        data_cache = self.stack.get_cache_data("coap", "host")
         c1 = {'localhost': 1}
-        self.assertDictEqual(cache, c1)
+        self.assertDictEqual(data_cache, c1)
 
     def test66(self):
         """ Verify that a Regex that matchs with a URI could handle the link
@@ -2470,7 +2399,7 @@ class StackLanTests(unittest.TestCase):
         rman1 = pyaiengine.RegexManager([reg1])
         rman2 = pyaiengine.RegexManager([reg2])
 
-        #  Link to the DomainName d to the RegexManager for analise the uris
+        # Link to the DomainName d to the RegexManager for analise the uris
         dom.http_uri_regex_manager = rman1
 
         """ Link to the Regex another RegexManager """
@@ -2484,7 +2413,7 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(dom.matchs, 1)
 
     def test67(self):
-        """ Verify that using the label for inject python code """
+        """Verify that using the label for inject python code."""
 
         def domain_callback(flow):
             """ The code is executed on other time """
@@ -2497,27 +2426,27 @@ class StackLanTests(unittest.TestCase):
             flow.label = "flow.label=\"Hi change me!\""
             self.called_callback += 1
 
-        im = pyaiengine.IPSetManager()
+        iman = pyaiengine.IPSetManager()
         ipset = pyaiengine.IPSet("Generic set", ["74.125.24.99"], ipset_callback)
-        d = pyaiengine.DomainName("All HTTP", ".google.com", domain_callback)
+        dom = pyaiengine.DomainName("All HTTP", ".google.com", domain_callback)
 
-        im.add_ip_set(ipset)
-        self.stack.tcp_ip_set_manager = im
+        iman.add_ip_set(ipset)
+        self.stack.tcp_ip_set_manager = iman
 
-        dm = pyaiengine.DomainNameManager()
-        dm.add_domain_name(d)
+        dman = pyaiengine.DomainNameManager()
+        dman.add_domain_name(dom)
 
-        self.stack.set_domain_name_manager(dm, "HTTP")
+        self.stack.set_domain_name_manager(dman, "HTTP")
 
         self.inject("../pcapfiles/accessgoogle.pcap")
 
         self.assertEqual(self.called_callback, 2)
-        self.assertEqual(d.matchs, 1)
+        self.assertEqual(dom.matchs, 1)
 
     def test68(self):
-        """ Verify on SMTP access to mail data with regex """
+        """Verify on SMTP access to mail data with regex."""
 
-        def domain_callback(flow):
+        def domain_callback(_):
             self.called_callback += 1
 
         def regex1_callback(flow):
@@ -2527,33 +2456,33 @@ class StackLanTests(unittest.TestCase):
                 cad += str(chr(i))
             self.assertGreater(cad.find("GCC"), 1000)
 
-        def regex2_callback(flow):
+        def regex2_callback(_):
             self.called_callback += 1
 
-        rm = pyaiengine.RegexManager()
-        r1 = pyaiengine.Regex("Some r1", "^.*GCC.*$", regex1_callback)
-        r2 = pyaiengine.Regex("Some r2", "^.*(NextPart_000_0004_01CA45B0.095693F0).*$", \
+        rman = pyaiengine.RegexManager()
+        reg1 = pyaiengine.Regex("Some r1", "^.*GCC.*$", regex1_callback)
+        reg2 = pyaiengine.Regex("Some r2", "^.*(NextPart_000_0004_01CA45B0.095693F0).*$", \
             regex2_callback)
-        d = pyaiengine.DomainName("Some SMTP traffic", ".patriots.in", domain_callback)
+        dom = pyaiengine.DomainName("Some SMTP traffic", ".patriots.in", domain_callback)
 
-        rm.add_regex(r1)
+        rman.add_regex(reg1)
 
-        r1.next_regex = r2
-        d.regex_manager = rm
-        dm = pyaiengine.DomainNameManager()
-        dm.add_domain_name(d)
+        reg1.next_regex = reg2
+        dom.regex_manager = rman
+        dman = pyaiengine.DomainNameManager()
+        dman.add_domain_name(dom)
 
-        self.stack.set_domain_name_manager(dm, "SMTP")
+        self.stack.set_domain_name_manager(dman, "SMTP")
 
         self.inject("../pcapfiles/smtp.pcap")
 
         self.assertEqual(self.called_callback, 3)
-        self.assertEqual(d.matchs, 1)
-        self.assertEqual(r1.matchs, 1)
-        self.assertEqual(r2.matchs, 1)
+        self.assertEqual(dom.matchs, 1)
+        self.assertEqual(reg1.matchs, 1)
+        self.assertEqual(reg2.matchs, 1)
 
     def test69(self):
-        """ Verify that the data of SSH is correct """
+        """Verify that the data of SSH is correct."""
 
         self.stack.enable_protocol("ssh")
 
@@ -2574,7 +2503,7 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(len(self.stack.udp_flow_manager), 0)
 
     def test70(self):
-        """ Verify the quic traffic funcionality """
+        """Verify the quic traffic funcionality."""
 
         self.stack.enable_protocol("quic")
 
@@ -2596,21 +2525,21 @@ class StackLanTests(unittest.TestCase):
         self.assertEqual(len(self.stack.udp_flow_manager), 1)
 
     def test71(self):
-        """ Verify the quic traffic funcionality with domain names """
+        """Verify the quic traffic funcionality with domain names."""
 
         def quic_callback(flow):
             self.called_callback += 1
-            self.assertEqual(flow.quic_info.matched_domain_name, d)
+            self.assertEqual(flow.quic_info.matched_domain_name, dom)
             self.assertEqual(flow.quic_info.host_name, "ad-emea.doubleclick.net")
             self.assertEqual(flow.quic_info.user_agent, "Chrome/52.0.2743.116 Linux x86_64")
 
-        d = pyaiengine.DomainName("Test", ".doubleclick.net")
-        d.callback = quic_callback
+        dom = pyaiengine.DomainName("Test", ".doubleclick.net")
+        dom.callback = quic_callback
 
-        dm = pyaiengine.DomainNameManager()
-        dm.add_domain_name(d)
+        dman = pyaiengine.DomainNameManager()
+        dman.add_domain_name(dom)
 
-        self.stack.set_domain_name_manager(dm, "QuicProtocol")
+        self.stack.set_domain_name_manager(dman, "QuicProtocol")
 
         self.inject("../pcapfiles/quic.pcap")
 
@@ -2632,129 +2561,379 @@ class StackLanTests(unittest.TestCase):
         else:
             self.assertTrue(False)
 
-        self.assertEqual(len(self.stack.tcp_flow_manager), 2)
+        tcp_flows = self.stack.tcp_flow_manager
+        self.assertEqual(len(tcp_flows), 2)
 
         host = "gw.alicdn.com"
-        for f in self.stack.tcp_flow_manager:
-            self.assertEqual(session_id, f.ssl_info.session_id)
-            self.assertEqual(host, f.ssl_info.server_name)
+        for flow in tcp_flows:
+            self.assertEqual(session_id, flow.ssl_info.session_id)
+            self.assertEqual(host, flow.ssl_info.server_name)
 
-class StackMobileTests(unittest.TestCase):
+        total = [flow for flow in tcp_flows if flow.http_info]
+        self.assertEqual(len(total), 0)
 
-    def setUp(self):
-        self.stack = pyaiengine.StackMobile()
-        self.pdis = pyaiengine.PacketDispatcher()
-        self.pdis.stack = self.stack
-        self.stack.tcp_flows = 2048
-        self.stack.udp_flows = 1024
-        self.called_callback = 0
+        total = [flow for flow in tcp_flows if flow.dns_info]
+        self.assertEqual(len(total), 0)
 
-    def tearDown(self):
-        pass
+        total = [flow for flow in tcp_flows if flow.ssl_info]
+        self.assertEqual(len(total), 2)
 
-    def inject(self, pcapfile):
-        with pyaiengine.PacketDispatcher(pcapfile) as pdis:
-            pdis.stack = self.stack
-            pdis.run()
+    def test73(self):
+        """Verify the retrieval of the interal caches with preallocated flows"""
 
-    def test01(self):
-        """ Verify the integrity of the sip fields """
+        self.inject("../pcapfiles/two_http_flows_noending.pcap")
 
-        adaptor = DatabaseTestAdaptor()
+        cache = self.stack.get_cache("http", "host")
 
-        self.stack.set_udp_database_adaptor(adaptor)
+        self.assertIsNotNone(cache)
+        self.assertEqual(cache.total_items, 1534)
+        self.assertEqual(cache.total_acquires, 2)
+        self.assertEqual(cache.total_releases, 0)
+        self.assertEqual(cache.total_fails, 0)
 
-        self.inject("../pcapfiles/gprs_sip_flow.pcap")
+        cache.destroy(1000)
 
-        for flow in self.stack.udp_flow_manager:
-            self.assertEqual(flow.mqtt_info, None)
-            self.assertEqual(flow.coap_info, None)
-            self.assertEqual(flow.http_info, None)
-            self.assertEqual(flow.dns_info, None)
-            self.assertEqual(flow.ssl_info, None)
-            self.assertNotEqual(flow.sip_info, None)
-            self.assertEqual(flow.sip_info.from_name, \
-                "\"User1\" <sip:ng40user1@apn.sip.voice.ng4t.com>;tag=690711")
-            self.assertEqual(flow.sip_info.to_name, \
-               "\"User1\" <sip:ng40user1@apn.sip.voice.ng4t.com>")
-            self.assertEqual(flow.sip_info.uri, "sip:10.255.1.111:5090")
-            self.assertEqual(flow.sip_info.via, \
-                "SIP/2.0/UDP 10.255.1.1:5090;branch=z9hG4bK199817980098801998")
+        self.assertEqual(cache.total_items, 534)
+        self.assertEqual(cache.total_acquires, 2)
+        self.assertEqual(cache.total_releases, 0)
+        self.assertEqual(cache.total_fails, 0)
 
-        data = json.loads(adaptor.lastdata)
-        counters = self.stack.get_counters("SIPProtocol")
-        self.assertEqual(counters["requests"], 7)
-        self.assertEqual(counters["responses"], 7)
-        self.assertEqual(counters["registers"], 2)
+        # Verify the output of the cache
+        with tempfile.TemporaryFile() as file, stdout_redirected(file):
+            cache.show()
 
-        if "sip" in data:
-            self.assertEqual(data["sip"]["uri"], "sip:apn.sip.voice.ng4t.com")
-            self.assertEqual(data["sip"]["from"], \
-                "\"User1\" <sip:ng40user1@apn.sip.voice.ng4t.com>;tag=690711")
-            self.assertEqual(data["sip"]["to"], \
-                "\"User1\" <sip:ng40user1@apn.sip.voice.ng4t.com>")
-            self.assertEqual(data["sip"]["via"], \
-                "SIP/2.0/UDP 10.255.1.1:5090;branch=z9hG4bK199817980098801998")
-        else:
-            self.assertTrue(False)
+        cache = self.stack.get_cache("http", "dontexist")
 
-        cache = self.stack.get_cache("SIP")
+        self.assertIsNone(cache)
 
-        cache1 = {'sip:10.255.1.111:5090': 2, 'sip:apn.sip.voice.ng4t.com': 4, 
-                  'sip:ng40user11@apn.sip.voice.ng4t.com': 1}
+    def test74(self):
+        """Verify the retrieval of the interal caches with preallocated flows"""
 
-        self.assertDictEqual(cache, cache1)
+        cache_host = self.stack.get_cache("ssl", "host")
+        self.assertIsNotNone(cache_host)
+        cache_host.destroy(cache_host.total_items)
+
+        cache_session = self.stack.get_cache("ssl", "session")
+        self.assertIsNotNone(cache_session)
+        cache_session.destroy(cache_session.total_items)
+
+        self.inject("../pcapfiles/alibaba.pcap")
+        for flow in self.stack.tcp_flow_manager:
+            self.assertEqual("", flow.ssl_info.session_id)
+            self.assertEqual("", flow.ssl_info.server_name)
+            self.assertEqual("", flow.ssl_info.issuer_name)
 
-        """ print the output of the cache """
+        # Verify the output of the cache
         with tempfile.TemporaryFile() as file, stdout_redirected(file):
-            self.stack.show_cache("SIP")
-            file.seek(0)
-            total_lines = len(file.readlines())
-            self.assertEqual(total_lines, 4)
+            cache_host.show()
+            cache_session.show()
 
-        self.stack.release_cache("SIPProtocol")
+        cache = self.stack.get_cache("ssl", "dontexist")
+
+        self.assertIsNone(cache)
+
+    def test75(self):
+        """Verify the retrieval of the internal coap caches,"""
+
+        cache_host = self.stack.get_cache("coap", "host")
+        self.assertIsNotNone(cache_host)
+        cache_host.destroy(cache_host.total_items)
+
+        cache_uri = self.stack.get_cache("coap", "uri")
+        self.assertIsNotNone(cache_uri)
+        cache_uri.destroy(cache_uri.total_items)
+
+        self.inject("../pcapfiles/ipv4_coap.pcap")
+
+        cache_host.dynamic_allocated_memory = True
+        cache_uri.dynamic_allocated_memory = True
+        self.stack.udp_flow_manager.flush()
+
+        self.assertEqual(self.stack.tcp_flow_manager.flows, 0)
+        self.assertEqual(self.stack.udp_flow_manager.flows, 0)
+
+        self.inject("../pcapfiles/ipv4_coap.pcap")
+
+        self.assertEqual(self.stack.udp_flow_manager.flows, 1)
+        for flow in self.stack.udp_flow_manager:
+            self.assertEqual("", flow.coap_info.host_name)
+            self.assertEqual("/1/1/768/core.power", flow.coap_info.uri)
+
+    def test76(self):
+        """Verify the retrieval of the internal SSH caches."""
+
+        cache_name = self.stack.get_cache("ssh", "name")
+        self.assertIsNotNone(cache_name)
+        cache_name.destroy(cache_name.total_items)
+
+        self.stack.enable_protocol("ssh")
+
+        adaptor = DatabaseTestAdaptor()
+        self.stack.set_tcp_database_adaptor(adaptor, 1)
+
+        self.inject("../pcapfiles/ssh_flow.pcap")
+
+        data = json.loads(adaptor.lastdata)
+        # print(json.dumps(d,sort_keys=True,indent=4, separators=(',', ': ')))
+        if "ssh" in data:
+            self.assertNotIn("clientname", data["ssh"])
+            self.assertNotIn("servername", data["ssh"])
+        else:
+            self.assertTrue(False)
+
+        self.assertEqual(len(self.stack.tcp_flow_manager), 1)
+        self.assertEqual(len(self.stack.udp_flow_manager), 0)
+
+    def test77(self):
+        """Verify the retrieval of the internal SSDP caches."""
+
+        cache_host = self.stack.get_cache("ssdp", "host")
+        self.assertIsNotNone(cache_host)
+        cache_host.destroy(cache_host.total_items)
+        
+        cache_uri = self.stack.get_cache("ssdp", "uri")
+        self.assertIsNotNone(cache_uri)
+        cache_uri.destroy(cache_uri.total_items)
+
+        self.inject("../pcapfiles/ssdp_flow.pcap")
+
+        # show the caches
+        with tempfile.TemporaryFile() as file, stdout_redirected(file):
+            cache_host.show()
+            cache_uri.show()
+
+        for flow in self.stack.udp_flow_manager:
+            self.assertNotEqual(flow.ssdp_info, None)
+            self.assertEqual(flow.ssdp_info.host_name, "")
+
+    def test78(self):
+        """Verify the retrieval of the internal IMAP cache."""
+
+        def imap_callback(flow):
+            # Nothing to retrieve there is no memory on the
+            # cache allocated
+            self.assertEqual(flow.imap_info.user_name, "")
+            self.called_callback += 1
+
+        dman = pyaiengine.DomainNameManager()
+        dom = pyaiengine.DomainName("No trusted domain", "*", imap_callback)
+
+        dman.add_domain_name(dom)
+
+        self.stack.set_domain_name_manager(dman, "imap")
+        self.stack.set_dynamic_allocated_memory(True)
+
+        cache_user = self.stack.get_cache("imap", "user")
+        self.assertIsNotNone(cache_user)
+        cache_user.destroy(cache_user.total_items)
+        cache_user.dynamic_allocated_memory = False
+
+        self.inject("../pcapfiles/imap_flow.pcap")
+
+        counters = self.stack.get_counters("imap")
+
+        self.assertEqual(counters["commands"], 6)
+        self.assertEqual(counters["responses"], 12)
+        self.assertEqual(self.called_callback, 1)
+
+    def test79(self):
+        """Verify the retrieval of the netbios internal cache."""
+
+        self.stack.link_layer_tag = "vlan"
+
+        cache = self.stack.get_cache("netbios", "name")
+        self.assertIsNotNone(cache)
+        cache.destroy(cache.total_items)
+
+        self.inject("../pcapfiles/flow_vlan_netbios.pcap")
+
+        cache = self.stack.get_cache_data("netbios", "name")
+        self.assertEqual(cache, {})
+
+    def test80(self):
+        """Verify the get of the pop internal cache object."""
+
+        def pop_callback(flow):
+            _ = flow.pop_info
+            self.assertIsNotNone(flow.pop_info)
+            # Nothing to retrieve there is no memory on the
+            # cache allocated
+            self.assertEqual(flow.pop_info.user_name, "")
+            self.called_callback += 1
+
+        dman = pyaiengine.DomainNameManager()
+        dom = pyaiengine.DomainName("No trusted domain", "*", pop_callback)
+
+        dman.add_domain_name(dom)
+
+        self.stack.set_domain_name_manager(dman, "pop")
+
+        cache = self.stack.get_cache("pop", "user")
+        self.assertIsNotNone(cache)
+        cache.destroy(cache.total_items)
+
+        self.inject("../pcapfiles/pop_flow.pcap")
+
+        counters = self.stack.get_counters("pop")
+
+        self.assertEqual(counters["commands"], 15)
+        self.assertEqual(counters["responses"], 16)
+        self.assertEqual(self.called_callback, 1)
+
+    def test81(self):
+        """Verify the retrieval of the smb internal cache."""
+
+        cache = self.stack.get_cache("SMBProtocol", "filename")
+        self.assertIsNotNone(cache)
+        cache.destroy(cache.total_items)
+
+        self.inject("../pcapfiles/smb_flow.pcap")
+
+        counters = self.stack.get_counters("smb")
+
+        self.assertEqual(counters["create files"], 8)
+        
+        for flow in self.stack.tcp_flow_manager:
+            self.assertEqual(flow.smb_info.filename, "")
+
+    def test82(self):
+        """Retrive the internal smtp cache."""
+
+        def domain_callback(flow):
+            self.assertEqual(flow.smtp_info.mail_from, "")
+            self.assertEqual(flow.smtp_info.mail_to, "")
+            self.called_callback += 1
+
+        dom = pyaiengine.DomainName("Some SMTP traffic", ".patriots.in", domain_callback)
+
+        dman = pyaiengine.DomainNameManager()
+        dman.add_domain_name(dom)
+
+        self.stack.set_domain_name_manager(dman, "SMTP")
+
+        cache_from = self.stack.get_cache("smtp", "from")
+        self.assertIsNotNone(cache_from)
+        cache_from.destroy(cache_from.total_items)
+        cache_from.dynamic_allocated_memory = False
+
+        self.inject("../pcapfiles/smtp.pcap")
+
+        self.assertEqual(dom.matchs, 1)
+
+class StackMobileTests(unittest.TestCase):
+    """This class handles the test cases for mobile enviroments
+    such as GPRS, GTP tunneling."""
+
+    def setUp(self):
+        self.stack = pyaiengine.StackMobile()
+        self.pdis = pyaiengine.PacketDispatcher()
+        self.pdis.stack = self.stack
+        self.stack.tcp_flows = 2048
+        self.stack.udp_flows = 1024
+        self.called_callback = 0
+
+    def tearDown(self):
+        pass
+
+    def inject(self, pcapfile):
+        """Method for process the pcapfile."""
+
+        with pyaiengine.PacketDispatcher(pcapfile) as pdis:
+            pdis.stack = self.stack
+            pdis.run()
+
+    def test01(self):
+        """Verify the integrity of the sip fields."""
+
+        adaptor = DatabaseTestAdaptor()
+
+        self.stack.set_udp_database_adaptor(adaptor)
+
+        self.inject("../pcapfiles/gprs_sip_flow.pcap")
+
+        for flow in self.stack.udp_flow_manager:
+            self.assertEqual(flow.mqtt_info, None)
+            self.assertEqual(flow.coap_info, None)
+            self.assertEqual(flow.http_info, None)
+            self.assertEqual(flow.dns_info, None)
+            self.assertEqual(flow.ssl_info, None)
+            self.assertNotEqual(flow.sip_info, None)
+            self.assertEqual(flow.sip_info.from_name, \
+                "\"User1\" <sip:ng40user1@apn.sip.voice.ng4t.com>;tag=690711")
+            self.assertEqual(flow.sip_info.to_name, \
+               "\"User1\" <sip:ng40user1@apn.sip.voice.ng4t.com>")
+            self.assertEqual(flow.sip_info.uri, "sip:10.255.1.111:5090")
+            self.assertEqual(flow.sip_info.via, \
+                "SIP/2.0/UDP 10.255.1.1:5090;branch=z9hG4bK199817980098801998")
+
+        data = json.loads(adaptor.lastdata)
+        counters = self.stack.get_counters("SIPProtocol")
+        self.assertEqual(counters["requests"], 7)
+        self.assertEqual(counters["responses"], 7)
+        self.assertEqual(counters["registers"], 2)
+
+        if "sip" in data:
+            self.assertEqual(data["sip"]["uri"], "sip:apn.sip.voice.ng4t.com")
+            self.assertEqual(data["sip"]["from"], \
+                "\"User1\" <sip:ng40user1@apn.sip.voice.ng4t.com>;tag=690711")
+            self.assertEqual(data["sip"]["to"], \
+                "\"User1\" <sip:ng40user1@apn.sip.voice.ng4t.com>")
+            self.assertEqual(data["sip"]["via"], \
+                "SIP/2.0/UDP 10.255.1.1:5090;branch=z9hG4bK199817980098801998")
+        else:
+            self.assertTrue(False)
+
+        data_cache = self.stack.get_cache_data("SIP", "uri")
+
+        cache1 = {'sip:10.255.1.111:5090': 2, 'sip:apn.sip.voice.ng4t.com': 4,
+                  'sip:ng40user11@apn.sip.voice.ng4t.com': 1}
+
+        self.assertDictEqual(data_cache, cache1)
+
+        self.stack.release_cache("SIPProtocol")
 
         for flow in self.stack.udp_flow_manager:
             self.assertEqual(flow.sip_info, None)
 
     def test02(self):
-        """ Test some regex on the mobile stack """
+        """Test some regex on the mobile stack."""
 
-        rm = pyaiengine.RegexManager()
-        r1 = pyaiengine.Regex("r1", b"^\\x58\\x67\\x77\\x86.*$")
-        r2 = pyaiengine.Regex("r2", b"^.*\\xde\\xed\\xfc\\x0c.*$")
+        rman = pyaiengine.RegexManager()
+        reg1 = pyaiengine.Regex("r1", b"^\\x58\\x67\\x77\\x86.*$")
+        reg2 = pyaiengine.Regex("r2", b"^.*\\xde\\xed\\xfc\\x0c.*$")
 
-        rm.add_regex(r1)
+        rman.add_regex(reg1)
 
-        r1.next_regex = r2
+        reg1.next_regex = reg2
 
-        self.assertEqual(sys.getrefcount(r2), 3)
+        self.assertEqual(sys.getrefcount(reg2), 3)
 
-        self.stack.tcp_regex_manager = rm
+        self.stack.tcp_regex_manager = rman
 
         self.inject("../pcapfiles/gprs_ftp.pcap")
 
-        self.assertEqual(r1.matchs, 1)
-        self.assertEqual(r2.matchs, 1)
+        self.assertEqual(reg1.matchs, 1)
+        self.assertEqual(reg2.matchs, 1)
 
         ft = self.stack.tcp_flow_manager
         self.assertEqual(len(ft), 1)
         ft.flush()
         self.assertEqual(len(ft), 0)
 
-        """ Unset the next regex of r1 """
-        r1.next_regex = None
-        self.assertEqual(sys.getrefcount(r2), 2)
+        # Unset the next regex of reg1
+        reg1.next_regex = None
+        self.assertEqual(sys.getrefcount(reg2), 2)
 
         self.inject("../pcapfiles/gprs_ftp.pcap")
 
-        self.assertEqual(r1.matchs, 2)
-        self.assertEqual(r2.matchs, 1)
-        self.assertEqual(r1.next_regex, None)
-        self.assertEqual(r2.next_regex, None)
+        self.assertEqual(reg1.matchs, 2)
+        self.assertEqual(reg2.matchs, 1)
+        self.assertEqual(reg1.next_regex, None)
+        self.assertEqual(reg2.next_regex, None)
 
     def test03(self):
         """ Tests the database adaptor on tcp and callbacks on regex """
+
         def callback1(flow):
             self.called_callback += 1
             self.assertNotEqual(flow.regex, None)
@@ -2822,7 +3001,36 @@ class StackMobileTests(unittest.TestCase):
         self.assertEqual(counters["packets"], 22)
         self.assertEqual(counters["bytes"], 14537)
 
+    def test05(self):
+        """Verify the integrity of the sip internal caches."""
+
+        # Remove all the memory for store uris
+        cache = self.stack.get_cache("SIPProtocol", "uri")
+        cache.destroy(cache.total_items)
+
+        # Remove all the memory for store froms
+        cache = self.stack.get_cache("SIPProtocol", "from")
+        cache.destroy(cache.total_items)
+
+        # Remove all the memory for store tos
+        cache = self.stack.get_cache("SIPProtocol", "to")
+        cache.destroy(cache.total_items)
+
+        # Remove all the memory for store vias
+        cache = self.stack.get_cache("SIPProtocol", "via")
+        cache.destroy(cache.total_items)
+
+        self.inject("../pcapfiles/gprs_sip_flow.pcap")
+
+        for flow in self.stack.udp_flow_manager:
+            self.assertNotEqual(flow.sip_info, None)
+            self.assertEqual(flow.sip_info.from_name, "")
+            self.assertEqual(flow.sip_info.to_name, "")
+            self.assertEqual(flow.sip_info.uri, "")
+            self.assertEqual(flow.sip_info.via, "")
+
 class StackLanIPv6Tests(unittest.TestCase):
+    """Class for handle the test cases related to IPv6."""
 
     def setUp(self):
         self.stack = pyaiengine.StackLanIPv6()
@@ -2836,25 +3044,43 @@ class StackLanIPv6Tests(unittest.TestCase):
         pass
 
     def inject(self, pcapfile):
+        """Method for process the pcapfile."""
         with pyaiengine.PacketDispatcher(pcapfile) as pdis:
             pdis.stack = self.stack
             pdis.run()
 
     def test01(self):
-        """ Create a regex for a generic exploit """
+        """Create a regex for a generic exploit."""
 
-        rm = pyaiengine.RegexManager()
-        r = pyaiengine.Regex("generic exploit", b"\\x90\\x90\\x90\\x90\\x90\\x90\\x90")
-        rm.add_regex(r)
-        self.stack.tcp_regex_manager = rm
+        rman = pyaiengine.RegexManager()
+        reg = pyaiengine.Regex("generic exploit", b"\\x90\\x90\\x90\\x90\\x90\\x90\\x90")
+        rman.add_regex(reg)
+        self.stack.tcp_regex_manager = rman
 
         self.inject("../pcapfiles/generic_exploit_ipv6_defcon20.pcap")
 
-        self.assertEqual(r.matchs, 1)
+        self.assertEqual(reg.matchs, 1)
 
     def test02(self):
-        """ Create a regex for a generic exploit and a IPSet """
+        """Create a regex for a generic exploit and a IPSet."""
+
         def ipset_callback(flow):
+            self.assertIsNotNone(flow)
+
+            # Check some TCP Flags
+            # Bear in mind that the ipsets are trigger
+            # on the first packet
+            tcp = flow.tcp_info
+            self.assertIsNotNone(tcp)
+            self.assertEqual(tcp.syns, 1)
+            self.assertEqual(tcp.synacks, 0)
+            self.assertEqual(tcp.synacks, 0)
+            self.assertEqual(tcp.acks, 0)
+            self.assertEqual(tcp.fins, 0)
+            self.assertEqual(tcp.rsts, 0)
+            self.assertEqual(tcp.pushs, 0)
+            self.assertEqual(tcp.state, "SYN_SENT")
+
             self.called_callback += 1
 
         ipset = pyaiengine.IPSet("IPv6 generic set", ["dc20:c7f:2012:11::2", "dc20:c7f:2012:11::1"])
@@ -2864,56 +3090,58 @@ class StackLanIPv6Tests(unittest.TestCase):
         ipset.callback = ipset_callback
         im = pyaiengine.IPSetManager()
 
-        """ There is only three valid IP address """
+        # There is only three valid IP address 
         self.assertEqual(len(ipset), 3)
 
         im.add_ip_set(ipset)
         self.stack.tcp_ip_set_manager = im
 
-        rm = pyaiengine.RegexManager()
-        r1 = pyaiengine.Regex("generic exploit", b"\\x90\\x90\\x90\\x90\\x90\\x90\\x90")
-        rm.add_regex(r1)
-        r2 = pyaiengine.Regex("other exploit", "(this can not match)")
-        rm.add_regex(r2)
-        self.stack.tcp_regex_manager = rm
+        rman = pyaiengine.RegexManager()
+        reg1 = pyaiengine.Regex("generic exploit", b"\\x90\\x90\\x90\\x90\\x90\\x90\\x90")
+        rman.add_regex(reg1)
+        reg2 = pyaiengine.Regex("other exploit", "(this can not match)")
+        rman.add_regex(reg2)
+        self.stack.tcp_regex_manager = rman
 
         self.inject("../pcapfiles/generic_exploit_ipv6_defcon20.pcap")
 
-        self.assertEqual(r1.matchs, 1)
-        self.assertEqual(r2.matchs, 0)
+        self.assertEqual(reg1.matchs, 1)
+        self.assertEqual(reg2.matchs, 0)
         self.assertEqual(self.called_callback, 1)
 
         ipset.remove_ip_address("dc20:c7f:2012:11::2")
 
     def test03(self):
-        """ Create a regex for a generic exploit and a IPSet with no matching"""
+        """Create a regex for a generic exploit and a IPSet with no matching."""
+
         def ipset_callback(flow):
+            self.assertIsNotNone(flow)
             self.called_callback += 1
 
         ips = ["dc20:c7f:2012:11::22", "dc20:c7f:2012:11::1"]
 
         ipset = pyaiengine.IPSet(ips)
         ipset.callback = ipset_callback
-        im = pyaiengine.IPSetManager()
+        iman = pyaiengine.IPSetManager()
 
-        im.add_ip_set(ipset)
-        self.stack.tcp_ip_set_manager = im
+        iman.add_ip_set(ipset)
+        self.stack.tcp_ip_set_manager = iman
 
-        rm = pyaiengine.RegexManager()
-        r1 = pyaiengine.Regex("generic exploit", b"\\xaa\\xbb\\xcc\\xdd\\x90\\x90\\x90")
-        rm.add_regex(r1)
-        r2 = pyaiengine.Regex("other exploit", "(this can not match)")
-        rm.add_regex(r2)
-        self.stack.tcp_regex_manager = rm
+        rman = pyaiengine.RegexManager()
+        reg1 = pyaiengine.Regex("generic exploit", b"\\xaa\\xbb\\xcc\\xdd\\x90\\x90\\x90")
+        rman.add_regex(reg1)
+        reg2 = pyaiengine.Regex("other exploit", "(this can not match)")
+        rman.add_regex(reg2)
+        self.stack.tcp_regex_manager = rman
 
         self.inject("../pcapfiles/generic_exploit_ipv6_defcon20.pcap")
 
-        self.assertEqual(r1.matchs, 0)
-        self.assertEqual(r2.matchs, 0)
+        self.assertEqual(reg1.matchs, 0)
+        self.assertEqual(reg2.matchs, 0)
         self.assertEqual(self.called_callback, 0)
 
     def test04(self):
-        """ Attach a database to the engine for TCP traffic """
+        """Attach a database to the engine for TCP traffic."""
 
         dbaux = DatabaseTestAdaptor()
         adaptor = DatabaseTestAdaptor()
@@ -2938,7 +3166,7 @@ class StackLanIPv6Tests(unittest.TestCase):
         # self.assertEqual(sys.getrefcount(adaptor), 2)
 
     def test05(self):
-        """ Attach a database to the engine for UDP traffic """
+        """Attach a database to the engine for UDP traffic."""
 
         db_udp = DatabaseTestAdaptor()
         db_tcp = DatabaseTestAdaptor()
@@ -2957,55 +3185,62 @@ class StackLanIPv6Tests(unittest.TestCase):
         self.assertEqual(db_tcp.total_removes, 0)
 
     def test06(self):
-        """ Several IPSets with no matching"""
+        """Several IPSets with no matching."""
+
         def ipset_callback(flow):
+            self.assertIsNotNone(flow)
             self.called_callback += 1
 
         ipset1 = pyaiengine.IPSet("IPSet 1", ["dcbb:c7f:2012:11::22"])
         ipset2 = pyaiengine.IPSet("IPSet 2", ["dcaa:c7f:2012:11::22"])
         ipset3 = pyaiengine.IPSet("IPSet 3", ["dc20:c7f:2012:11::2"])
 
-        im = pyaiengine.IPSetManager()
+        iman = pyaiengine.IPSetManager()
 
-        im.add_ip_set(ipset1)
-        im.add_ip_set(ipset2)
-        im.add_ip_set(ipset3)
+        iman.add_ip_set(ipset1)
+        iman.add_ip_set(ipset2)
+        iman.add_ip_set(ipset3)
 
-        self.stack.tcp_ip_set_manager = im
+        self.stack.tcp_ip_set_manager = iman
 
         self.inject("../pcapfiles/generic_exploit_ipv6_defcon20.pcap")
 
-        self.assertEqual(len(im), 3)
+        self.assertEqual(len(iman), 3)
         self.assertEqual(self.called_callback, 0)
-        self.assertEqual(self.stack.tcp_ip_set_manager, im)
+        self.assertEqual(self.stack.tcp_ip_set_manager, iman)
 
     def test07(self):
-        """ Extract IPv6 address from a DomainName matched and IPSet functionality """
+        """Extract IPv6 address from a DomainName matched and IPSet functionality."""
+
         def dns_callback(flow):
             for ip in flow.dns_info:
                 if ip == "2607:f8b0:4001:c05::6a":
                     self.called_callback += 1
-            self.assertEqual(flow.dns_info.matched_domain_name, d)
+            self.assertEqual(flow.dns_info.matched_domain_name, dom)
             self.assertEqual(flow.dns_info.query_type, 28)
 
+            # This flow is UDP so no tcp info on the flow
+            self.assertIsNone(flow.tcp_info)
+
         def ipset_callback(flow):
+            self.assertIsNotNone(flow)
             self.called_callback += 1
 
-        d = pyaiengine.DomainName("Google test", ".google.com")
-        d.callback = dns_callback
+        dom = pyaiengine.DomainName("Google test", ".google.com")
+        dom.callback = dns_callback
 
-        dm = pyaiengine.DomainNameManager()
-        dm.add_domain_name(d)
+        dman = pyaiengine.DomainNameManager()
+        dman.add_domain_name(dom)
 
         ipset1 = pyaiengine.IPSet("IPSet 1", ["2001:abcd::1"], ipset_callback)
 
-        im = pyaiengine.IPSetManager()
-        im.add_ip_set(ipset1)
+        iman = pyaiengine.IPSetManager()
+        iman.add_ip_set(ipset1)
 
-        self.stack.udp_ip_set_manager = im
-        self.assertEqual(self.stack.udp_ip_set_manager, im)
+        self.stack.udp_ip_set_manager = iman
+        self.assertEqual(self.stack.udp_ip_set_manager, iman)
 
-        self.stack.set_domain_name_manager(dm, "dns")
+        self.stack.set_domain_name_manager(dman, "dns")
 
         self.inject("../pcapfiles/ipv6_google_dns.pcap")
 
@@ -3014,20 +3249,20 @@ class StackLanIPv6Tests(unittest.TestCase):
         self.assertEqual(ipset1.lookups_out, 0)
         self.assertEqual(self.called_callback, 2)
 
-        """ Verify some of the counters of the dns protocol """
+        # Verify some of the counters of the dns protocol
 
-        c = self.stack.get_counters("dns")
-        self.assertEqual(c["queries"], 1)
-        self.assertEqual(c["allow queries"], 1)
-        self.assertEqual(c["banned queries"], 0)
-        self.assertEqual(c["responses"], 1)
-        self.assertEqual(c["type AAAA"], 1)
+        counters = self.stack.get_counters("dns")
+        self.assertEqual(counters["queries"], 1)
+        self.assertEqual(counters["allow queries"], 1)
+        self.assertEqual(counters["banned queries"], 0)
+        self.assertEqual(counters["responses"], 1)
+        self.assertEqual(counters["type AAAA"], 1)
 
-        for i in im:
-            a = i
+        for ipset in iman:
+            _ = ipset
 
     def test08(self):
-        """ Test the functionality of make graphs of regex, for complex detecctions """
+        """Test the functionality of make graphs of regex, for complex detecctions."""
 
         rmbase = pyaiengine.RegexManager()
         rman2 = pyaiengine.RegexManager()
@@ -3091,37 +3326,40 @@ class StackLanIPv6Tests(unittest.TestCase):
         self.assertEqual(reg4.matchs, 1)
 
     def test10(self):
-        """ Verify the functionality of the getCache method """
+        """ Verify the functionality of the get_cache_data method """
 
         self.inject("../pcapfiles/ipv6_google_dns.pcap")
 
-        d = self.stack.get_cache("DNSProtocol")
-        self.assertEqual(len(self.stack.get_cache("DNSProtocol")), 1)
-        self.assertEqual(len(self.stack.get_cache("DNSProtocolNoExists")), 0)
+        data = self.stack.get_cache_data("DNSProtocol", "name")
+        self.assertEqual(len(self.stack.get_cache_data("DNSProtocol", "name")), 1)
+        self.assertEqual(len(self.stack.get_cache_data("DNSProtocolNoExists", "name")), 0)
         self.stack.release_cache("DNSProtocol")
-        self.assertEqual(len(self.stack.get_cache("DNSProtocol")), 0)
-        self.assertEqual(len(self.stack.get_cache("HTTPProtocol")), 0)
-        self.assertEqual(len(self.stack.get_cache("SSLProtocol")), 0)
+        self.assertEqual(len(self.stack.get_cache_data("DNSProtocol", "name")), 0)
+        self.assertEqual(len(self.stack.get_cache_data("HTTPProtocol", "host")), 0)
+        self.assertEqual(len(self.stack.get_cache_data("SSLProtocol", "host")), 0)
 
-        self.assertIsNotNone(d["www.google.com"])
+        self.assertIsNotNone(data["www.google.com"])
 
     def test11(self):
         """ Verify the correctness of the HTTP Protocol on IPv6 """
 
         self.inject("../pcapfiles/http_over_ipv6.pcap")
 
-        c = self.stack.get_counters("HTTPProtocol")
-        self.assertEqual(c["requests"], 11)
-        self.assertEqual(c["responses"], 11)
+        counters = self.stack.get_counters("HTTPProtocol")
+        self.assertEqual(counters["requests"], 11)
+        self.assertEqual(counters["responses"], 11)
 
-        d = self.stack.get_cache("http")
-        self.assertIsNotNone(d["media.us.listen.com"])
+        data = self.stack.get_cache_data("http", "host")
+        self.assertIsNotNone(data["media.us.listen.com"])
 
     def test12(self):
         """ Verify the functionality of the RegexManager on the HTTP Protocol for analise
             inside the l7 payload of HTTP on IPv6 traffic """
 
         def callback_domain(flow):
+            # These are the ttls when the domain rule is trigger
+            self.assertEqual(flow.upstream_ttl, 255)
+            self.assertEqual(flow.downstream_ttl, 236)
             self.called_callback += 1
 
         def callback_regex(flow):
@@ -3129,29 +3367,29 @@ class StackLanIPv6Tests(unittest.TestCase):
             self.assertEqual(flow.regex.name, "Regex for analysing the content of HTTP")
             self.assertEqual(flow.http_info.host_name, "media.us.listen.com")
 
-        d = pyaiengine.DomainName("Music domain", ".us.listen.com")
+        dom = pyaiengine.DomainName("Music domain", ".us.listen.com")
 
-        rm = pyaiengine.RegexManager()
-        r1 = pyaiengine.Regex("Regex for analysing the content of HTTP", \
+        rman = pyaiengine.RegexManager()
+        reg1 = pyaiengine.Regex("Regex for analysing the content of HTTP", \
             b"^\\x89\\x50\\x4e\\x47\\x0d\\x0a\\x1a\\x0a.*$")
 
-        rm.add_regex(r1)
-        r1.callback = callback_regex
+        rman.add_regex(reg1)
+        reg1.callback = callback_regex
 
-        """ So the flows from listen.com will be analise the regexmanager attached """
-        d.regex_manager = rm
+        # So the flows from listen.com will be analise the regexmanager attached
+        dom.regex_manager = rman
 
-        dm = pyaiengine.DomainNameManager()
-        d.callback = callback_domain
-        dm.add_domain_name(d)
+        dman = pyaiengine.DomainNameManager()
+        dom.callback = callback_domain
+        dman.add_domain_name(dom)
 
-        self.stack.set_domain_name_manager(dm, "HTTPProtocol")
+        self.stack.set_domain_name_manager(dman, "HTTPProtocol")
 
         self.inject("../pcapfiles/http_over_ipv6.pcap")
 
         self.assertEqual(self.called_callback, 2)
-        self.assertEqual(r1.matchs, 1)
-        self.assertEqual(d.matchs, 1)
+        self.assertEqual(reg1.matchs, 1)
+        self.assertEqual(dom.matchs, 1)
 
     def test13(self):
         """ Verify the functionality of the Evidence manager with IPv6 and UDP """
@@ -3160,13 +3398,13 @@ class StackLanIPv6Tests(unittest.TestCase):
             self.called_callback += 1
             flow.evidence = True
 
-        d = pyaiengine.DomainName("Google domain", ".google.com")
+        dom = pyaiengine.DomainName("Google domain", ".google.com")
 
-        dm = pyaiengine.DomainNameManager()
-        d.callback = domain_callback
-        dm.add_domain_name(d)
+        dman = pyaiengine.DomainNameManager()
+        dom.callback = domain_callback
+        dman.add_domain_name(dom)
 
-        self.stack.set_domain_name_manager(dm, "DNSProtocol")
+        self.stack.set_domain_name_manager(dman, "DNSProtocol")
 
         with pyaiengine.PacketDispatcher("../pcapfiles/ipv6_google_dns.pcap") as pdis:
             pdis.evidences = True
@@ -3174,9 +3412,9 @@ class StackLanIPv6Tests(unittest.TestCase):
             pdis.run()
 
         self.assertEqual(self.called_callback, 1)
-        self.assertEqual(d.matchs, 1)
+        self.assertEqual(dom.matchs, 1)
 
-        """ verify the integrity of the new file created """
+        # verify the integrity of the new file created
         files = glob.glob("evidences.*.pcap")
         os.remove(files[0])
 
@@ -3186,18 +3424,18 @@ class StackLanIPv6Tests(unittest.TestCase):
         when a important event happen on TCP.
         """
 
-        r = pyaiengine.Regex("my regex", b"^Upgrade.*$")
+        reg = pyaiengine.Regex("my regex", b"^Upgrade.*$")
 
-        """ Force to write the packet """
-        r.write_packet = True
+        # Force to write the packet
+        reg.write_packet = True
 
-        rm = pyaiengine.RegexManager([r])
+        rman = pyaiengine.RegexManager([reg])
 
         adaptor = DatabaseTestAdaptor()
 
         self.stack.set_tcp_database_adaptor(adaptor)
 
-        self.stack.tcp_regex_manager = rm
+        self.stack.tcp_regex_manager = rman
 
         self.inject("../pcapfiles/generic_exploit_ipv6_defcon20.pcap")
 
@@ -3207,8 +3445,8 @@ class StackLanIPv6Tests(unittest.TestCase):
         else:
             self.assertTrue(False)
 
-        """ the packet is write on the packet field of the json """
-        self.assertEqual(r.write_packet, True)
+        # the packet is write on the packet field of the json
+        self.assertEqual(reg.write_packet, True)
 
         packet = data["packet"]
         cad = "".join(str(chr(x)) for x in packet)
@@ -3217,28 +3455,28 @@ class StackLanIPv6Tests(unittest.TestCase):
     def test15(self):
         """ Verify the flush functionality of the FlowManager """
 
-        """ increase the timeout of the flows because the difference between the pcaps
-            is more than one year """
+        # increase the timeout of the flows because the difference between the pcaps
+        # is more than one year
         self.stack.flows_timeout = 60 * 60 * 500
 
         self.inject("../pcapfiles/ipv6_google_dns.pcap")
         self.inject("../pcapfiles/http_over_ipv6.pcap")
 
-        fu = self.stack.udp_flow_manager
-        ft = self.stack.tcp_flow_manager
+        udp_flows = self.stack.udp_flow_manager
+        tcp_flows = self.stack.tcp_flow_manager
 
-        self.assertEqual(len(fu), 1)
-        self.assertEqual(len(ft), 1)
+        self.assertEqual(len(udp_flows), 1)
+        self.assertEqual(len(tcp_flows), 1)
 
-        fu.flush()
+        udp_flows.flush()
 
-        self.assertEqual(len(fu), 0)
-        self.assertEqual(len(ft), 1)
+        self.assertEqual(len(udp_flows), 0)
+        self.assertEqual(len(tcp_flows), 1)
 
-        ft.flush()
+        tcp_flows.flush()
 
-        self.assertEqual(len(fu), 0)
-        self.assertEqual(len(ft), 0)
+        self.assertEqual(len(udp_flows), 0)
+        self.assertEqual(len(tcp_flows), 0)
 
     def test16(self):
         """ Test the callbacks on the RegexManager for TCP traffic """
@@ -3251,126 +3489,120 @@ class StackLanIPv6Tests(unittest.TestCase):
             self.assertEqual(flow.regex.name, "generic exploit")
             self.called_callback += 1
 
-        rm = pyaiengine.RegexManager()
-        r = pyaiengine.Regex("generic exploit", b"\\x90\\x90\\x90\\x90\\x90\\x90\\x90")
-        r.callback = callback_re
-        rm.callback = callback_rm
+        rman = pyaiengine.RegexManager()
+        reg = pyaiengine.Regex("generic exploit", b"\\x90\\x90\\x90\\x90\\x90\\x90\\x90")
+        reg.callback = callback_re
+        rman.callback = callback_rm
 
-        rm.add_regex(r)
-        self.stack.tcp_regex_manager = rm
+        rman.add_regex(reg)
+        self.stack.tcp_regex_manager = rman
 
         self.inject("../pcapfiles/generic_exploit_ipv6_defcon20.pcap")
 
         self.assertEqual(self.called_callback, 1)
-        self.assertEqual(r.matchs, 1)
+        self.assertEqual(reg.matchs, 1)
 
     def test17(self):
-        """ Extract IPv6 address from a DomainName matched on a adaptor """
+        """Extract IPv6 address from a DomainName matched on a adaptor."""
 
-        d = pyaiengine.DomainName("Google test", ".google.com")
+        dom = pyaiengine.DomainName("Google test", ".google.com")
 
-        dm = pyaiengine.DomainNameManager()
-        dm.add_domain_name(d)
+        dman = pyaiengine.DomainNameManager()
+        dman.add_domain_name(dom)
 
         adaptor = DatabaseTestAdaptor()
         self.stack.set_udp_database_adaptor(adaptor)
 
         self.inject("../pcapfiles/ipv6_google_dns.pcap")
 
-        """ There is no domainname manager attached so the ips should not be populated """
+        # There is no domainname manager attached so the ips should not be populated
         data = json.loads(adaptor.lastdata)
 
         if "dns" in data:
             if "ips" in data["dns"]:
-                self.assertTrue(False)
+                self.fail("The IPs must not be on the data")
             else:
                 self.assertTrue(True)
         else:
-            self.assertTrue(False)
+            self.fail("The DNS must be on the data")
 
         self.stack.udp_flow_manager.flush()
 
-        self.stack.set_domain_name_manager(dm, "dns")
+        self.stack.set_domain_name_manager(dman, "dns")
         self.inject("../pcapfiles/ipv6_google_dns.pcap")
 
-        """ The ips should be on the ips secction """
+        # The ips should be on the ips secction
         data = json.loads(adaptor.lastdata)
 
         if "dns" in data:
             if "ips" in data["dns"]:
                 self.assertTrue(True)
             else:
-                self.assertTrue(False)
+                self.fail("The IPs must be on the data")
         else:
-            self.assertTrue(False)
+            self.fail("The DNS must be on the data")
 
     def test18(self):
-        """ Check integrity of banned domains on DNS traffic"""
+        """Check integrity of banned domains on DNS traffic."""
 
         def domain_callback(flow):
+            self.assertIsNotNone(flow)
             self.called_callback += 1
 
-        d = pyaiengine.DomainName("Google test", ".google.com")
+        dom = pyaiengine.DomainName("Google test", ".google.com")
 
-        d.callback = domain_callback
+        dom.callback = domain_callback
 
-        dm = pyaiengine.DomainNameManager()
-        dm.add_domain_name(d)
+        dman = pyaiengine.DomainNameManager()
+        dman.add_domain_name(dom)
 
-        """ we are not interested on traffic from google """
-        self.stack.set_domain_name_manager(dm, "dns", False)
+        # we are not interested on traffic from google
+        self.stack.set_domain_name_manager(dman, "dns", False)
         self.inject("../pcapfiles/ipv6_google_dns.pcap")
 
-        """ There is no callbacks for domains that we are not
-            interested """
+        # There is no callbacks for domains that we are not
+        # interested
         self.assertEqual(self.called_callback, 0)
-        self.assertEqual(d.matchs, 1)
-        d = self.stack.get_cache("DNSProtocol")
+        self.assertEqual(dom.matchs, 1)
+        data = self.stack.get_cache_data("DNSProtocol", "name")
 
-        flow = None
-        """ just one flow on the pcap """
-        ft = self.stack.udp_flow_manager
-        for f in ft:
-            flow = f
+        flow = [flow for flow in self.stack.udp_flow_manager][0]
 
-        self.assertEqual("www.google.com" in d, False)
+        self.assertEqual("www.google.com" in data, False)
         self.assertNotEqual(flow, None)
         self.assertNotEqual(flow.dns_info, None)
         self.assertEqual(flow.dns_info.domain_name, "")
 
     def test19(self):
-        """ Check the operator * on the DomainName """
+        """Check the operator * on the DomainName."""
 
         def domain_callback(flow):
+            self.assertIsNotNone(flow)
             self.called_callback += 1
 
-        d = pyaiengine.DomainName("All domains", "*")
+        dom = pyaiengine.DomainName("All domains", "*")
 
-        d.callback = domain_callback
+        dom.callback = domain_callback
 
-        dm = pyaiengine.DomainNameManager()
-        dm.add_domain_name(d)
-        self.stack.set_domain_name_manager(dm, "dns")
+        dman = pyaiengine.DomainNameManager()
+        dman.add_domain_name(dom)
+        self.stack.set_domain_name_manager(dman, "dns")
 
         self.inject("../pcapfiles/ipv6_google_dns.pcap")
 
         self.assertEqual(self.called_callback, 1)
-        self.assertEqual(d.matchs, 1)
-        d = self.stack.get_cache("DNSProtocol")
+        self.assertEqual(dom.matchs, 1)
+        data = self.stack.get_cache_data("DNSProtocol", "name")
 
-        flow = None
-        """ just one flow on the pcap """
-        ft = self.stack.udp_flow_manager
-        for f in ft:
-            flow = f
+        flow = [flow for flow in self.stack.udp_flow_manager][0]
 
-        self.assertEqual("www.google.com" in d, True)
+        self.assertEqual("www.google.com" in data, True)
         self.assertNotEqual(flow, None)
         self.assertNotEqual(flow.dns_info, None)
         self.assertEqual(flow.dns_info.domain_name, "www.google.com")
 
     def test20(self):
-        """ disable DNS traffic"""
+        """Disable DNS traffic."""
 
         self.inject("../pcapfiles/ipv6_google_dns.pcap")
 
@@ -3403,56 +3635,97 @@ class StackLanIPv6Tests(unittest.TestCase):
         self.assertDictEqual(counters, counters3)
 
     def test21(self):
-        """ Disable and enable HTTP """
+        """Disable and enable HTTP."""
 
         self.inject("../pcapfiles/http_over_ipv6.pcap")
 
-        c = self.stack.get_counters("httP")
-        c1 = {'L7 bytes': 394393, 'heads': 0, 'responses': 11, 'puts': 0, 'packets': 318,
-              'bytes': 400490, 'connects': 0, 'options': 0, 'posts': 0, 'banned hosts': 0,
-              'others': 0, 'requests': 11, 'gets': 11, 'traces': 0, 'allow hosts': 11, 'deletes': 0}
+        counters = self.stack.get_counters("httP")
+        counters1 = {'L7 bytes': 394393, 'heads': 0, 'responses': 11, 'puts': 0, 'packets': 318,
+                     'bytes': 400490, 'connects': 0, 'options': 0, 'posts': 0, 'banned hosts': 0,
+                     'others': 0, 'requests': 11, 'gets': 11, 'traces': 0, 'allow hosts': 11,
+                     'deletes': 0}
 
-        self.assertDictEqual(c, c1)
+        self.assertDictEqual(counters, counters1)
 
-        c2 = {'bytes': 0, 'packets': 0}
-        c = self.stack.get_counters("tcpgeneric")
+        counters2 = {'bytes': 0, 'packets': 0}
+        counters = self.stack.get_counters("tcpgeneric")
 
-        self.assertDictEqual(c, c2)
+        self.assertDictEqual(counters, counters2)
 
         self.stack.tcp_flow_manager.flush()
         self.stack.disable_protocol("http")
 
         self.inject("../pcapfiles/http_over_ipv6.pcap")
 
-        c = self.stack.get_counters("httP")
-        self.assertDictEqual(c, c1)
+        counters = self.stack.get_counters("httP")
+        self.assertDictEqual(counters, counters1)
 
-        c3 = {'bytes': 400490, 'packets': 318}
-        c = self.stack.get_counters("tcpgeneric")
+        counters3 = {'bytes': 400490, 'packets': 318}
+        counters = self.stack.get_counters("tcpgeneric")
 
-        self.assertDictEqual(c, c3)
+        self.assertDictEqual(counters, counters3)
 
     def test22(self):
-        """ DHCPv6 traffic test """
+        """DHCPv6 traffic test."""
 
         self.stack.set_dynamic_allocated_memory(True)
 
         self.inject("../pcapfiles/ipv6_dhcp6.pcap")
 
-        # Test the output show_cache
-        with tempfile.TemporaryFile() as file, stdout_redirected(file):
-            self.stack.show_cache("dhcp6")
-            file.seek(0)
-            total_lines = len(file.readlines())
-            self.assertEqual(total_lines, 2)
-
-        cache = self.stack.get_cache("dhcp6")
+        data_cache = self.stack.get_cache_data("dhcp6", "host")
         cache1 = {'TSE-MANAGEMENT': 1}
-        self.assertDictEqual(cache, cache1)
+        self.assertDictEqual(data_cache, cache1)
+
+        for flow in self.stack.udp_flow_manager:
+            _ = flow.dhcp6_info.host_name
+            _ = flow.dhcp6_info.ip
+
+    def test23(self):
+        """Verify the retrieval of the internal caches on DHCPv6."""
+
+        cache_host = self.stack.get_cache("dhcp6", "host")
+        self.assertIsNotNone(cache_host)
+
+        cache_ip = self.stack.get_cache("dhcp6", "ip")
+        self.assertIsNotNone(cache_ip)
+
+        self.stack.set_dynamic_allocated_memory(True)
+
+        cache_host.dynamic_allocated_memory = False
+        cache_ip.dynamic_allocated_memory = False
+
+        self.inject("../pcapfiles/ipv6_dhcp6.pcap")
+
+        for flow in self.stack.udp_flow_manager:
+            _ = flow.dhcp6_info.host_name
+            _ = flow.dhcp6_info.ip
+            self.assertEqual(flow.dhcp6_info.host_name, "")
+            self.assertEqual(flow.dhcp6_info.ip, "")
+
+    def test24(self):
+        """Verify the functionality get the internal http caches."""
+
+        def callback_domain(flow):
+            self.called_callback += 1
+            self.assertIsNotNone(flow)
+
+        dom = pyaiengine.DomainName("Music domain", ".us.listen.com")
+
+        dman = pyaiengine.DomainNameManager()
+        dom.callback = callback_domain
+        dman.add_domain_name(dom)
+
+        self.stack.set_domain_name_manager(dman, "HTTPProtocol")
+
+        cache_host = self.stack.get_cache("http", "host")
+        self.assertIsNotNone(cache_host)
+        cache_host.destroy(cache_host.total_items)
+
+        self.inject("../pcapfiles/http_over_ipv6.pcap")
+
+        self.assertEqual(self.called_callback, 0)
+        self.assertEqual(dom.matchs, 0)
 
-        for f in self.stack.udp_flow_manager:
-            a = f.dhcp6_info.host_name
-            b = f.dhcp6_info.ip
 
 class StackLanLearningTests(unittest.TestCase):
 
@@ -3462,7 +3735,7 @@ class StackLanLearningTests(unittest.TestCase):
         self.pdis.stack = self.stack
         self.stack.tcp_flows = 2048
         self.stack.udp_flows = 1024
-        self.f = pyaiengine.FrequencyGroup()
+        self.freq = pyaiengine.FrequencyGroup()
 
     def tearDown(self):
         pass
@@ -3475,57 +3748,58 @@ class StackLanLearningTests(unittest.TestCase):
         self.pdis.close()
 
     def test01(self):
+        """Sanity test case for verify the frequencies."""
 
-        self.f.reset()
+        self.freq.reset()
         self.stack.enable_frequency_engine = True
 
         self.inject("../pcapfiles/two_http_flows_noending.pcap")
 
-        self.assertEqual(self.f.total_process_flows, 0)
-        self.assertEqual(self.f.total_computed_frequencies, 0)
+        self.assertEqual(self.freq.total_process_flows, 0)
+        self.assertEqual(self.freq.total_computed_frequencies, 0)
 
-        """ Add the TCP Flows of the FlowManager on the FrequencyEngine """
-        self.f.add_flows_by_destination_port(self.stack.tcp_flow_manager)
-        self.f.compute()
+        # Add the TCP Flows of the FlowManager on the FrequencyEngine
+        self.freq.add_flows_by_destination_port(self.stack.tcp_flow_manager)
+        self.freq.compute()
 
-        self.assertEqual(self.f.total_process_flows, 2)
-        self.assertEqual(self.f.total_computed_frequencies, 1)
+        self.assertEqual(self.freq.total_process_flows, 2)
+        self.assertEqual(self.freq.total_computed_frequencies, 1)
 
     def test02(self):
 
-        self.f.reset()
+        self.freq.reset()
         self.stack.enable_frequency_engine = True
 
         self.inject("../pcapfiles/tor_4flows.pcap")
 
-        self.assertEqual(self.f.total_process_flows, 0)
-        self.assertEqual(self.f.total_computed_frequencies, 0)
+        self.assertEqual(self.freq.total_process_flows, 0)
+        self.assertEqual(self.freq.total_computed_frequencies, 0)
 
         # Add the TCP Flows of the FlowManager on the FrequencyEngine
-        self.f.add_flows_by_destination_port(self.stack.tcp_flow_manager)
-        self.f.compute()
+        self.freq.add_flows_by_destination_port(self.stack.tcp_flow_manager)
+        self.freq.compute()
 
-        self.assertEqual(len(self.f.get_reference_flows_by_key("80")), 4)
-        self.assertEqual(len(self.f.get_reference_flows()), 4)
-        self.assertEqual(len(self.f.get_reference_flows_by_key("8080")), 0)
-        self.assertEqual(self.f.total_process_flows, 4)
-        self.assertEqual(self.f.total_computed_frequencies, 1)
+        self.assertEqual(len(self.freq.get_reference_flows_by_key("80")), 4)
+        self.assertEqual(len(self.freq.get_reference_flows()), 4)
+        self.assertEqual(len(self.freq.get_reference_flows_by_key("8080")), 0)
+        self.assertEqual(self.freq.total_process_flows, 4)
+        self.assertEqual(self.freq.total_computed_frequencies, 1)
 
     def test03(self):
-        """ Integrate with the learner to generate a regex """
+        """Integrate with the learner to generate a regex."""
         learn = pyaiengine.LearnerEngine()
 
-        self.f.reset()
+        self.freq.reset()
         self.stack.enable_frequency_engine = True
 
         self.inject("../pcapfiles/tor_4flows.pcap")
 
         # Add the TCP Flows of the FlowManager on the FrequencyEngine
-        self.f.add_flows_by_destination_port(self.stack.tcp_flow_manager)
-        self.f.compute()
+        self.freq.add_flows_by_destination_port(self.stack.tcp_flow_manager)
+        self.freq.compute()
 
-        flow_list = self.f.get_reference_flows()
-        self.assertEqual(self.f.total_computed_frequencies, 1)
+        flow_list = self.freq.get_reference_flows()
+        self.assertEqual(self.freq.total_computed_frequencies, 1)
         learn.agregate_flows(flow_list)
         learn.compute()
 
@@ -3533,7 +3807,7 @@ class StackLanLearningTests(unittest.TestCase):
 
         # Get the generated regex and compile with the regex module
         try:
-            rc = re.compile(learn.regex)
+            _ = re.compile(learn.regex)
             self.assertTrue(True)
         except:
             self.assertFalse(False)
@@ -3542,7 +3816,7 @@ class StackLanLearningTests(unittest.TestCase):
         """ Switch from normal mode to learner mode and check flow and caches status """
         learn = pyaiengine.LearnerEngine()
 
-        self.f.reset()
+        self.freq.reset()
         self.stack.enable_frequency_engine = True
 
         # The filter tcp and port 55354 will filter just one HTTP flow
@@ -3550,30 +3824,25 @@ class StackLanLearningTests(unittest.TestCase):
         self.inject("../pcapfiles/two_http_flows_noending.pcap", pcapfilter="tcp and port 55354")
 
         # Add the TCP Flows of the FlowManager on the FrequencyEngine
-        self.f.add_flows_by_destination_port(self.stack.tcp_flow_manager)
-        self.f.compute()
+        self.freq.add_flows_by_destination_port(self.stack.tcp_flow_manager)
+        self.freq.compute()
 
-        flow_list = self.f.get_reference_flows()
-        self.assertEqual(self.f.total_computed_frequencies, 1)
+        flow_list = self.freq.get_reference_flows()
+        self.assertEqual(self.freq.total_computed_frequencies, 1)
         learn.agregate_flows(flow_list)
         learn.compute()
 
         self.assertEqual(learn.flows_process, 1)
         self.assertEqual(len(self.stack.tcp_flow_manager), 1)
 
-        flow1 = None
-        flow2 = None
-        for f in self.stack.tcp_flow_manager:
-            flow1 = f
+        flow1 = [flow for flow in self.stack.tcp_flow_manager][0]
 
         # Switch to normal mode and inject the other flow
 
         self.stack.enable_frequency_engine = False
         self.inject("../pcapfiles/two_http_flows_noending.pcap", pcapfilter="tcp and port 49503")
 
-        for f in self.stack.tcp_flow_manager:
-            if f.src_port == 49503:
-                flow2 = f
+        flow2 = [flow for flow in self.stack.tcp_flow_manager if flow.src_port == 49503][0]
 
         self.assertIsNotNone(flow1)
         self.assertEqual(flow1.l7_protocol_name, "TCPFrequencyProtocol")
@@ -3595,6 +3864,7 @@ class StackLanLearningTests(unittest.TestCase):
         self.assertIsNone(flow2.frequencies)
 
 class StackVirtualTests(unittest.TestCase):
+    """Handle the test cases for the VirtualStacks."""
 
     def setUp(self):
         self.stack = pyaiengine.StackVirtual()
@@ -3608,12 +3878,14 @@ class StackVirtualTests(unittest.TestCase):
         pass
 
     def inject(self, pcapfile):
+        """Process the pcapfile."""
+
         with pyaiengine.PacketDispatcher(pcapfile) as pdis:
             pdis.stack = self.stack
             pdis.run()
 
     def test01(self):
-        """ Create a regex for a detect the flow on a virtual network """
+        """Create a regex for a detect the flow on a virtual network."""
 
         rman = pyaiengine.RegexManager()
         reg = pyaiengine.Regex("Bin directory", "^bin$")
@@ -3625,7 +3897,7 @@ class StackVirtualTests(unittest.TestCase):
         self.assertEqual(reg.matchs, 1)
 
     def test02(self):
-        """ Create a regex for a detect the flow on a virtual network on the GRE side """
+        """Create a regex for a detect the flow on a virtual network on the GRE."""
 
         rman = pyaiengine.RegexManager()
         reg = pyaiengine.Regex("Bin directory", b"^SSH-2.0.*$")
@@ -3640,7 +3912,7 @@ class StackVirtualTests(unittest.TestCase):
         self.assertEqual(len(self.stack.udp_flow_manager), 0)
 
     def test03(self):
-        """ Inject two pcapfiles with gre and vxlan traffic and verify regex """
+        """Inject two pcapfiles with gre and vxlan traffic and verify regex."""
 
         rman = pyaiengine.RegexManager()
         reg = pyaiengine.Regex("SSH activity", b"^SSH-2.0.*$")
@@ -3678,10 +3950,10 @@ class StackVirtualTests(unittest.TestCase):
         self.assertEqual(len(fu), 0)
 
     def test04(self):
-        """ Test the extraction of the tag from the flow when matches """
+        """Test the extraction of the tag from the flow when matches."""
 
         def virt_callback(flow):
-            if (flow.have_tag == True)and(flow.tag == 1):
+            if (flow.have_tag)and(flow.tag == 1):
                 self.called_callback += 1
 
         rman = pyaiengine.RegexManager()
@@ -3699,7 +3971,7 @@ class StackVirtualTests(unittest.TestCase):
         self.assertEqual(self.called_callback, 1)
 
     def test05(self):
-        """ Verify regex on the constructor for easy management """
+        """Verify regex on the constructor for easy management."""
 
         # Create a multi regex that match with different packets
         reg = pyaiengine.Regex("First that matchs", b"^SSH-2.0.*$", \
@@ -3723,77 +3995,80 @@ class StackVirtualTests(unittest.TestCase):
         self.assertEqual(reg2.matchs, 1)
         self.assertEqual(reg3.matchs, 0)
 
-        flow = None
-        for f in self.stack.tcp_flow_manager:
-            flow = f.ssh_info
-            flow = f.bitcoin_info
+        info = [flow.ssh_info for flow in self.stack.tcp_flow_manager][0]
 
-        self.assertEqual(flow, None)
+        self.assertEqual(info, None)
 
     def test06(self):
-        """ Verify regex on the constructor for easy management """
+        """Verify regex on the constructor for easy management."""
 
         # Create a regex list that match with different packets
-        rm = pyaiengine.RegexManager("Some regexs", \
-            [pyaiengine.Regex("First that matchs", b"^SSH-2.0.*$"), \
-            pyaiengine.Regex("Second dont matchs", b"^SSH-2.0.*$"), \
-            pyaiengine.Regex("Third dont matchs", b"^.*diffie-hellman.*$"), \
-            pyaiengine.Regex("Four dont that matchs", b"This can not match")])
+        rman = pyaiengine.RegexManager("Some regexs", \
+              [pyaiengine.Regex("First that matchs", b"^SSH-2.0.*$"), \
+              pyaiengine.Regex("Second dont matchs", b"^SSH-2.0.*$"), \
+              pyaiengine.Regex("Third dont matchs", b"^.*diffie-hellman.*$"), \
+              pyaiengine.Regex("Four dont that matchs", b"This can not match")])
 
-        self.stack.tcp_regex_manager = rm
+        self.stack.tcp_regex_manager = rman
         self.stack.enable_nids_engine = True
 
         self.inject("../pcapfiles/gre_ssh.pcap")
 
         # Just match the first regex
-        self.assertNotEqual(str(rm).find("Name:First that matchs         Matchs:1"), -1)
-        self.assertNotEqual(str(rm).find("Name:Second dont matchs        Matchs:0"), -1)
+        self.assertNotEqual(str(rman).find("Name:First that matchs         Matchs:1"), -1)
+        self.assertNotEqual(str(rman).find("Name:Second dont matchs        Matchs:0"), -1)
 
     def test07(self):
-        """ Enable and Disable the DHCP protocol """
+        """Enable and Disable the DHCP protocol."""
 
         self.inject("../pcapfiles/gre_dhcp.pcap")
 
-        # Test the show_cache on DHCP
-        f = tempfile.TemporaryFile()
-        with stdout_redirected(f):
-            self.stack.show_cache("dhcp")
-
-        f.close()
+        data_cache = self.stack.get_cache_data("dhcp", "host")
+        data1 = {'PAQUITO': 1}
+        self.assertDictEqual(data_cache, data1)
 
-        c = self.stack.get_cache("dhcp")
-        c1 = {'PAQUITO': 1}
-        self.assertDictEqual(c, c1)
-
-        for f in self.stack.udp_flow_manager:
-            b = f.dhcp_info.host_name
-            a = f.dhcp_info.ip
+        for flow in self.stack.udp_flow_manager:
+            _ = flow.dhcp_info.host_name
+            _ = flow.dhcp_info.ip
 
-        c1 = {'releases': 0, 'packets': 1, 'bytes': 253, 'informs': 0, 'offers': 0,
-              'discovers': 1, 'acks': 0, 'declines': 0, 'requests': 0, 'naks': 0}
-        c2 = {'bytes': 0, 'packets': 0}
-        c = self.stack.get_counters("dhcp")
+        counters1 = {'releases': 0, 'packets': 1, 'bytes': 253, 'informs': 0, 'offers': 0,
+                     'discovers': 1, 'acks': 0, 'declines': 0, 'requests': 0, 'naks': 0}
+        counters2 = {'bytes': 0, 'packets': 0}
+        counters = self.stack.get_counters("dhcp")
 
-        self.assertDictEqual(c, c1)
+        self.assertDictEqual(counters, counters1)
 
-        c = self.stack.get_counters("udpgeneric")
-        self.assertDictEqual(c, c2)
+        counters = self.stack.get_counters("udpgeneric")
+        self.assertDictEqual(counters, counters2)
 
         self.stack.udp_flow_manager.flush()
         self.stack.disable_protocol("dhcp")
 
         self.inject("../pcapfiles/gre_dhcp.pcap")
 
-        c = self.stack.get_counters("dhcp")
+        counters = self.stack.get_counters("dhcp")
+
+        self.assertDictEqual(counters, counters1)
+
+        counters3 = {'bytes': 253, 'packets': 1}
+        counters = self.stack.get_counters("udpgeneric")
+
+        self.assertDictEqual(counters, counters3)
 
-        self.assertDictEqual(c, c1)
+    def test08(self):
+        """Verify the retrieval of the internal caches on DHCP."""
 
-        c3 = {'bytes': 253, 'packets': 1}
-        c = self.stack.get_counters("udpgeneric")
+        cache = self.stack.get_cache("dhcp", "name")
+        cache.destroy(cache.total_items)
 
-        self.assertDictEqual(c, c3)
+        self.inject("../pcapfiles/gre_dhcp.pcap")
+
+        cache = self.stack.get_cache_data("dhcp", "nothing")
+        cache1 = {}
+        self.assertDictEqual(cache, cache1)
 
 class StackOpenFlowTests(unittest.TestCase):
+    """This class handlers test cases related to OpenFlow traffic."""
 
     def setUp(self):
         self.stack = pyaiengine.StackOpenFlow()
@@ -3829,7 +4104,7 @@ class StackOpenFlowTests(unittest.TestCase):
         self.assertEqual(reg2.matchs, 1)
 
     def test02(self):
-        """ Test the with statement of the PacketDispatcher """
+        """Test the with statement of the PacketDispatcher."""
 
         rman = pyaiengine.RegexManager()
         reg = pyaiengine.Regex("Bin directory", b"^\\x26\\x01")
@@ -3862,30 +4137,35 @@ class StackOpenFlowTests(unittest.TestCase):
         self.assertEqual(reg.write_packet, True)
 
     def test03(self):
-        """ Test the flowmanager flush functionality """
+        """Test the flowmanager flush functionality."""
 
         self.inject("../pcapfiles/openflow.pcap")
 
-        ft = self.stack.tcp_flow_manager
+        tcp_flows = self.stack.tcp_flow_manager
 
-        self.assertEqual(ft.flows, 1)
-        self.assertEqual(ft.process_flows, 1)
-        self.assertEqual(ft.timeout_flows, 0)
-        self.assertEqual(len(ft), 1)
+        self.assertEqual(tcp_flows.flows, 1)
+        self.assertEqual(tcp_flows.process_flows, 1)
+        self.assertEqual(tcp_flows.timeout_flows, 0)
+        self.assertEqual(len(tcp_flows), 1)
 
-        ft.flush()
+        tcp_flows.flush()
 
-        self.assertEqual(ft.flows, 0)
-        self.assertEqual(ft.process_flows, 1)
-        self.assertEqual(ft.timeout_flows, 0)
-        self.assertEqual(len(ft), 0)
+        self.assertEqual(tcp_flows.flows, 0)
+        self.assertEqual(tcp_flows.process_flows, 1)
+        self.assertEqual(tcp_flows.timeout_flows, 0)
+        self.assertEqual(len(tcp_flows), 0)
 
     def test04(self):
-        """ Test DNS query on openflow """
+        """Verify DNS query on openflow, be aware that the pcapfile
+           contains one openflow flow and two dns, one query and one
+           response that are different each other."""
+
         def domain_callback(flow):
             self.assertNotEqual(flow.dns_info, None)
             self.assertEqual(flow.dns_info.domain_name, "daisy.ubuntu.com")
             self.called_callback += 1
+            self.assertEqual(flow.upstream_ttl, 62)
+            self.assertEqual(flow.downstream_ttl, 0)
 
         dom = pyaiengine.DomainName("test", ".ubuntu.com")
 
@@ -3901,7 +4181,7 @@ class StackOpenFlowTests(unittest.TestCase):
 
         self.inject("../pcapfiles/openflow_dns.pcap")
 
-        cache = self.stack.get_cache("DNSProtocol")
+        cache = self.stack.get_cache_data("DNSProtocol", "name")
         cache1 = {'daisy.ubuntu.com': 2}
 
         self.assertDictEqual(cache, cache1)
@@ -3911,17 +4191,21 @@ class StackOpenFlowTests(unittest.TestCase):
         # Verify the output of adaptor
         data = json.loads(adaptor.lastdata)
 
-        data1 = {u'dns': {u'domain': u'daisy.ubuntu.com', u'ips': [u'91.189.92.55', u'91.189.92.57'], \
-                 u'matchs': u'test', u'qtype': 0}, u'layer7': u'dns', u'packets': 1, u'proto': 17,
+        data1 = {u'dns': {u'domain': u'daisy.ubuntu.com',
+                          u'ips': [u'91.189.92.55', u'91.189.92.57'],
+                          u'matchs': u'test', u'qtype': 0}, 
+                 u'layer7': u'dns', u'packets': 1, u'proto': 17,
                  u'ip': {u'src': u'129.21.3.17', u'dst': u'192.168.2.6'},
                  u'evidence': False,
+                 u'upstream_ttl':62,
+                 u'downstream_ttl':0,
                  u'bytes': 94, u'anomaly': 6, u'port': {u'src': 53, u'dst': 28848}}
 
-        # print(json.dumps(d, sort_keys=True, indent=4, separators=(',', ': ')))
+        # print(json.dumps(data, sort_keys=True, indent=4, separators=(',', ': ')))
         self.assertDictEqual(data, data1)
 
     def test05(self):
-        """ Enable and disable DNS protocol """
+        """Enable and disable DNS protocol."""
 
         self.inject("../pcapfiles/openflow_dns.pcap")
 
@@ -3931,27 +4215,27 @@ class StackOpenFlowTests(unittest.TestCase):
               'queries': 1, 'allow queries': 1, 'banned queries': 0, 'type PTR': 0, 'type A': 1}
 
         c2 = {'bytes': 0, 'packets': 0}
-        c = self.stack.get_counters("DNSProtocol")
+        counters = self.stack.get_counters("DNSProtocol")
 
-        self.assertDictEqual(c, c1)
+        self.assertDictEqual(counters, c1)
 
-        c = self.stack.get_counters("udpgenericprotocol")
+        counters = self.stack.get_counters("udpgenericprotocol")
 
-        self.assertDictEqual(c, c2)
+        self.assertDictEqual(counters, c2)
 
         self.stack.udp_flow_manager.flush()
 
         self.stack.disable_protocol("dns")
         self.inject("../pcapfiles/openflow_dns.pcap")
 
-        c = self.stack.get_counters("DNSProtocol")
+        counters = self.stack.get_counters("DNSProtocol")
 
-        self.assertDictEqual(c, c1)
+        self.assertDictEqual(counters, c1)
 
         c3 = {'bytes': 120, 'packets': 2}
-        c = self.stack.get_counters("udpgenericprotocol")
+        counters = self.stack.get_counters("udpgenericprotocol")
 
-        self.assertDictEqual(c, c3)
+        self.assertDictEqual(counters, c3)
 
         # Test the output of show_anomalies and show_protocol_statistics
         with tempfile.TemporaryFile() as file, stdout_redirected(file):
@@ -3967,7 +4251,8 @@ class PacketDispatcherTests(unittest.TestCase):
         del self.pdis
 
     def test01(self):
-        """ The packet dispatcher should process the packets without stack """
+        """The packet dispatcher should process the packets without stack."""
+
         self.pdis.open("../pcapfiles/vxlan_ftp.pcap")
         self.pdis.run()
         # self.pdis.show_current_packet()
@@ -3981,7 +4266,8 @@ class PacketDispatcherTests(unittest.TestCase):
         self.assertEqual(self.pdis.is_packet_accepted, True)
 
     def test02(self):
-        """ check the port functionality """
+        """Check the port functionality."""
+
         self.pdis.open("../pcapfiles/vxlan_ftp.pcap")
         self.pdis.enable_shell = True
 
@@ -3993,8 +4279,8 @@ class PacketDispatcherTests(unittest.TestCase):
 
         # The socket should be in use
         try:
-            """ Use psutil for verify if the current process have a socket open on
-                the port """
+            # Use psutil for verify if the current process have a socket open on
+            # the port.
             import psutil
 
             proc = psutil.Process(os.getpid())
@@ -4007,7 +4293,8 @@ class PacketDispatcherTests(unittest.TestCase):
         self.pdis.close()
 
     def test03(self):
-        """ Run the dispatcher of a unknown device name """
+        """Run the dispatcher of a unknown device name."""
+
         self.pdis.open("I_dont think this will work")
         self.pdis.run()
         self.pdis.close()
@@ -4015,7 +4302,7 @@ class PacketDispatcherTests(unittest.TestCase):
         self.assertEqual(self.pdis.packets, 0)
 
     def test04(self):
-        """ Test case for the add_timer functionality """
+        """Test case for the add_timer functionality."""
 
         def timer1():
             pass
@@ -4060,7 +4347,7 @@ class StackMobileIPv6Tests(unittest.TestCase):
             pdis.run()
 
     def test01(self):
-        """ Verify the integrity of the sip fields """
+        """Verify the integrity of the sip fields."""
 
         adaptor = DatabaseTestAdaptor()
 
@@ -4081,7 +4368,7 @@ class StackMobileIPv6Tests(unittest.TestCase):
         self.assertDictEqual(counters, counters1)
 
     def test02(self):
-        """ Verify the integrity of the sip fields """
+        """Verify the integrity of the sip fields."""
 
         adaptor = DatabaseTestAdaptor()
 
@@ -4111,20 +4398,13 @@ class StackMobileIPv6Tests(unittest.TestCase):
         self.assertEqual(counters["responses"], 2)
         self.assertEqual(counters["registers"], 0)
 
-        cache = self.stack.get_cache("SIP")
-
-        # print the output of the cache
-        with tempfile.TemporaryFile() as file, stdout_redirected(file):
-            self.stack.show_cache("SIP")
-            file.seek(0)
-            total_lines = len(file.readlines())
-            self.assertEqual(total_lines, 3)
+        data_cache = self.stack.get_cache_data("SIP", "via")
+        self.assertEqual(len(data_cache), 1)
 
     def test03(self):
-        """ Verify the integrity of the DNS traffic """
+        """Verify the integrity of the DNS traffic."""
 
-        def callback_domain(flow):
-            # pylint: disable=unused-argument
+        def callback_domain(_):
             self.called_callback += 1
 
         dom = pyaiengine.DomainName("Some domain", ".org")
@@ -4144,12 +4424,16 @@ class StackMobileIPv6Tests(unittest.TestCase):
         self.assertEqual(self.called_callback, 1)
 
         data = json.loads(adaptor.lastdata)
-        self.assertEqual(data["ip"]["src"], "2001:507:0:1:200:8600:0:1")
-        self.assertEqual(data["ip"]["dst"], "2001:507:0:1:200:8600:0:2")
+        if (sys.platform == 'darwin'):
+            self.assertEqual(data["ip"]["src"], "2001:507::1:200:8600:0:1")
+            self.assertEqual(data["ip"]["dst"], "2001:507::1:200:8600:0:2")
+        else:
+            self.assertEqual(data["ip"]["src"], "2001:507:0:1:200:8600:0:1")
+            self.assertEqual(data["ip"]["dst"], "2001:507:0:1:200:8600:0:2")
         self.assertEqual(data["dns"]["domain"], "itojun.org")
 
     def test04(self):
-        """ Verify the integrity of the SSL traffic """
+        """Verify the integrity of the SSL traffic."""
 
         def callback_domain(flow):
             self.called_callback += 1
@@ -4186,7 +4470,7 @@ class StackMobileIPv6Tests(unittest.TestCase):
         self.assertEqual(data["ssl"]["issuer"], "DigiCert SHA2 Secure Server CA")
 
     def test05(self):
-        """ Verify DomainName with IPSets on TCP traffic """
+        """Verify DomainName with IPSets on TCP traffic."""
 
         def callback_ipset(flow):
             self.called_callback += 1
@@ -4205,7 +4489,9 @@ class StackMobileIPv6Tests(unittest.TestCase):
         self.stack.set_domain_name_manager(dman, "SSLProtocol")
 
         ipset = pyaiengine.IPSet("IPv6 generic set", \
-            ["2001:507:0:1:200:8600:0:2", "2001:507:0:1:200:8600:0:100"])
+            ["2001:507:0:1:200:8600:0:2",
+             "2001:507::1:200:8600:0:2",
+             "2001:507:0:1:200:8600:0:100"])
         ipset.callback = callback_ipset
         im = pyaiengine.IPSetManager()
 
@@ -4217,7 +4503,7 @@ class StackMobileIPv6Tests(unittest.TestCase):
         self.assertEqual(self.called_callback, 2)
 
     def test06(self):
-        """ Verify Regex with IPSets on UDP traffic """
+        """Verify Regex with IPSets on UDP traffic."""
 
         def callback_ipset(flow):
             self.called_callback += 1
@@ -4247,10 +4533,10 @@ class StackMobileIPv6Tests(unittest.TestCase):
         self.assertEqual(self.called_callback, 2)
 
     def test07(self):
-        """ Verify the change of execution by changing the regex_manager of the flow """
+        """Verify the change of execution by changing the regex_manager of the flow."""
 
         def callback1(flow):
-            """ 
+            """
             On a regular execution, without changing the regex_manager, the flow
             will stop the check of new regex, because there is one that matches.
             However, by changing the matched RegexManager to other value we tell
@@ -4323,8 +4609,31 @@ class StackMobileIPv6Tests(unittest.TestCase):
         self.assertIn("matchs", data)
         self.assertEqual(data["matchs"], "Rule3")
 
+    def test08(self):
+        """Verify the functionality of the internal caches."""
+
+        cache = self.stack.get_cache("DNSProtocol", "name")
+        cache.destroy(cache.total_items)
+
+        adaptor = DatabaseTestAdaptor()
+
+        self.stack.set_udp_database_adaptor(adaptor)
+
+        self.inject("../pcapfiles/gtp_ip6_dns.pcap")
+
+        data = json.loads(adaptor.lastdata)
+
+        if (sys.platform == 'darwin'):
+            self.assertEqual(data["ip"]["src"], "2001:507::1:200:8600:0:1")
+            self.assertEqual(data["ip"]["dst"], "2001:507::1:200:8600:0:2")
+        else:
+            self.assertEqual(data["ip"]["src"], "2001:507:0:1:200:8600:0:1")
+            self.assertEqual(data["ip"]["dst"], "2001:507:0:1:200:8600:0:2")
+
+        self.assertNotIn("domain", data["dns"])
+
 class StackLanHTTPServerTests(unittest.TestCase):
-    """ Verify the functionality of the http interface """
+    """Verify the functionality of the HTTP interface."""
 
     @classmethod
     def setUpClass(cls):
@@ -4364,7 +4673,8 @@ class StackLanHTTPServerTests(unittest.TestCase):
         self.proc.terminate()
 
     def test01(self):
-        """ Test the /aiengine/protocols/summary URI """
+        """Test the /aiengine/protocols/summary URI."""
+
         uri = "http://127.0.0.1:" + str(self.port) + "/aiengine/protocols/summary"
         headers = {}
         res = requests.get(uri, headers=headers)
@@ -4377,7 +4687,8 @@ class StackLanHTTPServerTests(unittest.TestCase):
         self.assertEqual(res.status_code, 200)
 
     def test02(self):
-        """ Test the /aiengine/flows URI """
+        """Test the /aiengine/flows URI."""
+
         uri = "http://127.0.0.1:" + str(self.port) + "/aiengine/flows"
         headers = {}
         res = requests.get(uri, headers=headers)
@@ -4400,7 +4711,8 @@ class StackLanHTTPServerTests(unittest.TestCase):
         self.assertEqual(res.text.startswith("Flows on memory"), True)
 
     def test03(self):
-        """ Test the /aiengine/protocol/ URI """
+        """Test the /aiengine/protocol/ URI."""
+
         headers = {}
         uri = "http://127.0.0.1:" + str(self.port) + "/aiengine/protocol/dns"
         res = requests.get(uri, headers=headers)
@@ -4424,15 +4736,16 @@ class StackLanHTTPServerTests(unittest.TestCase):
         self.assertGreater(res.text.find("Name cache statistics"), 0)
 
     def test04(self):
-        """ Test the /aiengine/protocol/ URI but with JSON format """
+        """Test the /aiengine/protocol/ URI but with JSON format."""
+
         headers = {"Accept" : "application/json"}
-        protos = ["dns", "http", "ip", "tcp", "udp", "pop", "smtp", "bitcoin"]
-        protos += ["icmp", "imap", "ssl", "ssdp", "ssh", "modbus", "mqtt", "smb"]
-        protos += ["dcerpc", "tcpgeneric", "sip", "dhcp", "ntp", "snmp", "netbios"]
-        protos += ["coap", "rtp", "quic", "udpgeneric"]
+        protocols = ["dns", "http", "ip", "tcp", "udp", "pop", "smtp", "bitcoin"]
+        protocols += ["icmp", "imap", "ssl", "ssdp", "ssh", "modbus", "mqtt", "smb"]
+        protocols += ["dcerpc", "tcpgeneric", "sip", "dhcp", "ntp", "snmp", "netbios"]
+        protocols += ["coap", "rtp", "quic", "udpgeneric"]
 
-        for p in protos:
-            uri = "http://127.0.0.1:" + str(self.port) + "/aiengine/protocol/%s/5" % p
+        for proto in protocols:
+            uri = "http://127.0.0.1:" + str(self.port) + "/aiengine/protocol/%s/5" % proto
             res = requests.get(uri, headers=headers)
             self.assertEqual(res.status_code, 200)
             jres = res.json()
@@ -4443,7 +4756,8 @@ class StackLanHTTPServerTests(unittest.TestCase):
             self.assertIn("bytes", jres)
 
     def test05(self):
-        """ Test the /aiengine/summary URI """
+        """Test the /aiengine/summary URI."""
+
         headers = {}
 
         uri = "http://127.0.0.1:" + str(self.port) + "/aiengine/summary"
@@ -4462,7 +4776,8 @@ class StackLanHTTPServerTests(unittest.TestCase):
         self.assertEqual(jres["shell"], False)
 
     def test06(self):
-        """ Test the /aiengine/system URI """
+        """Test the /aiengine/system URI."""
+
         headers = {}
 
         uri = "http://127.0.0.1:" + str(self.port) + "/aiengine/system"
@@ -4583,17 +4898,18 @@ class StackLanHTTPServerTests(unittest.TestCase):
         res = requests.get(uri, headers=headers)
         self.assertEqual(res.status_code, 200)
 
-        jres = res.json()
+        flows = res.json()
 
-        ff = None
+        flow = None
         # Dont know if there will be more network flows on lo
-        for f in jres:
-            if f["layer7"] == "dns":
-                ff = f
+        flow = [flow for flow in flows if flow["layer7"] == "dns"]
 
-        self.assertNotEqual(ff, None)
-        flowid = "[%s:%d]:%d:[%s:%d]" % \
-            (ff["ip"]["src"], ff["port"]["src"], ff["proto"], ff["ip"]["dst"], ff["port"]["dst"])
+        flow = flow[0]
+        self.assertNotEqual(flow, None)
+
+        flowid = "[%s:%d]" % (flow["ip"]["src"], flow["port"]["src"])
+        flowid += ":%d:" % (flow["proto"])
+        flowid += "[%s:%d]" % (flow["ip"]["dst"], flow["port"]["dst"])
 
         # Get the flow in plain format
         headers = {}
@@ -4610,7 +4926,11 @@ class StackLanHTTPServerTests(unittest.TestCase):
 
         # Get the flow in JSON format but the flow dont exists
         headers = {"Accept" : "application/json"}
-        flowid = "[%s:%d]:%d:[%s:%d]" % (ff["ip"]["src"], ff["port"]["src"], ff["proto"], ff["ip"]["dst"], ff["port"]["dst"] + 1)
+
+        flowid = "[%s:%d]" % (flow["ip"]["src"], flow["port"]["src"])
+        flowid += ":%d:" % (flow["proto"])
+        flowid += "[%s:%d]" % (flow["ip"]["dst"], flow["port"]["dst"] + 1)
+
         uri = "http://127.0.0.1:" + str(self.port) + "/aiengine/flow/" + flowid
         res = requests.get(uri, headers=headers)
         self.assertEqual(res.status_code, 404)
@@ -4679,7 +4999,7 @@ class StackLanHTTPServerTests(unittest.TestCase):
         self.assertEqual(jres["objects"][variable_name], "int")
 
     def test14(self):
-        """ 
+        """
         Full test that interacts with different uris to modify
         the behavior of the running engine.
 
@@ -4732,12 +5052,14 @@ class StackLanHTTPServerTests(unittest.TestCase):
         self.assertTrue(jres[0]["packets"] > 8)
         self.assertTrue(jres[1]["packets"] > 8)
 
-        if defined("HAVE_JA3") == True:
+        if defined("HAVE_JA3"):
             self.assertEqual(jres[0]["ssl"]["fingerprint"], "2b356f3492005681e356a72c1e4fd879")
             self.assertEqual(jres[1]["ssl"]["fingerprint"], "2b356f3492005681e356a72c1e4fd879")
 
-        self.assertEqual(jres[0]["ssl"]["session"], "d7589284b1eecb5896a463486bace2a6569170c2e6bfa5e8329f93ef7806704c")
-        self.assertEqual(jres[1]["ssl"]["session"], "d7589284b1eecb5896a463486bace2a6569170c2e6bfa5e8329f93ef7806704c")
+        self.assertEqual(jres[0]["ssl"]["session"], 
+                         "d7589284b1eecb5896a463486bace2a6569170c2e6bfa5e8329f93ef7806704c")
+        self.assertEqual(jres[1]["ssl"]["session"], 
+                         "d7589284b1eecb5896a463486bace2a6569170c2e6bfa5e8329f93ef7806704c")
         self.assertEqual(jres[0]["ssl"]["host"], "gw.alicdn.com")
         self.assertEqual(jres[1]["ssl"]["host"], "gw.alicdn.com")
 
@@ -4753,7 +5075,7 @@ class StackLanHTTPServerTests(unittest.TestCase):
         jres = res.json()
         self.assertIn("d7589284b1eecb5896a463486bace2a6569170c2e6bfa5e8329f93ef7806704c", jres)
 
-        if defined("HAVE_JA3") == True:
+        if defined("HAVE_JA3"):
             uri = "http://127.0.0.1:" + str(self.port) + "/aiengine/protocol/ssl/map/fingerprints"
             res = requests.get(uri, headers=headers)
             self.assertEqual(res.status_code, 200)
@@ -4879,17 +5201,18 @@ class StackLanWithFrequenciesHTTPServerTests(unittest.TestCase):
         sys.exit(0)
 
     def setUp(self):
-        self.p = Process(target=self.__service)
-        self.p.daemon = True
-        self.p.start()
+        self.proc = Process(target=self.__service)
+        self.proc.daemon = True
+        self.proc.start()
         time.sleep(1)
 
     def tearDown(self):
         # Stop and delete the server
-        self.p.terminate()
+        self.proc.terminate()
 
     def test01(self):
-        """ Upload a pcap file and analyze with frequencies """
+        """Upload a pcap file and analyze with frequencies."""
+
         headers = {}
         file = open("../pcapfiles/dcerpc_traffic.pcapng", "rb")
         files = {"file": file}
@@ -4913,7 +5236,8 @@ class StackLanWithFrequenciesHTTPServerTests(unittest.TestCase):
             self.assertIn("frequencies", flow)
 
     def test02(self):
-        """ Upload a ssh pcap file and analyze with frequencies """
+        """Upload a ssh pcap file and analyze with frequencies."""
+
         headers = {}
 
         file = open("../pcapfiles/ssh_flow.pcap", "rb")
@@ -4930,11 +5254,8 @@ class StackLanWithFrequenciesHTTPServerTests(unittest.TestCase):
         self.assertEqual(res.status_code, 200)
 
         jres = res.json()
-        flow = None
-        for f in jres:
-            if f["layer7"] == "tcpfrequency":
-                flow = f
-                break
+
+        flow = [flow for flow in jres][0]
 
         self.assertNotEqual(flow, None)
         self.assertGreater(flow["dispersion"], 240)
@@ -4942,9 +5263,9 @@ class StackLanWithFrequenciesHTTPServerTests(unittest.TestCase):
 
 if __name__ == "__main__":
 
-    logfile = "aiengine-00000.log"
-    if os.path.isfile(logfile):
-        os.remove(logfile)
+    log_file = "aiengine-00000.log"
+    if os.path.isfile(log_file):
+        os.remove(log_file)
 
     unittest.main()
 
